<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-11-09T22:15:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JINJEONIMUM</title><subtitle></subtitle><author><name>JinJeon</name></author><entry><title type="html">백준 7576번</title><link href="http://localhost:4000/algorithm/2022/11/09/7576/" rel="alternate" type="text/html" title="백준 7576번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/7576</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/7576/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/7576">QUESTION LINK</a></strong></p>

<p>익은 토마토가 위치한 곳에서 한 번씩 BFS를 시행해, 하루가 지날 때마다 근처 토마토가 익은 것으로 만드는 형식을 적용하고자 했습니다. 즉, 이를 위해서 익은 토마토가 있는 위치 ‘1’ 좌표를 찾아내고, 이 곳에서 BFS가 순차적으로 발생하는 것으로 하고자 구상했습니다. 생각한 순서는 아래와 같습니다.</p>

<ol>
  <li>모든 익은 토마토(’1’)의 좌표 구하기</li>
  <li>하루가 지날 때마다(<code class="language-plaintext highlighter-rouge">day+=1;</code>) 익은 토마토의 좌표로부터 근접한 덜 익은 토마토(’0’)의 값을 ‘1’로 바꾸기</li>
  <li>다음 하루가 지날 때마다 2번과 같은 과정 반복하기</li>
  <li>인접한 곳에 덜 익은 토마토(’0’)가 없을 시 과정 중단하기</li>
</ol>

<h3 id="성공은-했으나-시간-초과">성공은 했으나 시간 초과</h3>

<p>이를 위해, 아래와 같은 코드를 구상했으며, 이를 통해 순차적으로 토마토가 익는 과정을 그려낼 수 있었습니다. 하지만, <strong>시간 초과</strong>가 발생해, 추가적인 수정이 필요했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 첫 익은 토마토가 있는 위치를 받음</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// queue에 들어갈 형태를 만드는 함수</span>

<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// 익은 토마토가 있을 경우, queue 배열에 담아줌</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문 여부를 나타내는 객체</span>
<span class="kd">let</span> <span class="nx">day</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 날짜를 나타냄. 하루가 지나는 것을 확인할 때마다 1씩 오름</span>
<span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>
<span class="c1">// 반복문에서 현재의 위치를 나타내는 값</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
  <span class="c1">// queue에서 가장 처음 요소를 가져와, BFS로 순환하도록 함</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
  <span class="c1">// 좌표 및 날짜를 가져옴</span>
  <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">-1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 방문하지 않았고, 토마토가 있는 경우에만 추가 작업 시행함</span>
    <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="c1">// 방문했음을 표기</span>
    <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">;</span>
    <span class="c1">// 토마토가 있었다는 표기</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">day</span> <span class="o">&lt;</span> <span class="nx">curDay</span><span class="p">)</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">curDay</span><span class="p">;</span>
    <span class="c1">// 현재 설정된 날짜보다 많은 날짜가 지나갔을 시, 그 날짜로 수정</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="c1">// 주변 토마토들을 체크하기 위해 날짜가 하루 더해진 값(curDay + 1)을 대입함</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">isFailed</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// 모든 토마토가 순환한 후, 방문하지 못한 곳이 존재할 시 -1로 변경</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isFailed</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="nx">day</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="시간-초과-원인-제거하기">시간 초과 원인 제거하기</h3>

<p>이 코드에서 시간 초과가 나오게 된 원인 중 하나로, <code class="language-plaintext highlighter-rouge">queue.shift()</code> 부분이 있으며, 이 부분은 <code class="language-plaintext highlighter-rouge">index</code>로 받아 처리하는 방법으로 해결이 가능했습니다. 그리고 다른 원인 중 하나는 위 코드에서 일단 방문한 적이 있는 지를 확인하고 추가적인 작업을 하는게 아니라, 우선 <code class="language-plaintext highlighter-rouge">queue</code>에 담은 뒤, 추가 작업에서 방문 여부를 확인하고 진행하도록 설정이 되어있었습니다. 이로 인해 불필요한 작업이 반복되는 경우가 많아져, 이 부분들을 모두 제외하고 코드를 수정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">toString</span><span class="p">().</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">value</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 주변 좌표로 넘어가는 부분의 중복을 없애기 위해 만든 위치 변수들</span>
<span class="kd">const</span> <span class="nx">positionValue</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">];</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// 이전과 달라진 부분. 좌표와 날짜를 받고, 이상이 없을 시 queue에 들어가도록 설정함</span>
<span class="kd">const</span> <span class="nx">checkPosition</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">&gt;=</span> <span class="nx">m</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">};</span>

<span class="c1">// 이전과 달리, queue에 들어가기 전 방문 여부를 체크해 중복 확인이 발생하지 않도록 함</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">let</span> <span class="nx">targetIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">day</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

<span class="c1">// 기존에 queue에서 직접 빼던 방식과 달리, queue내에서 index를 통해 빼낸 것과 동일한 효과로 필요한 값들을 꺼냄</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">[</span><span class="nx">targetIdx</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">targetIdx</span><span class="p">];</span>
  <span class="nx">targetIdx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">value</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">-1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">day</span> <span class="o">&lt;</span> <span class="nx">curDay</span><span class="p">)</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">curDay</span><span class="p">;</span>
    <span class="c1">// 주변 위치로 이동하도록 설정하는 부분</span>
    <span class="nx">positionValue</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">dy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">checkPosition</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">isFailed</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">some</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">some</span><span class="p">((</span><span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isFailed</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="nx">day</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>🔎 <strong>위와 같이 수정을 하여, 백준에서 통과를 하기는 했습니다. 하지만, 이 코드의 경우에도 시간이 상당히 오래 걸려 통과가 됐기 때문에 가능하다면 자바스크립트에서 더 빠르게 처리하는 코드를 찾아보아야 합니다.</strong></p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 익은 토마토가 위치한 곳에서 한 번씩 BFS를 시행해, 하루가 지날 때마다 근처 토마토가 익은 것으로 만드는 형식을 적용하고자 했습니다. 즉, 이를 위해서 익은 토마토가 있는 위치 ‘1’ 좌표를 찾아내고, 이 곳에서 BFS가 순차적으로 발생하는 것으로 하고자 구상했습니다. 생각한 순서는 아래와 같습니다. 모든 익은 토마토(’1’)의 좌표 구하기 하루가 지날 때마다(day+=1;) 익은 토마토의 좌표로부터 근접한 덜 익은 토마토(’0’)의 값을 ‘1’로 바꾸기 다음 하루가 지날 때마다 2번과 같은 과정 반복하기 인접한 곳에 덜 익은 토마토(’0’)가 없을 시 과정 중단하기 성공은 했으나 시간 초과 이를 위해, 아래와 같은 코드를 구상했으며, 이를 통해 순차적으로 토마토가 익는 과정을 그려낼 수 있었습니다. 하지만, 시간 초과가 발생해, 추가적인 수정이 필요했습니다. const [numbers, ...graph] = input; const [m, n] = numbers.split(" ").map((value) =&gt; Number(value)); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const queue = []; // 첫 익은 토마토가 있는 위치를 받음 const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, day) =&gt; `${getMarker(y, x)},${day}`; // queue에 들어갈 형태를 만드는 함수 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "1") queue.push(getQueueItem(lineIndex, boxIndex, 0)); // 익은 토마토가 있을 경우, queue 배열에 담아줌 }); }); const visited = {}; // 방문 여부를 나타내는 객체 let day = 0; // 날짜를 나타냄. 하루가 지나는 것을 확인할 때마다 1씩 오름 let curItem; // 반복문에서 현재의 위치를 나타내는 값 while (queue.length) { curItem = queue.shift(); // queue에서 가장 처음 요소를 가져와, BFS로 순환하도록 함 const [y, x, curDay] = curItem.split(",").map((value) =&gt; Number(value)); // 좌표 및 날짜를 가져옴 const curValue = graphBoxes[y][x]; const curMarker = getMarker(y, x); if (!visited[curMarker] &amp;&amp; curValue !== "-1") { // 방문하지 않았고, 토마토가 있는 경우에만 추가 작업 시행함 visited[curMarker] = true; // 방문했음을 표기 graphBoxes[y][x] = "1"; // 토마토가 있었다는 표기 if (day &lt; curDay) day = curDay; // 현재 설정된 날짜보다 많은 날짜가 지나갔을 시, 그 날짜로 수정 if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, curDay + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, curDay + 1)); if (y + 1 &lt; n) queue.push(getQueueItem(y + 1, x, curDay + 1)); if (x + 1 &lt; m) queue.push(getQueueItem(y, x + 1, curDay + 1)); // 주변 토마토들을 체크하기 위해 날짜가 하루 더해진 값(curDay + 1)을 대입함 } } const isFailed = !!graphBoxes.find((line) =&gt; line.find((box) =&gt; box === "0")); // 모든 토마토가 순환한 후, 방문하지 못한 곳이 존재할 시 -1로 변경 const result = isFailed ? -1 : day; console.log(result); 시간 초과 원인 제거하기 이 코드에서 시간 초과가 나오게 된 원인 중 하나로, queue.shift() 부분이 있으며, 이 부분은 index로 받아 처리하는 방법으로 해결이 가능했습니다. 그리고 다른 원인 중 하나는 위 코드에서 일단 방문한 적이 있는 지를 확인하고 추가적인 작업을 하는게 아니라, 우선 queue에 담은 뒤, 추가 작업에서 방문 여부를 확인하고 진행하도록 설정이 되어있었습니다. 이로 인해 불필요한 작업이 반복되는 경우가 많아져, 이 부분들을 모두 제외하고 코드를 수정했습니다. const input = fs.readFileSync(filePath).toString().trim().split("\n"); const [numbers, ...graph] = input; const [m, n] = numbers.split(" ").map((value) =&gt; +value); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const queue = []; const visited = {}; // 주변 좌표로 넘어가는 부분의 중복을 없애기 위해 만든 위치 변수들 const positionValue = [ [-1, 0], [1, 0], [0, -1], [0, 1], ]; const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, day) =&gt; `${getMarker(y, x)},${day}`; // 이전과 달라진 부분. 좌표와 날짜를 받고, 이상이 없을 시 queue에 들어가도록 설정함 const checkPosition = (y, x, day) =&gt; { if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) return; const marker = getMarker(y, x); if (visited[marker]) return; visited[marker] = true; queue.push(getQueueItem(y, x, day + 1)); }; // 이전과 달리, queue에 들어가기 전 방문 여부를 체크해 중복 확인이 발생하지 않도록 함 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "1") { visited[getMarker(lineIndex, boxIndex)] = true; queue.push(getQueueItem(lineIndex, boxIndex, 0)); } }); }); let targetIdx = 0; let day = 0; let curItem; // 기존에 queue에서 직접 빼던 방식과 달리, queue내에서 index를 통해 빼낸 것과 동일한 효과로 필요한 값들을 꺼냄 while (queue[targetIdx]) { curItem = queue[targetIdx]; targetIdx += 1; const [y, x, curDay] = curItem.split(",").map((value) =&gt; +value); const curValue = graphBoxes[y][x]; if (curValue !== "-1") { graphBoxes[y][x] = "1"; if (day &lt; curDay) day = curDay; // 주변 위치로 이동하도록 설정하는 부분 positionValue.forEach(([dy, dx]) =&gt; checkPosition(y + dy, x + dx, curDay)); } } const isFailed = !!graphBoxes.some((line) =&gt; line.some((box) =&gt; box === "0")); const result = isFailed ? -1 : day; console.log(result); 🔎 위와 같이 수정을 하여, 백준에서 통과를 하기는 했습니다. 하지만, 이 코드의 경우에도 시간이 상당히 오래 걸려 통과가 됐기 때문에 가능하다면 자바스크립트에서 더 빠르게 처리하는 코드를 찾아보아야 합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 14940번</title><link href="http://localhost:4000/algorithm/2022/11/09/14940/" rel="alternate" type="text/html" title="백준 14940번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/14940</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/14940/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/14940">QUESTION LINK</a></strong></p>

<p>그래프 순회를 하여 기준점으로부터의 거리값을 구하는 문제였습니다. 이 문제의 경우, BFS를 통해 한 점으로 부터 사방으로 이동할 때마다 이동거리를 한 칸 넓히는 방식을 통해 각 칸에서의 길이를 구하면 되었습니다.</p>

<h3 id="잘못된-풀이--각-점으로-부터-2까지의-거리-구하기">잘못된 풀이 : 각 점으로 부터 ‘2’까지의 거리 구하기</h3>

<p>하지만, 초반에 잘못된 방법으로 풀고자 하여, 기준점을 “2”에 두는 것이 아닌, 모든 각각의 점에 대해 기준점을 두고 2까지 가는 데에 필요한 길이를 구하는 방식으로 진행을 하여, 아래와 같은 코드가 나왔고, 이로 인해 <strong>‘시간 초과’</strong>가 계속해서 나오는 문제가 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">M</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">)].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nx">M</span><span class="p">)]);</span>
<span class="c1">// 결과를 담을 배열</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">floor</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">checkBox</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 0일 때 그 위치의 값은 0으로 설정</span>
    <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2일 때 그 위치의 값은 0으로 설정</span>
    <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문여부를 확인하는 객체</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
  <span class="c1">// 최초 값은 함수를 통해 들어온 위치</span>
  <span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 해당 박스의 좌표와 몇 번을 거쳐 왔는지 나타내는 floor 값</span>
    <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 2인 경우 추가적인 queue를 넣지 않고 거쳐온 정도를 넣어준 뒤 종료</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">floor</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 1인 경우 주변 요소도 확인하도록 queue에 push</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">M</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 문제가 되었던 곳. 모든 값을 돌아 길이를 구하려 해서 시간이 늘어남</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">checkBox</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">resultArray</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>위 코드로 작성해, 모든 값에 대한 길이를 구하다보니 시간이 늘어나게 되어 이를 해결하기 위한 다른 방법을 찾게 되었습니다.</p>

<h3 id="2를-시작점으로-설정하고-주변-길이-구하기">‘2’를 시작점으로 설정하고 주변 길이 구하기</h3>

<p>여러번의 BFS 순회를 하는 것이 아니라, 한 번의 BFS만을 통해 모든 위치의 값을 구하면 된다는 것을 알게 되었고, 이를 적용하고자 했습니다. 이 때, 문제의 사항 중 고려하지 못했던 부분이 하나 더 있었는데, <strong>‘1’로 된 곳 중, 방문을 아예 하지 못한 곳은 ‘-1’로 처리한다</strong>는 것입니다. 처음에는 이 사항에 대한 고려가 없어 계속 틀렸다는 결과가 나왔는데, 문제를 다시 파악해보니 이와 같은 조건이 같이 있었다는 것을 알았습니다. 문제를 꼼꼼하게 읽는 것이 풀이보다 더 중요하다는 걸 느끼는 순간이었습니다…</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">toString</span><span class="p">().</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">M</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">destination</span> <span class="o">=</span> <span class="p">[];</span>

<span class="c1">// '2'의 위치를 처음에 파악해 저장해둠</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="nx">destination</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">floor</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// floor 값은 BFS로 탐색을 들어간 횟수를 나타냄</span>

<span class="kd">const</span> <span class="nx">BFS</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">destY</span><span class="p">,</span> <span class="nx">destX</span><span class="p">]</span> <span class="o">=</span> <span class="nx">destination</span><span class="p">;</span>
  <span class="c1">// '2'의 위치</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문한 곳을 나타내는 객체</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">destY</span><span class="p">,</span> <span class="nx">destX</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
  <span class="c1">// 최초값으로 '2'의 위치를 넣어줌. 2는 어느 곳에 대한 이동도 없으므로 floor값은 0</span>
  <span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 방문한 곳의 좌표, 탐색 횟수</span>
    <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 값이 0인 경우 0으로 설정</span>
      <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 값이 1, 2인 경우 해당 위치를 방문했음을 표기하고 주변 위치를 탐색</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">floor</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">M</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">BFS</span><span class="p">();</span>

<span class="c1">// 0인 경우, -1인 경우를 표기함</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="nx">line</span><span class="p">[</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">line</span><span class="p">[</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>이번 문제를 풀면서 난이도가 쉬운 문제도 문제에 대한 해결 방향을 잘못 잡거나, 문제를 잘못 읽은 경우 문제 풀이에 큰 문제가 생길 수 있음을 다시 느낄 수 있었습니다! 문제 해결에 앞서서 문제 이해 및 풀이를 위한 설계를 조금 더 신경쓰기로 했습니다.</p>

<p><strong>🔎 현재 코드의 경우, 상당히 긴 시간과 메모리를 소모하며 문제를 해결하게 됩니다. 추후 다시 문제를 풀면서 해당 부분에 대한 해결도 필요합니다.</strong></p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 그래프 순회를 하여 기준점으로부터의 거리값을 구하는 문제였습니다. 이 문제의 경우, BFS를 통해 한 점으로 부터 사방으로 이동할 때마다 이동거리를 한 칸 넓히는 방식을 통해 각 칸에서의 길이를 구하면 되었습니다. 잘못된 풀이 : 각 점으로 부터 ‘2’까지의 거리 구하기 하지만, 초반에 잘못된 방법으로 풀고자 하여, 기준점을 “2”에 두는 것이 아닌, 모든 각각의 점에 대해 기준점을 두고 2까지 가는 데에 필요한 길이를 구하는 방식으로 진행을 하여, 아래와 같은 코드가 나왔고, 이로 인해 ‘시간 초과’가 계속해서 나오는 문제가 있었습니다. const [numbers, ...graph] = input; const [n, m] = numbers.split(" "); const N = Number(n); const M = Number(m); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const resultArray = [...Array(N)].map(() =&gt; [...Array(M)]); // 결과를 담을 배열 const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, floor) =&gt; `${getMarker(y, x)},${floor}`; const checkBox = (lineIndex, boxIndex, box) =&gt; { if (box === "0") { // 0일 때 그 위치의 값은 0으로 설정 resultArray[lineIndex][boxIndex] = "0"; return; } if (box === "2") { // 2일 때 그 위치의 값은 0으로 설정 resultArray[lineIndex][boxIndex] = "0"; return; } const visited = {}; // 방문여부를 확인하는 객체 const queue = [getQueueItem(lineIndex, boxIndex, 0)]; // 최초 값은 함수를 통해 들어온 위치 let curItem; while (queue.length) { curItem = queue.shift(); const [y, x, floor] = curItem.split(",").map((value) =&gt; Number(value)); // 해당 박스의 좌표와 몇 번을 거쳐 왔는지 나타내는 floor 값 const curMarker = getMarker(y, x); const curValue = graphBoxes[y][x]; if (!visited[curMarker] &amp;&amp; curValue === "2") { // 2인 경우 추가적인 queue를 넣지 않고 거쳐온 정도를 넣어준 뒤 종료 visited[curMarker] = true; resultArray[lineIndex][boxIndex] = floor; } if (!visited[curMarker] &amp;&amp; curValue === "1") { // 1인 경우 주변 요소도 확인하도록 queue에 push visited[curMarker] = true; if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, floor + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, floor + 1)); if (y + 1 &lt; N) queue.push(getQueueItem(y + 1, x, floor + 1)); if (x + 1 &lt; M) queue.push(getQueueItem(y, x + 1, floor + 1)); } } }; // 문제가 되었던 곳. 모든 값을 돌아 길이를 구하려 해서 시간이 늘어남 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { checkBox(lineIndex, boxIndex, box); }); }); const result = resultArray.map((line) =&gt; line.join(" ")).join("\n"); console.log(result); 위 코드로 작성해, 모든 값에 대한 길이를 구하다보니 시간이 늘어나게 되어 이를 해결하기 위한 다른 방법을 찾게 되었습니다. ‘2’를 시작점으로 설정하고 주변 길이 구하기 여러번의 BFS 순회를 하는 것이 아니라, 한 번의 BFS만을 통해 모든 위치의 값을 구하면 된다는 것을 알게 되었고, 이를 적용하고자 했습니다. 이 때, 문제의 사항 중 고려하지 못했던 부분이 하나 더 있었는데, ‘1’로 된 곳 중, 방문을 아예 하지 못한 곳은 ‘-1’로 처리한다는 것입니다. 처음에는 이 사항에 대한 고려가 없어 계속 틀렸다는 결과가 나왔는데, 문제를 다시 파악해보니 이와 같은 조건이 같이 있었다는 것을 알았습니다. 문제를 꼼꼼하게 읽는 것이 풀이보다 더 중요하다는 걸 느끼는 순간이었습니다… const input = fs.readFileSync(filePath).toString().trim().split("\n"); const [numbers, ...graph] = input; const [n, m] = numbers.split(" "); const N = Number(n); const M = Number(m); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const destination = []; // '2'의 위치를 처음에 파악해 저장해둠 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "2") destination.push(lineIndex, boxIndex); }); }); const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, floor) =&gt; `${getMarker(y, x)},${floor}`; // floor 값은 BFS로 탐색을 들어간 횟수를 나타냄 const BFS = () =&gt; { const [destY, destX] = destination; // '2'의 위치 const visited = {}; // 방문한 곳을 나타내는 객체 const queue = [getQueueItem(destY, destX, 0)]; // 최초값으로 '2'의 위치를 넣어줌. 2는 어느 곳에 대한 이동도 없으므로 floor값은 0 let curItem; while (queue.length) { curItem = queue.shift(); const [y, x, floor] = curItem.split(",").map((value) =&gt; Number(value)); // 방문한 곳의 좌표, 탐색 횟수 const curMarker = getMarker(y, x); const curValue = graphBoxes[y][x]; if (curValue === "0") { // 값이 0인 경우 0으로 설정 graphBoxes[y][x] = 0; } if (!visited[curMarker] &amp;&amp; (curValue === "1" || curValue === "2")) { // 값이 1, 2인 경우 해당 위치를 방문했음을 표기하고 주변 위치를 탐색 visited[curMarker] = true; graphBoxes[y][x] = floor; if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, floor + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, floor + 1)); if (y + 1 &lt; N) queue.push(getQueueItem(y + 1, x, floor + 1)); if (x + 1 &lt; M) queue.push(getQueueItem(y, x + 1, floor + 1)); } } }; BFS(); // 0인 경우, -1인 경우를 표기함 graphBoxes.forEach((line) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "0") line[boxIndex] = 0; if (box === "1") line[boxIndex] = -1; }); }); const result = graphBoxes.map((line) =&gt; line.join(" ")).join("\n"); console.log(result); 이번 문제를 풀면서 난이도가 쉬운 문제도 문제에 대한 해결 방향을 잘못 잡거나, 문제를 잘못 읽은 경우 문제 풀이에 큰 문제가 생길 수 있음을 다시 느낄 수 있었습니다! 문제 해결에 앞서서 문제 이해 및 풀이를 위한 설계를 조금 더 신경쓰기로 했습니다. 🔎 현재 코드의 경우, 상당히 긴 시간과 메모리를 소모하며 문제를 해결하게 됩니다. 추후 다시 문제를 풀면서 해당 부분에 대한 해결도 필요합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 2667번</title><link href="http://localhost:4000/algorithm/2022/11/09/2667/" rel="alternate" type="text/html" title="백준 2667번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/2667</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/2667/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/2667">QUESTION LINK</a></strong></p>

<p>그래프 순회를 이용해 해결해야하는 문제였습니다. 문제를 해결하기 위해 일종의 흐름을 짜는 과정이 필요했는데 그 과정은 아래와 같았습니다.</p>

<ol>
  <li>그래프의 각 부분들(여기서는 <code class="language-plaintext highlighter-rouge">box</code>라는 이름으로 설정)을 순회하면서 그 값이 0인지 1인지를 확인</li>
  <li><code class="language-plaintext highlighter-rouge">box</code>의 값이 1인 경우, 해당 <code class="language-plaintext highlighter-rouge">box</code>의 방문 여부를 <code class="language-plaintext highlighter-rouge">true</code>로 설정함</li>
  <li>상하좌우의 <code class="language-plaintext highlighter-rouge">box</code>들을 따라 들어가, 2번과 같은 과정을 반복함</li>
</ol>

<p>위 순서를 따르기 위해 가장 먼저 필요한 것은 해당 그래프를 순회하는 과정을 만드는 것이었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">N</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">countArray</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 각 단지의 개수를 담아두기 위한 배열</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문여부를 확인하기 위한 객체</span>

<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 그래프의 각 라인마다 박스들을 확인함</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">checkBox</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">);</span>
    <span class="c1">// 각 박스마다 그 박스의 값과 방문여부를 확인하는 함수 생성 필요!</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="c1">// graphBoxes의 형태</span>
<span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
</code></pre></div></div>

<p>위 코드에서 보시다시피, 순회를 돌면서 각 위치(<code class="language-plaintext highlighter-rouge">lineIndex</code>, <code class="language-plaintext highlighter-rouge">boxIndex</code>)와 값(<code class="language-plaintext highlighter-rouge">box</code>)에 따라 처리를 해 줄 함수 <code class="language-plaintext highlighter-rouge">checkBox</code>가 필요했습니다. 이 함수는 각 박스의 순회 여부를 결정하고, 순회를 해야하는 경우 상하좌우를 DFS를 통해 순회하도록 설정해야 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// visited 객체의 key값을 만들기 위해 필요한 함수</span>

<span class="kd">const</span> <span class="nx">checkBox</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// y(lineIndex), x(boxIndex), box 값을 받아옴</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// box가 0인 경우 아파트가 없으므로 작업을 종료</span>
  <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
  <span class="c1">// key값으로 사용될 marker 생성</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 이미 방문했을 경우 작업을 종료</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">marker</span><span class="p">];</span>
  <span class="c1">// 첫 값으로 만들어진 marker를 담은 queue 생성</span>
  <span class="kd">let</span> <span class="nx">curMarker</span><span class="p">;</span>
  <span class="c1">// 반복문을 돌면서 목표 지점이 될 marker</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 해당 함수의 시작지점으로부터 얼마나 아파트를 돌았는지 확인하기 위한 변수</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="c1">// 목표지점으로 사용될 marker를 설정</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curMarker</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 몇 번째 줄, 몇 번째 box인지를 알아냄</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 방문하지 않은 값이 "1"인 box들일 경우에만 작업을 진행함</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 방문을 하는 상황으로 설정</span>
      <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">// 상하좌우를 돌면서 queue에 넣어줌</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="nx">countArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위 함수를 통해서 반복 작업 시 <code class="language-plaintext highlighter-rouge">box</code>가 <strong>방문하지 않은 ‘1’인 경우에만</strong> 그래프 순회를 통해 개수 세기를 진행하도록 할 수 있었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 그래프 순회를 이용해 해결해야하는 문제였습니다. 문제를 해결하기 위해 일종의 흐름을 짜는 과정이 필요했는데 그 과정은 아래와 같았습니다. 그래프의 각 부분들(여기서는 box라는 이름으로 설정)을 순회하면서 그 값이 0인지 1인지를 확인 box의 값이 1인 경우, 해당 box의 방문 여부를 true로 설정함 상하좌우의 box들을 따라 들어가, 2번과 같은 과정을 반복함 위 순서를 따르기 위해 가장 먼저 필요한 것은 해당 그래프를 순회하는 과정을 만드는 것이었습니다. const [N, ...graph] = input; const graphBoxes = graph.map((line) =&gt; line.split("")); const countArray = []; // 각 단지의 개수를 담아두기 위한 배열 const visited = {}; // 방문여부를 확인하기 위한 객체 graphBoxes.forEach((line, lineIndex) =&gt; { // 그래프의 각 라인마다 박스들을 확인함 line.forEach((box, boxIndex) =&gt; { checkBox(lineIndex, boxIndex, box); // 각 박스마다 그 박스의 값과 방문여부를 확인하는 함수 생성 필요! }); }); // graphBoxes의 형태 [ ["0", "1", "1", "0", "1", "0", "0"], ["0", "1", "1", "0", "1", "0", "1"], ["1", "1", "1", "0", "1", "0", "1"], ["0", "0", "0", "0", "1", "1", "1"], ["0", "1", "0", "0", "0", "0", "0"], ["0", "1", "1", "1", "1", "1", "0"], ["0", "1", "1", "1", "0", "0", "0"], ]; 위 코드에서 보시다시피, 순회를 돌면서 각 위치(lineIndex, boxIndex)와 값(box)에 따라 처리를 해 줄 함수 checkBox가 필요했습니다. 이 함수는 각 박스의 순회 여부를 결정하고, 순회를 해야하는 경우 상하좌우를 DFS를 통해 순회하도록 설정해야 했습니다. const getMarker = (y, x) =&gt; `${y},${x}`; // visited 객체의 key값을 만들기 위해 필요한 함수 const checkBox = (lineIndex, boxIndex, box) =&gt; { // y(lineIndex), x(boxIndex), box 값을 받아옴 if (box === "0") return; // box가 0인 경우 아파트가 없으므로 작업을 종료 const marker = getMarker(lineIndex, boxIndex); // key값으로 사용될 marker 생성 if (visited[marker]) return; // 이미 방문했을 경우 작업을 종료 const queue = [marker]; // 첫 값으로 만들어진 marker를 담은 queue 생성 let curMarker; // 반복문을 돌면서 목표 지점이 될 marker let count = 0; // 해당 함수의 시작지점으로부터 얼마나 아파트를 돌았는지 확인하기 위한 변수 while (queue.length) { curMarker = queue.pop(); // 목표지점으로 사용될 marker를 설정 const [y, x] = curMarker.split(",").map((value) =&gt; Number(value)); // 몇 번째 줄, 몇 번째 box인지를 알아냄 if (!visited[curMarker] &amp;&amp; graphBoxes[y][x] === "1") { // 방문하지 않은 값이 "1"인 box들일 경우에만 작업을 진행함 visited[curMarker] = true; // 방문을 하는 상황으로 설정 count += 1; // 상하좌우를 돌면서 queue에 넣어줌 if (y - 1 &gt;= 0) queue.push(getMarker(y - 1, x)); if (x - 1 &gt;= 0) queue.push(getMarker(y, x - 1)); if (y + 1 &lt; N) queue.push(getMarker(y + 1, x)); if (x + 1 &lt; N) queue.push(getMarker(y, x + 1)); } } if (count) countArray.push(count); }; 위 함수를 통해서 반복 작업 시 box가 방문하지 않은 ‘1’인 경우에만 그래프 순회를 통해 개수 세기를 진행하도록 할 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 16918번</title><link href="http://localhost:4000/algorithm/2022/11/08/16918/" rel="alternate" type="text/html" title="백준 16918번" /><published>2022-11-08T00:00:00+09:00</published><updated>2022-11-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/08/16918</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/08/16918/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/16918">QEUSTION LINK</a></strong></p>

<h3 id="1-첫-풀이-방식--규칙-사용하기-실패">1. 첫 풀이 방식 : 규칙 사용하기 (실패)</h3>

<p>문제에서 일종의 규칙을 찾은 뒤, 이후 문제가 되는 부분에 대해서만 처리를 해주고자 했습니다. 가장 처음에 한 것은 상황을 구분 짓는 것이었는데, 해당 문제의 경우 총 세 가지 경우의 수가 반복되고 있었습니다.</p>

<ol>
  <li>처음에 주어진 폭탄의 상황</li>
  <li>모든 위치에 폭탄이 들어간 상황</li>
  <li>처음 위치와 반대로 폭탄이 설치된 상황</li>
</ol>

<p>이 상황들 중 3번에 대한 처리만 하면 될 것이라는 생각으로, 처음에 주어진 폭탄의 상황을 먼저 만드는 것으로 시작했습니다. 이를 위해 주어진 값들에 대해서 그래프 형식으로 바꾸는 작업부터 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">R</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">time</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// R x C 의 그래프에서 time을 가져옴</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>
<span class="c1">// 그래프 각각의 값을 나누어줌</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문한 곳을 처리하기 위한 객체</span>
</code></pre></div></div>

<p>위 코드를 통해 아래와 같은 형식의 그래프를 가져올 수 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
</code></pre></div></div>

<p>그 후, 각 초마다의 상황을 처리해야했는데, 이는 아래와 같은 규칙성을 가지고 있었습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0초 : 처음 주어진 상황
1초 : 처음 주어진 상황
2초 : 모든 위치에 폭탄
3초 : 처음과 뒤바뀐 상황
4초 : 모든 위치에 폭탄
5초 : 처음 주어진 상황
6초 : 모든 위치에 폭탄
...
</code></pre></div></div>

<p>즉, 시간이 주어진 상황에서, 4로 나눌 때, 아래와 같은 결과가 됩니다..</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>나머지 1 = 첫 상황
나머지 2, 나머지 4 = 모든 위치에 폭탄
나머지 3 = 첫 상황과 반대
</code></pre></div></div>

<p>이렇게 상황을 설정한 뒤에는 ‘첫 상황과 반대’인 경우에 대해 처리를 해주어야 했습니다. 이 부분에 대한 처리는 그래프를 순회하며 폭탄(”0”)을 만날 때마다 그 주위의 값들을 터짐(”.”)으로 바꿔주도록 설정했습니다. 그리고 만약, 그 주위에 다른 폭탄이 있는 경우에는 이후에 그 폭탄이 터지는 것으로 처리했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">remain</span> <span class="o">=</span> <span class="nx">time</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 처음과 같은 상태 유지</span>
    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">remain</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 모두 폭탄이 위치한 것으로 설정</span>
    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="nx">C</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 처음 폭탄과 반대 상황 설정</span>
    <span class="nx">graph</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="c1">// 처음 위치에 폭탄이 터지고, 이후 주변 폭탄도 터지도록 설정</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">C</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 폭탄이 아닌 곳을 지날 시, 폭탄으로 바뀌도록 설정</span>
          <span class="kd">const</span> <span class="nx">mark</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">lineIndex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">boxIndex</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">});</span>

    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그리고, 폭탄에 도착할 시, 폭탄이 터지는 상황에 대한 함수는 따로 구분해서 생성해주었습니다. 이 때, 폭탄이 터지는 상황은 현재 위치가 폭탄일 때, 주변 위치가 폭탄이 아닐 때로 설정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">checkMark</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">isSelf</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">mark</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">lineIndex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">boxIndex</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="c1">// 폭탄이 터질 위치</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isSelf</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 폭탄 자체의 위치가 아닌 상황에서 방문한 적 없는 주변 폭탄인 경우에는 넘어감</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이를 통해 예제의 상황에 대해서는 제대로 결과가 호출되는 것을 볼 수 있었습니다. 하지만, 백준을 통해 채점을 했을 때 틀렸다는 결과가 나와서 문제점을 파악하는 데에 시간을 꽤 소요됐습니다.</p>

<h3 id="2-두-번째-방식--직접-반복하기-성공">2. 두 번째 방식 : 직접 반복하기 (성공)</h3>

<p>이전에 규칙을 찾아 적용하는 방식을 할 경우, 규칙이 무조건 반복되지 않을 수도 있다는 문제가 있다는 것을 발견했습니다. 그래서, 이를 해결하기 위해서는 직접 폭탄이 터지는 상황을 반복하는 것이 안전하다고 판단해, 직접 진행하는 것으로 방법을 변경했습니다.</p>

<p>문제를 풀기 위해 진행한 순서는 아래와 같습니다.</p>

<ol>
  <li>1초만 진행된 상황에 대해 처리하기</li>
  <li>짝수초 만큼 진행된 상황에 대해 처리하기</li>
  <li>1,2번 이외의 상황 처리하기</li>
</ol>

<p>가장 먼저 진행한 것은 첫 번째 방식과 동일하게 그래프를 만들어주는 것이었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">R</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">N</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">N</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>

<span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
<span class="c1">// 생성된 그래프 배열</span>
</code></pre></div></div>

<p>그리고 폭탄이 터지는 상황에서 사용하기 위한 폭탄으로만 가득찬 배열을 만드는 함수를 생성했습니다. 이 함수의 경우, 앞서 말한 바와 같이 짝수초 만큼 지나간 상황에서는 폭탄으로만 가득한 배열이 나오기 때문에 그 상황에서도 활용이 가능합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getNewGraph</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">R</span><span class="p">))].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">C</span><span class="p">))].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div></div>

<p>그리고 1, 2번의 상황을 처리하기 위한 함수를 먼저 생성했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 1초만 지나간 경우 원래의 그래프를 보여줌</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">time</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 짝수초만큼 지나간 경우 폭탄으로 가득한 그래프를 보여줌</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">time</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">getNewGraph</span><span class="p">()</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">))</span>
      <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221108/1.png" alt="" width="100%" height="" /> 
</figure>

<p>이후 폭탄이 터진 뒤의 상황을 보여주는 그래프를 생성해야 했습니다. 이를 해결하기 위해 생각한 것은 우선 폭탄으로 가득찬 그래프를 먼저 만든 뒤, 이전 그래프에서 폭탄이 위치한 곳과 상하좌우를 폭탄이 터지도록 하여 다음에 터져야할 폭탄들이 보이는 그래프가 나오도록 설정을 해주었습니다.</p>

<p>그리고 2초가 더 지나간 상황에서는 새롭게 만들어진 그래프에서 폭탄이 터지는 상황을 만들도록 하여 앞서 진행한 것과 같은 방식으로 진행하도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="kd">let</span> <span class="nx">curTime</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// 시간이 이미 2초 지나간 뒤의 상황부터 시작하기 때문에 2를 뺌</span>
  <span class="kd">let</span> <span class="nx">curGraph</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">;</span>
  <span class="c1">// 폭탄의 위치를 나타내는 그래프</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">curTime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 2초씩 지나간 뒤, 0초 이하일 경우 멈춤</span>
    <span class="nx">curTime</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// 2초가 지나간 뒤의 상황을 보여줄 것이므로 뺌</span>
    <span class="kd">const</span> <span class="nx">newGraph</span> <span class="o">=</span> <span class="nx">getNewGraph</span><span class="p">();</span>
    <span class="c1">// 새롭게 만들어질 폭탄으로 가득찬 그래프</span>
    <span class="nx">curGraph</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 폭탄 위치를 나타내는 그래프에서 좌표를 빼내어 폭탄과 그 상하좌우가 터지도록 설정</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">C</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">});</span>
    <span class="nx">curGraph</span> <span class="o">=</span> <span class="nx">newGraph</span><span class="p">;</span>
    <span class="c1">// 새롭게 만들어진 폭탄 위치 그래프로 설정</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">curGraph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221108/2.png" alt="" width="100%" height="" /> 
</figure>

<p>이런 식으로 폭탄이 터지는 위치에 대한 값을 지속적으로 확인해 처리해주는 방식으로 문제를 해결할 수 있었습니다.</p>

<hr />

<p>🔎 현재 사용한 방식은 그래프 순회를 하는 방식을 적극적으로 사용하지는 않은 것이라 다른 방법에 대한 고민이 더 필요하기는 합니다!</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QEUSTION LINK 1. 첫 풀이 방식 : 규칙 사용하기 (실패) 문제에서 일종의 규칙을 찾은 뒤, 이후 문제가 되는 부분에 대해서만 처리를 해주고자 했습니다. 가장 처음에 한 것은 상황을 구분 짓는 것이었는데, 해당 문제의 경우 총 세 가지 경우의 수가 반복되고 있었습니다. 처음에 주어진 폭탄의 상황 모든 위치에 폭탄이 들어간 상황 처음 위치와 반대로 폭탄이 설치된 상황 이 상황들 중 3번에 대한 처리만 하면 될 것이라는 생각으로, 처음에 주어진 폭탄의 상황을 먼저 만드는 것으로 시작했습니다. 이를 위해 주어진 값들에 대해서 그래프 형식으로 바꾸는 작업부터 해주었습니다. const [R, C, time] = input[0].split(" "); // R x C 의 그래프에서 time을 가져옴 const graph = input.splice(1).map((line) =&gt; line.split("")); // 그래프 각각의 값을 나누어줌 const visited = {}; // 방문한 곳을 처리하기 위한 객체 위 코드를 통해 아래와 같은 형식의 그래프를 가져올 수 있었습니다. const graph = [ [".", ".", ".", ".", ".", ".", "."], [".", ".", ".", "O", ".", ".", "."], [".", ".", ".", ".", "O", ".", "."], [".", ".", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ]; 그 후, 각 초마다의 상황을 처리해야했는데, 이는 아래와 같은 규칙성을 가지고 있었습니다. 0초 : 처음 주어진 상황 1초 : 처음 주어진 상황 2초 : 모든 위치에 폭탄 3초 : 처음과 뒤바뀐 상황 4초 : 모든 위치에 폭탄 5초 : 처음 주어진 상황 6초 : 모든 위치에 폭탄 ... 즉, 시간이 주어진 상황에서, 4로 나눌 때, 아래와 같은 결과가 됩니다.. 나머지 1 = 첫 상황 나머지 2, 나머지 4 = 모든 위치에 폭탄 나머지 3 = 첫 상황과 반대 이렇게 상황을 설정한 뒤에는 ‘첫 상황과 반대’인 경우에 대해 처리를 해주어야 했습니다. 이 부분에 대한 처리는 그래프를 순회하며 폭탄(”0”)을 만날 때마다 그 주위의 값들을 터짐(”.”)으로 바꿔주도록 설정했습니다. 그리고 만약, 그 주위에 다른 폭탄이 있는 경우에는 이후에 그 폭탄이 터지는 것으로 처리했습니다. const getResult = () =&gt; { const remain = time % 4; if (remain === 1) { // 처음과 같은 상태 유지 return graph.map((line) =&gt; line.join("")).join("\n"); } if (remain === 0 || remain === 2) { // 모두 폭탄이 위치한 것으로 설정 return graph.map(() =&gt; "O".repeat(C)).join("\n"); } if (remain === 3) { // 처음 폭탄과 반대 상황 설정 graph.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "O") { checkMark(lineIndex, boxIndex, true); // 처음 위치에 폭탄이 터지고, 이후 주변 폭탄도 터지도록 설정 if (lineIndex - 1 &gt;= 0) checkMark(lineIndex - 1, boxIndex); if (boxIndex - 1 &gt;= 0) checkMark(lineIndex, boxIndex - 1); if (boxIndex + 1 &lt;= C - 1) checkMark(lineIndex, boxIndex + 1); if (lineIndex + 1 &lt;= R - 1) checkMark(lineIndex + 1, boxIndex); } if (box === ".") { // 폭탄이 아닌 곳을 지날 시, 폭탄으로 바뀌도록 설정 const mark = `${lineIndex},${boxIndex}`; if (!visited[mark]) { visited[mark] = true; graph[lineIndex][boxIndex] = "O"; } } }); }); return graph.map((line) =&gt; line.join("")).join("\n"); } }; 그리고, 폭탄에 도착할 시, 폭탄이 터지는 상황에 대한 함수는 따로 구분해서 생성해주었습니다. 이 때, 폭탄이 터지는 상황은 현재 위치가 폭탄일 때, 주변 위치가 폭탄이 아닐 때로 설정했습니다. const checkMark = (lineIndex, boxIndex, isSelf = false) =&gt; { const mark = `${lineIndex},${boxIndex}`; // 폭탄이 터질 위치 if (graph[lineIndex][boxIndex] === "O" &amp;&amp; !visited[mark] &amp;&amp; !isSelf) return; // 폭탄 자체의 위치가 아닌 상황에서 방문한 적 없는 주변 폭탄인 경우에는 넘어감 visited[mark] = true; graph[lineIndex][boxIndex] = "."; }; 이를 통해 예제의 상황에 대해서는 제대로 결과가 호출되는 것을 볼 수 있었습니다. 하지만, 백준을 통해 채점을 했을 때 틀렸다는 결과가 나와서 문제점을 파악하는 데에 시간을 꽤 소요됐습니다. 2. 두 번째 방식 : 직접 반복하기 (성공) 이전에 규칙을 찾아 적용하는 방식을 할 경우, 규칙이 무조건 반복되지 않을 수도 있다는 문제가 있다는 것을 발견했습니다. 그래서, 이를 해결하기 위해서는 직접 폭탄이 터지는 상황을 반복하는 것이 안전하다고 판단해, 직접 진행하는 것으로 방법을 변경했습니다. 문제를 풀기 위해 진행한 순서는 아래와 같습니다. 1초만 진행된 상황에 대해 처리하기 짝수초 만큼 진행된 상황에 대해 처리하기 1,2번 이외의 상황 처리하기 가장 먼저 진행한 것은 첫 번째 방식과 동일하게 그래프를 만들어주는 것이었습니다. const [R, C, N] = input[0].split(" "); const time = Number(N); const graph = input.slice(1).map((line) =&gt; line.split("")); [ [".", ".", ".", ".", ".", ".", "."], [".", ".", ".", "O", ".", ".", "."], [".", ".", ".", ".", "O", ".", "."], [".", ".", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ]; // 생성된 그래프 배열 그리고 폭탄이 터지는 상황에서 사용하기 위한 폭탄으로만 가득찬 배열을 만드는 함수를 생성했습니다. 이 함수의 경우, 앞서 말한 바와 같이 짝수초 만큼 지나간 상황에서는 폭탄으로만 가득한 배열이 나오기 때문에 그 상황에서도 활용이 가능합니다. const getNewGraph = () =&gt; [...Array(Number(R))].map(() =&gt; [...Array(Number(C))].map(() =&gt; "O")); 그리고 1, 2번의 상황을 처리하기 위한 함수를 먼저 생성했습니다. const getResult = () =&gt; { // 1초만 지나간 경우 원래의 그래프를 보여줌 if (time === 1) { return input.slice(1).join("\n"); } // 짝수초만큼 지나간 경우 폭탄으로 가득한 그래프를 보여줌 if (!(time % 2)) { return getNewGraph() .map((line) =&gt; line.join("")) .join("\n"); } ... }; 이후 폭탄이 터진 뒤의 상황을 보여주는 그래프를 생성해야 했습니다. 이를 해결하기 위해 생각한 것은 우선 폭탄으로 가득찬 그래프를 먼저 만든 뒤, 이전 그래프에서 폭탄이 위치한 곳과 상하좌우를 폭탄이 터지도록 하여 다음에 터져야할 폭탄들이 보이는 그래프가 나오도록 설정을 해주었습니다. 그리고 2초가 더 지나간 상황에서는 새롭게 만들어진 그래프에서 폭탄이 터지는 상황을 만들도록 하여 앞서 진행한 것과 같은 방식으로 진행하도록 했습니다. const getResult = () =&gt; { ... let curTime = Number(time) - 2; // 시간이 이미 2초 지나간 뒤의 상황부터 시작하기 때문에 2를 뺌 let curGraph = graph; // 폭탄의 위치를 나타내는 그래프 while (curTime &gt; 0) { // 2초씩 지나간 뒤, 0초 이하일 경우 멈춤 curTime -= 2; // 2초가 지나간 뒤의 상황을 보여줄 것이므로 뺌 const newGraph = getNewGraph(); // 새롭게 만들어질 폭탄으로 가득찬 그래프 curGraph.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { // 폭탄 위치를 나타내는 그래프에서 좌표를 빼내어 폭탄과 그 상하좌우가 터지도록 설정 if (box !== "O") return; newGraph[lineIndex][boxIndex] = "."; if (lineIndex - 1 &gt;= 0) newGraph[lineIndex - 1][boxIndex] = "."; if (boxIndex - 1 &gt;= 0) newGraph[lineIndex][boxIndex - 1] = "."; if (boxIndex + 1 &lt;= C - 1) newGraph[lineIndex][boxIndex + 1] = "."; if (lineIndex + 1 &lt;= R - 1) newGraph[lineIndex + 1][boxIndex] = "."; }); }); curGraph = newGraph; // 새롭게 만들어진 폭탄 위치 그래프로 설정 } return curGraph.map((line) =&gt; line.join("")).join("\n"); }; 이런 식으로 폭탄이 터지는 위치에 대한 값을 지속적으로 확인해 처리해주는 방식으로 문제를 해결할 수 있었습니다. 🔎 현재 사용한 방식은 그래프 순회를 하는 방식을 적극적으로 사용하지는 않은 것이라 다른 방법에 대한 고민이 더 필요하기는 합니다!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 1325번 (시간 초과)</title><link href="http://localhost:4000/algorithm/2022/11/08/1325/" rel="alternate" type="text/html" title="백준 1325번 (시간 초과)" /><published>2022-11-08T00:00:00+09:00</published><updated>2022-11-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/08/1325</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/08/1325/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/1325">QUESTION LINK</a></strong></p>

<p>그래프 순회를 이용해 해결하는 문제입니다. 문제를 해결하기 위해 일단 주어진 값들에 대해서 그래프로 만들어주는 작업이 먼저 필요했습니다.<br />
그래프를 그리기에 앞서 문제에 대한 파악이 먼저 필요했는데, 여기서 예를 들어 A가 B를 신뢰하는 경우는 그래프 상으로는 ‘B → A’와 같은 형태가 나온다고 볼 수 있습니다. 이를 이용해 그래프를 만들면 아래와 같은 형태의 그래프가 나오게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">3</span><span class="dl">"</span><span class="p">],</span>
  <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">3</span><span class="dl">"</span><span class="p">],</span>
  <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">4</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">],</span>
  <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">],</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이후 DFS를 통해서 해당 그래프를 순회하며 연결된 노드들이 지나갈 때마다 횟수를 1회 더해주어 총 지나간 횟수를 구하는 함수를 만들었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">start</span><span class="p">];</span>
  <span class="c1">// 방문할 노드를 담아두는 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문한 노드를 적어두는 곳</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 총 방문한 노드 수</span>
  <span class="kd">let</span> <span class="nx">node</span><span class="p">;</span>
  <span class="c1">// 현재 노드 설정</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="c1">// 시작점의 노드는 방문한 것으로 처리</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="c1">// 배열의 가장 마지막 요소를 빼내고, 이를 확인했다는 의미로 count의 숫자를 올림</span>
    <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">graph</span><span class="p">[</span><span class="nx">node</span><span class="p">])</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">// 해당 노드를 통해 접근가능한 값이 없는 경우에 대해 빈 배열로 처리함</span>

    <span class="nx">graph</span><span class="p">[</span><span class="nx">node</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextNode</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextNode</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// 인접 노드에 대해서도 방문하지 않았을 시 같은 방법으로 순회하도록 함</span>
        <span class="nx">visited</span><span class="p">[</span><span class="nx">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextNode</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이후 그래프의 key값들을 통해 그래프 순회를 시작합니다. 이 때 최대값과 결과 배열을 설정해두어, 최대값을 갖고 있는 값들의 배열을 구합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 결과 배열</span>
<span class="kd">let</span> <span class="nx">curMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 초기 최대값 설정</span>
<span class="kd">const</span> <span class="nx">graphKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">graph</span><span class="p">);</span>

<span class="nx">graphKeys</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">curCount</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curMax</span> <span class="o">&gt;</span> <span class="nx">curCount</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 최대값보다 작은 값이 나올 경우 취소</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curMax</span> <span class="o">===</span> <span class="nx">curCount</span><span class="p">)</span> <span class="nx">resultArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
  <span class="c1">// 최대값과 일치할 경우 기존 배열에 삽입</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curMax</span> <span class="o">&lt;</span> <span class="nx">curCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 최대값보다 클 경우 새롭게 최대값 설정 후 결과 배열을 변경</span>
    <span class="nx">curMax</span> <span class="o">=</span> <span class="nx">curCount</span><span class="p">;</span>
    <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[</span><span class="nx">index</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<blockquote>
  <p>하지만, 현재 이렇게 값을 구할 경우, 예제로 나온 부분에 대해서는 처리가 가능하나, 이후 백준을 통해서 채점을 진행할 경우 지속적으로 시간 초과가 나오는 상태입니다. 해당 부분을 처리하기 위한 작업을 추가적으로 진행해야 합니다.</p>
</blockquote>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 그래프 순회를 이용해 해결하는 문제입니다. 문제를 해결하기 위해 일단 주어진 값들에 대해서 그래프로 만들어주는 작업이 먼저 필요했습니다. 그래프를 그리기에 앞서 문제에 대한 파악이 먼저 필요했는데, 여기서 예를 들어 A가 B를 신뢰하는 경우는 그래프 상으로는 ‘B → A’와 같은 형태가 나온다고 볼 수 있습니다. 이를 이용해 그래프를 만들면 아래와 같은 형태의 그래프가 나오게 됩니다. const graph = { 1: ["3"], 2: ["3"], 3: ["4", "5"], 4: ["5"], }; 이후 DFS를 통해서 해당 그래프를 순회하며 연결된 노드들이 지나갈 때마다 횟수를 1회 더해주어 총 지나간 횟수를 구하는 함수를 만들었습니다. const dfs = (start) =&gt; { const queue = [start]; // 방문할 노드를 담아두는 배열 const visited = {}; // 방문한 노드를 적어두는 곳 let count = 0; // 총 방문한 노드 수 let node; // 현재 노드 설정 visited[start] = true; // 시작점의 노드는 방문한 것으로 처리 while (queue.length) { node = queue.pop(); // 배열의 가장 마지막 요소를 빼내고, 이를 확인했다는 의미로 count의 숫자를 올림 count += 1; if (!graph[node]) graph[node] = []; // 해당 노드를 통해 접근가능한 값이 없는 경우에 대해 빈 배열로 처리함 graph[node].forEach((nextNode) =&gt; { if (!visited[nextNode]) { // 인접 노드에 대해서도 방문하지 않았을 시 같은 방법으로 순회하도록 함 visited[nextNode] = true; queue.push(nextNode); } }); } return count; }; 이후 그래프의 key값들을 통해 그래프 순회를 시작합니다. 이 때 최대값과 결과 배열을 설정해두어, 최대값을 갖고 있는 값들의 배열을 구합니다. let resultArray = []; // 결과 배열 let curMax = 0; // 초기 최대값 설정 const graphKeys = Object.keys(graph); graphKeys.forEach((index) =&gt; { const curCount = dfs(index); if (curMax &gt; curCount) return; // 최대값보다 작은 값이 나올 경우 취소 if (curMax === curCount) resultArray.push(index); // 최대값과 일치할 경우 기존 배열에 삽입 if (curMax &lt; curCount) { // 최대값보다 클 경우 새롭게 최대값 설정 후 결과 배열을 변경 curMax = curCount; resultArray = [index]; } }); 하지만, 현재 이렇게 값을 구할 경우, 예제로 나온 부분에 대해서는 처리가 가능하나, 이후 백준을 통해서 채점을 진행할 경우 지속적으로 시간 초과가 나오는 상태입니다. 해당 부분을 처리하기 위한 작업을 추가적으로 진행해야 합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">BFS (너비 우선 그래프 순회)</title><link href="http://localhost:4000/algorithm/2022/11/07/BFS/" rel="alternate" type="text/html" title="BFS (너비 우선 그래프 순회)" /><published>2022-11-07T00:00:00+09:00</published><updated>2022-11-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/07/BFS</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/07/BFS/"><![CDATA[<p><strong>너비 우선</strong>은 주어진 노드의 인접점을 모두 방문하고 아래로 내려가거나 인접점의 인접점을 보는 형식을 의미합니다.</p>

<p>너비 우선에서 가장 중요한 점은 <strong>‘주어진 점에 대해 모든 인접점을 우선적으로 처리하는 것’</strong>입니다.</p>

<h3 id="bfs-만들기">BFS 만들기</h3>

<p>DFS와 BFS의 차이점은 다른 종류의 데이터 구조를 사용해, <strong>BFS는 큐(queue)를 쓴다는 것</strong>입니다. 이로 인해 먼저 들어갔던 것들이 먼저 나오게 됩니다. 코드로는 아래와 같습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">breadthFirst</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">start</span><span class="p">];</span>
  <span class="c1">// queue에 처음에 들어오는 값을 대입</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과로 사용될 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문했음을 알려주는 객체</span>
  <span class="kd">let</span> <span class="nx">curVertex</span><span class="p">;</span>
  <span class="c1">// 현재 노드의 정보</span>

  <span class="nx">visited</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="c1">// start 변수는 이미 방문된 것으로 처리되기에 visited에 넣어줌</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// while 문을 돌면서 설정된 queue에 아무 값이 없을 경우 순환을 끝냄</span>
    <span class="nx">curVertex</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="c1">// BFS에서 가장 중요한 부분으로, 들어간 값들의 가장 앞부분부터 빼냄</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curVertex</span><span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">[</span><span class="nx">curVertex</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextVertex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 이웃 값들에 대해 방문하지 않았을 시 방문하기 위해 queue에 넣어줌</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextVertex</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="na">A</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">B</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">C</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">D</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">E</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">F</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">]</span>
<span class="p">}</span>
<span class="c1">// graph</span>

<span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">]</span>
<span class="c1">// result</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221107/1.png" alt="" width="100%" height="" /> 
</figure>

<p>위 그림과 같은 순서로 진행되게 되며, DFS 중에서도 반복을 통한 순회와 같은 방식으로 코드가 진행된다는 것을 볼 수 있습니다. 차이점은 앞서 말한 바와 같이 <strong>데이터 구조 사용 시 stack이 아닌 queue를</strong> 써야 한다는 사실만 주의하면 BFS를 통한 순회를 하는 데에는 큰 문제가 없습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[너비 우선은 주어진 노드의 인접점을 모두 방문하고 아래로 내려가거나 인접점의 인접점을 보는 형식을 의미합니다. 너비 우선에서 가장 중요한 점은 ‘주어진 점에 대해 모든 인접점을 우선적으로 처리하는 것’입니다. BFS 만들기 DFS와 BFS의 차이점은 다른 종류의 데이터 구조를 사용해, BFS는 큐(queue)를 쓴다는 것입니다. 이로 인해 먼저 들어갔던 것들이 먼저 나오게 됩니다. 코드로는 아래와 같습니다. breadthFirst(start) { const queue = [start]; // queue에 처음에 들어오는 값을 대입 const result = []; // 결과로 사용될 배열 const visited = {}; // 방문했음을 알려주는 객체 let curVertex; // 현재 노드의 정보 visited[start] = true; // start 변수는 이미 방문된 것으로 처리되기에 visited에 넣어줌 while (queue.length) { // while 문을 돌면서 설정된 queue에 아무 값이 없을 경우 순환을 끝냄 curVertex = queue.shift(); // BFS에서 가장 중요한 부분으로, 들어간 값들의 가장 앞부분부터 빼냄 result.push(curVertex); this.graph[curVertex].forEach((nextVertex) =&gt; { // 이웃 값들에 대해 방문하지 않았을 시 방문하기 위해 queue에 넣어줌 if (!visited[nextVertex]) { visited[nextVertex] = true; queue.push(nextVertex); } }); } return result; } { A: [ 'B', 'C' ], B: [ 'A', 'D' ], C: [ 'A', 'E' ], D: [ 'B', 'E', 'F' ], E: [ 'C', 'D', 'F' ], F: [ 'D', 'E' ] } // graph [ 'A', 'B', 'C', 'D', 'E', 'F' ] // result 위 그림과 같은 순서로 진행되게 되며, DFS 중에서도 반복을 통한 순회와 같은 방식으로 코드가 진행된다는 것을 볼 수 있습니다. 차이점은 앞서 말한 바와 같이 데이터 구조 사용 시 stack이 아닌 queue를 써야 한다는 사실만 주의하면 BFS를 통한 순회를 하는 데에는 큰 문제가 없습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">textarea 높이 조절하기</title><link href="http://localhost:4000/react/2022/10/26/textarea-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="textarea 높이 조절하기" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/26/textarea%20%EB%86%92%EC%9D%B4%20%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/2022/10/26/textarea-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0/"><![CDATA[<h3 id="줄바꿈이-발생할-때-채팅-높이를-늘리기">줄바꿈이 발생할 때 채팅 높이를 늘리기</h3>

<p>textarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/4.png" alt="" width="" height="" /> 
</figure>

<p>줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">setAutoSize</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">{</span> <span class="na">scrollHeight</span><span class="p">:</span> <span class="nx">curHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">;</span>
  <span class="c1">// 현재의 scroll 높이를 구함</span>

  <span class="c1">// maximum height is 83px when textarea has 3 line</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curHeight</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 83보다 크고 110보다 작은 값으로 설정</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">curHeight</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
  <span class="c1">// 실제 textarea 높이를 스크롤 높이만큼 넓힘</span>
<span class="p">};</span>
</code></pre></div></div>

<p>하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/5.gif" alt="" width="50%" height="" /> 
</figure>

<h3 id="그림자-태그를-만들어-해결하기">그림자 태그를 만들어 해결하기</h3>

<p>이를 해결하기 위한 방법을 찾아보던 도중, <a href="https://stackoverflow.com/questions/57965268/possible-to-have-a-dynamically-height-adjusted-textarea-without-constant-reflows">링크</a>를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다.<br />
실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다.<br />
현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/6.png" alt="" width="" height="" /> 
</figure>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">ChatTextarea</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">textarea</span><span class="o">&lt;</span><span class="p">{</span> <span class="nx">isShadow</span><span class="p">?:</span> <span class="nx">boolean</span> <span class="p">}</span><span class="o">&gt;</span><span class="s2">`
  </span><span class="p">${({</span> <span class="na">theme</span><span class="p">:</span> <span class="p">{</span> <span class="nx">colors</span><span class="p">,</span> <span class="nx">fonts</span> <span class="p">},</span> <span class="nx">isShadow</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">css</span><span class="s2">`
    </span><span class="p">${</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">main</span><span class="p">}</span><span class="s2">
    </span><span class="p">${</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">largeRegular</span><span class="p">}</span><span class="s2">

		...

    </span><span class="p">${</span><span class="nx">isShadow</span> <span class="o">&amp;&amp;</span>
    <span class="c1">// 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정</span>
    <span class="nx">css</span><span class="s2">`
      height: 0px;
      opacity: 0;
    `</span><span class="p">}</span><span class="s2">
  `</span><span class="p">}</span><span class="s2">
`</span><span class="p">;</span>
</code></pre></div></div>

<p>우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, <code class="language-plaintext highlighter-rouge">width</code>는 그대로 두고, <code class="language-plaintext highlighter-rouge">height</code> 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">shadowTextareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="p">...</span>

<span class="cm">/** get height with shadow textarea */</span>
<span class="kd">const</span> <span class="nx">setAutoSize</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">||</span> <span class="o">!</span><span class="nx">shadowTextareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">{</span> <span class="na">scrollHeight</span><span class="p">:</span> <span class="nx">shadowHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">shadowTextareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
	<span class="c1">// 그림자의 scroll height를 이용해 높이를 구함</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="na">height</span><span class="p">:</span> <span class="nx">curHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">;</span>

  <span class="c1">// maximum height is 83px when textarea has 3 line</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curHeight</span> <span class="o">===</span> <span class="s2">`</span><span class="p">${</span><span class="nx">shadowHeight</span><span class="p">}</span><span class="s2">px`</span> <span class="o">||</span> <span class="nx">shadowHeight</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="c1">// 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">shadowHeight</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setAutoSize</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">chatValue</span><span class="p">]);</span>

<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextareaWrapper</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
    <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">textareaRef</span><span class="si">}</span>
    <span class="na">rows</span><span class="p">=</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span>
    <span class="na">spellCheck</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">chatValue</span><span class="si">}</span>
    <span class="na">onKeyDown</span><span class="p">=</span><span class="si">{</span><span class="nx">handleKeyDownChat</span><span class="si">}</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeChatValue</span><span class="si">}</span>
    <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
    <span class="na">placeholder</span><span class="p">=</span><span class="s">'메시지를 입력하세요.'</span>
  <span class="p">/&gt;</span>
	// 그림자 태그를 만들어 뒤에 숨어있도록 설정
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
    <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">shadowTextareaRef</span><span class="si">}</span>
    <span class="na">isShadow</span><span class="p">=</span><span class="si">{</span><span class="kc">true</span><span class="si">}</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">chatValue</span><span class="si">}</span>
    <span class="na">onKeyDown</span><span class="p">=</span><span class="si">{</span><span class="nx">handleKeyDownChat</span><span class="si">}</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeChatValue</span><span class="si">}</span>
    <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
    <span class="na">readOnly</span>
    <span class="na">tabIndex</span><span class="p">=</span><span class="si">{</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span>
  <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextareaWrapper</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/7.gif" alt="" width="50%" height="" /> 
</figure>

<p>하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다.</p>

<h3 id="채팅창의-높이가-올라갈-때-채팅-내용도-올려주기">채팅창의 높이가 올라갈 때 채팅 내용도 올려주기</h3>

<p>이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, <code class="language-plaintext highlighter-rouge">position: fixed</code>로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 <code class="language-plaintext highlighter-rouge">fixed</code>가 아닌 일반적인 <code class="language-plaintext highlighter-rouge">position</code> 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다.</p>

<p>이 부분에서 저는 <code class="language-plaintext highlighter-rouge">fixed</code>를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">position: fixed</code>로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 <code class="language-plaintext highlighter-rouge">onHeightChange</code>라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">blockHeight</span><span class="p">,</span> <span class="nx">setBlockHeight</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">scrollToBottom</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">lastBlockRef</span><span class="p">.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">scrollIntoView</span><span class="p">({</span> <span class="na">block</span><span class="p">:</span> <span class="dl">'</span><span class="s1">end</span><span class="dl">'</span> <span class="p">});</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">changeBlockHeight</span> <span class="o">=</span> <span class="p">(</span><span class="nx">height</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setBlockHeight</span><span class="p">(</span><span class="nx">height</span><span class="p">);</span>
  <span class="nx">scrollToBottom</span><span class="p">();</span>
	<span class="c1">// 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="p">&lt;&gt;</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">chatroomLogs</span><span class="si">}</span>
      <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">LastBottomBlock</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">scrollToBottomRef</span><span class="si">}</span> <span class="na">blockHeight</span><span class="p">=</span><span class="si">{</span><span class="nx">blockHeight</span><span class="si">}</span> <span class="p">/&gt;</span>
			// 채팅창 뒤 빈 영역을 채워주는 블록
    <span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">ChatroomBar</span> <span class="na">chatroomId</span><span class="p">=</span><span class="si">{</span><span class="nb">Number</span><span class="p">(</span><span class="nx">chatroomId</span><span class="p">)</span><span class="si">}</span> <span class="na">onHeightChange</span><span class="p">=</span><span class="si">{</span><span class="nx">changeBlockHeight</span><span class="si">}</span> <span class="p">/&gt;</span>
		// 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정
  <span class="p">&lt;/&gt;</span>
<span class="p">);</span>
</code></pre></div></div>

<p>위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/8.gif" alt="" width="50%" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[줄바꿈이 발생할 때 채팅 높이를 늘리기 textarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다. 줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다. const setAutoSize = () =&gt; { if (!textareaRef.current) return; const { scrollHeight: curHeight } = textareaRef.current.style; // 현재의 scroll 높이를 구함 // maximum height is 83px when textarea has 3 line if (curHeight &gt;= 90) return; // 83보다 크고 110보다 작은 값으로 설정 textareaRef.current.style.height = `${curHeight}px`; // 실제 textarea 높이를 스크롤 높이만큼 넓힘 }; 하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다. 그림자 태그를 만들어 해결하기 이를 해결하기 위한 방법을 찾아보던 도중, 링크를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다. 실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다. 현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다. export const ChatTextarea = styled.textarea&lt;{ isShadow?: boolean }&gt;` ${({ theme: { colors, fonts }, isShadow = false }) =&gt; css` ${fonts.main} ${fonts.largeRegular} ... ${isShadow &amp;&amp; // 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정 css` height: 0px; opacity: 0; `} `} `; 우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, width는 그대로 두고, height 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); const shadowTextareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); ... /** get height with shadow textarea */ const setAutoSize = () =&gt; { if (!textareaRef.current || !shadowTextareaRef.current) return; const { scrollHeight: shadowHeight } = shadowTextareaRef.current; // 그림자의 scroll height를 이용해 높이를 구함 const { height: curHeight } = textareaRef.current.style; // maximum height is 83px when textarea has 3 line if (curHeight === `${shadowHeight}px` || shadowHeight &gt;= 90) return; // 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용 textareaRef.current.style.height = `${shadowHeight}px`; }; ... useEffect(() =&gt; { setAutoSize(); }, [chatValue]); &lt;S.ChatTextareaWrapper&gt; &lt;S.ChatTextarea ref={textareaRef} rows={1} spellCheck={false} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} placeholder='메시지를 입력하세요.' /&gt; // 그림자 태그를 만들어 뒤에 숨어있도록 설정 &lt;S.ChatTextarea ref={shadowTextareaRef} isShadow={true} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} readOnly tabIndex={-1} /&gt; &lt;/S.ChatTextareaWrapper&gt; 이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다. 하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다. 채팅창의 높이가 올라갈 때 채팅 내용도 올려주기 이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, position: fixed로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 fixed가 아닌 일반적인 position 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다. 이 부분에서 저는 fixed를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다. position: fixed로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 onHeightChange라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다. const [blockHeight, setBlockHeight] = useState(0); ... const scrollToBottom = () =&gt; { lastBlockRef.current?.scrollIntoView({ block: 'end' }); }; ... const changeBlockHeight = (height: number) =&gt; { setBlockHeight(height); scrollToBottom(); // 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정 }; ... return ( &lt;&gt; &lt;S.Wrapper&gt; {chatroomLogs} &lt;S.LastBottomBlock ref={scrollToBottomRef} blockHeight={blockHeight} /&gt; // 채팅창 뒤 빈 영역을 채워주는 블록 &lt;/S.Wrapper&gt; &lt;ChatroomBar chatroomId={Number(chatroomId)} onHeightChange={changeBlockHeight} /&gt; // 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정 &lt;/&gt; ); 위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HTTP의 특징</title><link href="http://localhost:4000/http/2022/10/26/HTTP%EC%9D%98-%ED%8A%B9%EC%A7%95/" rel="alternate" type="text/html" title="HTTP의 특징" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/http/2022/10/26/HTTP%EC%9D%98%20%ED%8A%B9%EC%A7%95</id><content type="html" xml:base="http://localhost:4000/http/2022/10/26/HTTP%EC%9D%98-%ED%8A%B9%EC%A7%95/"><![CDATA[<blockquote>
  <p>해당 내용은 <a href="https://www.inflearn.com/course/http-웹-네트워크/dashboard">모든 개발자를 위한 HTTP 웹 기본 지식</a> 강의를 수강하여 작성했습니다.</p>
</blockquote>

<h2 id="http">HTTP?</h2>

<p>HTTP는 Hypertext Transfer Protocol의 약자로, 문서 간의 링크를 통해서 연결할 수 있는 프로토콜을 의미합니다. 현재 대부분의 것들(HTML, IMAGE, JSON, XML 등)을 HTTP 메시지에 담아서 전송하고 있습니다. 또한, 서버 간 데이터를 주고 받을 때도 HTTP를 사용합니다.</p>

<p>HTTP는 버전이 여러번 향상되었는데, <strong>HTTP/1.1</strong>가 현재 가장 많이 사용하며 중요한 버전이고, 이후 나온 HTTP/2, HTTP/3은 성능 개선 위주로 나왔습니다.</p>

<p>기반 프로토콜로서, ‘HTTP/1.1, HTTP’에서는 TCP ‘HTTP/3’에서는 UDP를 주로 사용하고 있습니다. 앞서 말했듯, 현재 HTTP/1.1을 주로 사용하며, 2, 3도 점점 사용량이 증가하고 있습니다. 크롬 내에서 개발자 도구 → 네트워크 → 프로토콜을 보면 h2, h3 등이 적힌 것을 통해 어떤 프로토콜을 쓰는지 알 수 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/9.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="http의-특징">HTTP의 특징</h3>

<ul>
  <li>클라이언트 - 서버 구조</li>
  <li>무상태 프로토콜, 비연결성</li>
  <li>HTTP 메시지로 작동</li>
  <li>단순하며 확장 가능</li>
</ul>

<hr />

<h2 id="클라이언트---서버-구조">클라이언트 - 서버 구조</h2>

<ul>
  <li>클라이언트가 서버에게 요청을 보내고 기다리고, 이후 서버가 요청을 받고 응답을 보냅니다.</li>
  <li>클라이언트와 서버의 개념이 분리되어 있습니다. 이로 인해, ‘비즈니스 로직, 데이터’는 서버에 넣어두고 클라이언트는 UI와 사용성에 집중했습니다. 덕분에 클라이언트, 서버가 독립적으로 성장할 수 있었습니다.</li>
  <li>Request, Response 구조로 이루어집니다.</li>
</ul>

<hr />

<h2 id="무상태-프로토콜stateless">무상태 프로토콜(stateless)</h2>

<h3 id="stateful">Stateful</h3>

<p>예를 들어, 물건을 구매해야하는 상황에서 구매자의 원하는 각각의 옵션을 계속 갖고 있는 것은 ‘상태를 보존하는 것’입니다. 이 상황에서 점원이 바뀌는 경우, 상태를 갖고 있다가 없어지기 때문에 상태 중 일부만 넘겨주는 것에 대해 처리를 할 수가 없습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/10.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="stateless">Stateless</h3>

<p>서버가 클라이언트의 상태를 보존하지 않습니다. 위 예시와 같이, 물건을 구매하는 경우, 상태를 갖고 있는 것이 아니라 모든 상태 값들을 처음부터 다시 구매자가 넘기기 때문에 중간에 점원이 바뀌어도 문제없이 처리할 수 있습니다. 이러한 형식은 갑작스러운 클라이언트 요청의 증가가 있어도 서버를 대거 투입하는 것을 통해 문제를 해결할 수 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/11.png" alt="" width="100%" height="" /> 
</figure>

<p>하지만, stateless도 <strong>한계점</strong>이 존재합니다. 단순 소개 화면의 경우 stateless로 하나, 로그인한 사용자의 경우 브라우저 쿠키 ∙ 서버 세션으로 상태를 유지하게 되며 이로 인해 <strong>서버에 로그인 상태를 저장</strong>해야 합니다. 또한, <strong>데이터의 양</strong>이 stateful보다 늘어나게 됩니다.</p>

<hr />

<h2 id="비연결성connectionless">비연결성(connectionless)</h2>

<p>클라이언트 - 서버의 연결을 만든 뒤에 다른 클라이언트와 서버가 연결이 되는 경우, 이전의 연결을 끊지 않게 되면 <strong>서버의 자원을 계속 낭비</strong>하게 됩니다. 이를 해결하기 위해 서버에서 정보를 전달한 뒤에는 바로 연결을 끊습니다.</p>

<h3 id="비연결성에-따른-특징">비연결성에 따른 특징</h3>

<ul>
  <li>일반적으로 초 단위 이하의 빠른 속도로 전송</li>
  <li>실제로 수천명이 서비스를 사용해도 동시처리를 하는 개수는 수십개 이하</li>
  <li>서버 자원을 효율적으로 관리할 수 있음</li>
</ul>

<h3 id="한계점">한계점</h3>

<ul>
  <li>새로운 TCP/IP 연결이 필요해, handshake 시간이 추가</li>
  <li>웹 브라우저로 요청을 하는 경우 HTML, CSS, JS와 같은 많은 자원을 받아야해서 계속 많은 양의 자료가 다시 넘어옴</li>
</ul>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/12.png" alt="" width="100%" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/13.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="해결법">해결법</h3>

<ul>
  <li>문제 해결을 위한 <strong>HTTP 지속 연결</strong> 사용 → 연결을 일정 시간 유지, 필요 데이터들을 다 받은 다음에 종료하도록 설정</li>
  <li>HTTP3 에서는 UDP 프로토콜을 사용해 연결 시간 자체 감소</li>
</ul>

<p>이를 위해 <strong>최대한 stateless하게 설계</strong>를 하는 것이 중요합니다.</p>]]></content><author><name>JinJeon</name></author><category term="HTTP" /><summary type="html"><![CDATA[해당 내용은 모든 개발자를 위한 HTTP 웹 기본 지식 강의를 수강하여 작성했습니다. HTTP? HTTP는 Hypertext Transfer Protocol의 약자로, 문서 간의 링크를 통해서 연결할 수 있는 프로토콜을 의미합니다. 현재 대부분의 것들(HTML, IMAGE, JSON, XML 등)을 HTTP 메시지에 담아서 전송하고 있습니다. 또한, 서버 간 데이터를 주고 받을 때도 HTTP를 사용합니다. HTTP는 버전이 여러번 향상되었는데, HTTP/1.1가 현재 가장 많이 사용하며 중요한 버전이고, 이후 나온 HTTP/2, HTTP/3은 성능 개선 위주로 나왔습니다. 기반 프로토콜로서, ‘HTTP/1.1, HTTP’에서는 TCP ‘HTTP/3’에서는 UDP를 주로 사용하고 있습니다. 앞서 말했듯, 현재 HTTP/1.1을 주로 사용하며, 2, 3도 점점 사용량이 증가하고 있습니다. 크롬 내에서 개발자 도구 → 네트워크 → 프로토콜을 보면 h2, h3 등이 적힌 것을 통해 어떤 프로토콜을 쓰는지 알 수 있습니다. HTTP의 특징 클라이언트 - 서버 구조 무상태 프로토콜, 비연결성 HTTP 메시지로 작동 단순하며 확장 가능 클라이언트 - 서버 구조 클라이언트가 서버에게 요청을 보내고 기다리고, 이후 서버가 요청을 받고 응답을 보냅니다. 클라이언트와 서버의 개념이 분리되어 있습니다. 이로 인해, ‘비즈니스 로직, 데이터’는 서버에 넣어두고 클라이언트는 UI와 사용성에 집중했습니다. 덕분에 클라이언트, 서버가 독립적으로 성장할 수 있었습니다. Request, Response 구조로 이루어집니다. 무상태 프로토콜(stateless) Stateful 예를 들어, 물건을 구매해야하는 상황에서 구매자의 원하는 각각의 옵션을 계속 갖고 있는 것은 ‘상태를 보존하는 것’입니다. 이 상황에서 점원이 바뀌는 경우, 상태를 갖고 있다가 없어지기 때문에 상태 중 일부만 넘겨주는 것에 대해 처리를 할 수가 없습니다. Stateless 서버가 클라이언트의 상태를 보존하지 않습니다. 위 예시와 같이, 물건을 구매하는 경우, 상태를 갖고 있는 것이 아니라 모든 상태 값들을 처음부터 다시 구매자가 넘기기 때문에 중간에 점원이 바뀌어도 문제없이 처리할 수 있습니다. 이러한 형식은 갑작스러운 클라이언트 요청의 증가가 있어도 서버를 대거 투입하는 것을 통해 문제를 해결할 수 있습니다. 하지만, stateless도 한계점이 존재합니다. 단순 소개 화면의 경우 stateless로 하나, 로그인한 사용자의 경우 브라우저 쿠키 ∙ 서버 세션으로 상태를 유지하게 되며 이로 인해 서버에 로그인 상태를 저장해야 합니다. 또한, 데이터의 양이 stateful보다 늘어나게 됩니다. 비연결성(connectionless) 클라이언트 - 서버의 연결을 만든 뒤에 다른 클라이언트와 서버가 연결이 되는 경우, 이전의 연결을 끊지 않게 되면 서버의 자원을 계속 낭비하게 됩니다. 이를 해결하기 위해 서버에서 정보를 전달한 뒤에는 바로 연결을 끊습니다. 비연결성에 따른 특징 일반적으로 초 단위 이하의 빠른 속도로 전송 실제로 수천명이 서비스를 사용해도 동시처리를 하는 개수는 수십개 이하 서버 자원을 효율적으로 관리할 수 있음 한계점 새로운 TCP/IP 연결이 필요해, handshake 시간이 추가 웹 브라우저로 요청을 하는 경우 HTML, CSS, JS와 같은 많은 자원을 받아야해서 계속 많은 양의 자료가 다시 넘어옴 해결법 문제 해결을 위한 HTTP 지속 연결 사용 → 연결을 일정 시간 유지, 필요 데이터들을 다 받은 다음에 종료하도록 설정 HTTP3 에서는 UDP 프로토콜을 사용해 연결 시간 자체 감소 이를 위해 최대한 stateless하게 설계를 하는 것이 중요합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">textarea 줄바꿈 시 자동 스크롤</title><link href="http://localhost:4000/react/2022/10/26/textarea-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%8A%A4%ED%81%AC%EB%A1%A4/" rel="alternate" type="text/html" title="textarea 줄바꿈 시 자동 스크롤" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/26/textarea%20%EC%A4%84%EB%B0%94%EA%BF%88%20%EC%8B%9C%20%EC%9E%90%EB%8F%99%20%EC%8A%A4%ED%81%AC%EB%A1%A4</id><content type="html" xml:base="http://localhost:4000/react/2022/10/26/textarea-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%8A%A4%ED%81%AC%EB%A1%A4/"><![CDATA[<h2 id="textarea-태그-내-줄바꿈-시-문제점">textarea 태그 내 줄바꿈 시 문제점</h2>

<p><code class="language-plaintext highlighter-rouge">textarea</code> 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 <code class="language-plaintext highlighter-rouge">input</code> 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. <code class="language-plaintext highlighter-rouge">input</code> 태그는 한 줄로만 이어져 줄바꿈이 없었지만, <code class="language-plaintext highlighter-rouge">textarea</code>는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/1.png" alt="" width="75%" height="" /> 
</figure>

<p>이러한 문제를 해결하기 위한 방법으로 처음에는 <code class="language-plaintext highlighter-rouge">line-height</code>를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다.</p>

<h2 id="스크롤을-최하단으로-내리기">스크롤을 최하단으로 내리기</h2>

<p>이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// textarea 태그를 받아오기 위한 ref</span>

<span class="kd">const</span> <span class="nx">handleScrollTextarea</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// scroll이 발생하는 상황 시</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollHeight</span><span class="p">;</span>
  <span class="c1">// 스크롤의 위치를 textarea의 최하단으로 옮김</span>
<span class="p">};</span>

<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
  <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">textareaRef</span><span class="si">}</span>
  <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
  <span class="c1">// 스크롤 발생 시 함수 적용</span>
  <span class="na">placeholder</span><span class="p">=</span><span class="s">"메시지를 입력하세요."</span>
<span class="p">/&gt;;</span>
</code></pre></div></div>

<p>하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/2.gif" alt="" width="75%" height="" /> 
</figure>

<h2 id="특정-상황에서만-스크롤을-강제로-내리기">특정 상황에서만 스크롤을 강제로 내리기</h2>

<p>위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">scrollWithTypingRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="c1">// 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref</span>
<span class="kd">const</span> <span class="nx">typingTimeoutRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">NodeJS</span><span class="p">.</span><span class="nx">Timeout</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref</span>

<span class="cm">/** handler for type key */</span>
<span class="kd">const</span> <span class="nx">handleChangeChatValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">inputType</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">nativeEvent</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">inputType</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">insertLineBreak</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span><span class="p">);</span>
  <span class="c1">// 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce)</span>
  <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="c1">// 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정</span>
  <span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">false</span><span class="p">),</span> <span class="mi">500</span><span class="p">);</span>
  <span class="c1">// 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정</span>
<span class="p">};</span>

<span class="cm">/** handler for type 'Enter' key */</span>
<span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span><span class="p">,</span> <span class="nx">keyCode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>
  <span class="c1">// 'keyCode' is deprecated but error occurs when just use 'key' in korean</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">Enter</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">keyCode</span> <span class="o">!==</span> <span class="mi">13</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="c1">// Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
    <span class="c1">// 줄바꿈 추가를 통해 스크롤을 발생시킴</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/** handler for auto scroll during typing */</span>
<span class="kd">const</span> <span class="nx">handleScrollTextarea</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">||</span> <span class="o">!</span><span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollHeight</span><span class="p">;</span>
  <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="c1">// 스크롤이 발생했으므로, 다시 false로 설정</span>
<span class="p">};</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="p">...</span>
  <span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">ChatTextarea</span>
    <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">textareaRef</span><span class="p">}</span>
    <span class="nx">rows</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="nx">spellCheck</span><span class="o">=</span><span class="p">{</span><span class="kc">false</span><span class="p">}</span>
    <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">chatValue</span><span class="p">}</span>
    <span class="nx">onKeyDown</span><span class="o">=</span><span class="p">{</span><span class="nx">handleKeyDownChat</span><span class="p">}</span>
    <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeChatValue</span><span class="p">}</span>
    <span class="nx">onScroll</span><span class="o">=</span><span class="p">{</span><span class="nx">handleScrollTextarea</span><span class="p">}</span>
    <span class="nx">placeholder</span><span class="o">=</span><span class="dl">'</span><span class="s1">메시지를 입력하세요.</span><span class="dl">'</span>
  <span class="o">/&gt;</span>
  <span class="p">...</span>
<span class="p">)</span>
</code></pre></div></div>

<p>위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다.</p>

<ol>
  <li>‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생</li>
  <li>줄바꿈 이전에 실행된 입력으로 인해 <code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = true;</code> 설정</li>
  <li><code class="language-plaintext highlighter-rouge">onScroll</code>에서 <code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = true;</code>여부 확인</li>
  <li><code class="language-plaintext highlighter-rouge">true</code>일 시 자동 스크롤 발생</li>
  <li><code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = false;</code>로 설정</li>
</ol>

<h2 id="결과">결과</h2>

<p>위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/3.gif" alt="" width="75%" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[textarea 태그 내 줄바꿈 시 문제점 textarea 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 input 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. input 태그는 한 줄로만 이어져 줄바꿈이 없었지만, textarea는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다. 이러한 문제를 해결하기 위한 방법으로 처음에는 line-height를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다. 스크롤을 최하단으로 내리기 이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); // textarea 태그를 받아오기 위한 ref const handleScrollTextarea = () =&gt; { // scroll이 발생하는 상황 시 if (!textareaRef.current) return; textareaRef.current.scrollTop = textareaRef.current.scrollHeight; // 스크롤의 위치를 textarea의 최하단으로 옮김 }; &lt;S.ChatTextarea ref={textareaRef} onScroll={handleScrollTextarea} // 스크롤 발생 시 함수 적용 placeholder="메시지를 입력하세요." /&gt;; 하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다. 특정 상황에서만 스크롤을 강제로 내리기 위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); const scrollWithTypingRef = useRef(false); // 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref const typingTimeoutRef = useRef&lt;NodeJS.Timeout&gt;(); // 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref /** handler for type key */ const handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { inputType } = event.nativeEvent as any; if (inputType === 'insertLineBreak') return; setChatValue(event.target.value); if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current); // 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce) scrollWithTypingRef.current = true; // 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정 typingTimeoutRef.current = setTimeout(() =&gt; (scrollWithTypingRef.current = false), 500); // 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정 }; /** handler for type 'Enter' key */ const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey, keyCode } = event; // 'keyCode' is deprecated but error occurs when just use 'key' in korean if (key !== 'Enter' || keyCode !== 13) return; if (!shiftKey) { sendCurChat(); } else { scrollWithTypingRef.current = true; // Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정 setChatValue(chatValue + '\n'); // 줄바꿈 추가를 통해 스크롤을 발생시킴 } }; /** handler for auto scroll during typing */ const handleScrollTextarea = () =&gt; { if (!textareaRef.current || !scrollWithTypingRef.current) return; textareaRef.current.scrollTop = textareaRef.current.scrollHeight; scrollWithTypingRef.current = false; // 스크롤이 발생했으므로, 다시 false로 설정 }; return ( ... &lt;S.ChatTextarea ref={textareaRef} rows={1} spellCheck={false} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} placeholder='메시지를 입력하세요.' /&gt; ... ) 위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다. ‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생 줄바꿈 이전에 실행된 입력으로 인해 scrollWithTypingRef.current = true; 설정 onScroll에서 scrollWithTypingRef.current = true;여부 확인 true일 시 자동 스크롤 발생 scrollWithTypingRef.current = false;로 설정 결과 위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">textarea 태그 Enter 처리 문제</title><link href="http://localhost:4000/react/2022/10/25/textarea-%EC%97%94%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C/" rel="alternate" type="text/html" title="textarea 태그 Enter 처리 문제" /><published>2022-10-25T00:00:00+09:00</published><updated>2022-10-25T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/25/textarea%20%EC%97%94%ED%84%B0%20%EC%B2%98%EB%A6%AC%20%EB%AC%B8%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/react/2022/10/25/textarea-%EC%97%94%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C/"><![CDATA[<h2 id="input-태그를-textarea-태그로-바꾸기">input 태그를 textarea 태그로 바꾸기</h2>

<p>기존에 <code class="language-plaintext highlighter-rouge">input</code> 태그로 되어있던 채팅 입력창을 <code class="language-plaintext highlighter-rouge">textarea</code> 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. <code class="language-plaintext highlighter-rouge">input</code> 태그의 경우 Enter 키를 입력 시 바로 <code class="language-plaintext highlighter-rouge">submit</code> 이벤트가 발생하게 되는 것에 반해, <code class="language-plaintext highlighter-rouge">textarea</code>는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다.</p>

<h2 id="onkeydown-이벤트-적용">onKeyDown 이벤트 적용</h2>

<p>Enter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 <code class="language-plaintext highlighter-rouge">onKeyDown</code>이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">Enter</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// Enter 키 여부 확인</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Shift 키 여부 확인</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
    <span class="c1">// 한 줄 띄운 값으로 기존 채팅값을 변경</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 <code class="language-plaintext highlighter-rouge">onChange</code> 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleChangeChatValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">inputType</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">nativeEvent</span> <span class="k">as</span> <span class="nx">any</span><span class="p">;</span>
  <span class="c1">//</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">inputType</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">insertLineBreak</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘<code class="language-plaintext highlighter-rouge">onChange</code> 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 <code class="language-plaintext highlighter-rouge">nativeEvent</code> 객체 내에 존재하는 <code class="language-plaintext highlighter-rouge">inputType</code>을 찾아 Enter를 누를 시 보여주게 되는 ‘<code class="language-plaintext highlighter-rouge">insertLineBreak</code>’을 사용했습니다.<br />
(이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 <code class="language-plaintext highlighter-rouge">any</code>로 처리했습니다…)</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/1.png" alt="" width="100%" height="" /> 
</figure>

<p>위 과정을 통해서 Enter키를 누른 상황에는 <code class="language-plaintext highlighter-rouge">onKeyDown</code>, 누르지 않은 상황은 <code class="language-plaintext highlighter-rouge">onChange</code>에서 처리를 하는 방식을 사용했습니다.</p>

<h2 id="enter-중복-처리-문제">Enter 중복 처리 문제</h2>

<p>하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/2.gif" alt="" width="50%" height="" /> 
</figure>

<p>이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 <code class="language-plaintext highlighter-rouge">onKeyDown</code> 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/3.png" alt="" width="" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/4.png" alt="" width="" height="" /> 
</figure>

<p>영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 <code class="language-plaintext highlighter-rouge">keyCode</code>를 사용하는 것이었는데, <code class="language-plaintext highlighter-rouge">keyCode</code>를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 <code class="language-plaintext highlighter-rouge">keyCode</code> 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span><span class="p">,</span> <span class="nx">keyCode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>
  <span class="c1">// 'keyCode' is deprecated but error occurs when just use 'key' in korean</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">Enter</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">keyCode</span> <span class="o">!==</span> <span class="mi">13</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="띄워쓰기-스타일-적용하기">띄워쓰기 스타일 적용하기</h3>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/5.png" alt="" width="50%" height="" /> 
</figure>

<p>띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘<code class="language-plaintext highlighter-rouge">\n</code>’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">white-space</span><span class="o">:</span> <span class="nt">pre-wrap</span><span class="o">;</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[input 태그를 textarea 태그로 바꾸기 기존에 input 태그로 되어있던 채팅 입력창을 textarea 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. input 태그의 경우 Enter 키를 입력 시 바로 submit 이벤트가 발생하게 되는 것에 반해, textarea는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다. onKeyDown 이벤트 적용 Enter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 onKeyDown이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다. const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey } = event; if (key !== "Enter") return; // Enter 키 여부 확인 if (!shiftKey) { // Shift 키 여부 확인 sendCurChat(); } else { setChatValue(chatValue + "\n"); // 한 줄 띄운 값으로 기존 채팅값을 변경 } }; 그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 onChange 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다. const handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { inputType } = event.nativeEvent as any; // if (inputType === 'insertLineBreak') return; setChatValue(event.target.value); }; 이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘onChange 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 nativeEvent 객체 내에 존재하는 inputType을 찾아 Enter를 누를 시 보여주게 되는 ‘insertLineBreak’을 사용했습니다. (이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 any로 처리했습니다…) 위 과정을 통해서 Enter키를 누른 상황에는 onKeyDown, 누르지 않은 상황은 onChange에서 처리를 하는 방식을 사용했습니다. Enter 중복 처리 문제 하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다. 이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 onKeyDown 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다. 영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 keyCode를 사용하는 것이었는데, keyCode를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 keyCode 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다. const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey, keyCode } = event; // 'keyCode' is deprecated but error occurs when just use 'key' in korean if (key !== "Enter" || keyCode !== 13) return; if (!shiftKey) { sendCurChat(); } else { setChatValue(chatValue + "\n"); } }; 띄워쓰기 스타일 적용하기 띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘\n’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다. white-space: pre-wrap;]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>