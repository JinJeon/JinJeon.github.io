<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-GB"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-GB" /><updated>2022-11-04T09:39:24+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JINJEONIMUM</title><subtitle></subtitle><author><name>JinJeon</name></author><entry><title type="html">IP, TCP ∙ UDP</title><link href="http://localhost:4000/react/2022/10/20/IP_TCP_UDP/" rel="alternate" type="text/html" title="IP, TCP ∙ UDP" /><published>2022-10-20T00:00:00+09:00</published><updated>2022-10-20T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/20/IP_TCP_UDP</id><content type="html" xml:base="http://localhost:4000/react/2022/10/20/IP_TCP_UDP/"><![CDATA[<h2 id="ipinternet-protocol">IP(Internet Protocol)</h2>

<p>IP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다.</p>

<p>클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 <strong>‘패킷’</strong>이라는 단위를 사용합니다.</p>

<p><strong>클라이언트 주소, 서버 주소, 보낼 내용</strong> 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221020/Untitled-8.png" alt="" width="" height="" /> 
</figure>

<h3 id="문제점">문제점</h3>

<ol>
  <li><strong>비연결성</strong> : 패킷 대상이 없거나 불능이어도 보내게 됩니다.</li>
  <li><strong>비신뢰성</strong> : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다.
    <ul>
      <li>중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다.</li>
      <li>1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다.</li>
    </ul>
  </li>
  <li><strong>프로그램 구분</strong> : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다.</li>
</ol>

<hr />

<h2 id="tcpudp">TCP/UDP</h2>

<p>인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다.</p>

<ol>
  <li>애플리케이션 계층 - HTTP, FTP</li>
  <li>전송 계층 - TDP, UDP (IP 보완)</li>
  <li>인터넷 계층 - IP</li>
  <li>네트워크 인터페이스 계층 - LAN 드라이버 등</li>
</ol>

<h3 id="순서">순서</h3>

<figure class="figure  figure--center">
  <img class="image" src="/image/221020/Untitled-9.png" alt="" width="" height="" /> 
</figure>

<ol>
  <li>일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달</li>
  <li>OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함</li>
  <li>이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄</li>
  <li>서버로 전송</li>
</ol>

<h3 id="ip-tcp-패킷-정보">IP, TCP 패킷 정보</h3>

<p>패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다.</p>

<p>TCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221020/Untitled-10.png" alt="" width="" height="" /> 
</figure>

<h3 id="tcp의-특징">TCP의 특징</h3>

<ol>
  <li>TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다.</li>
  <li>먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake)</li>
  <li>데이터가 상대에게 제대로 보내졌는지를 확인하는 <strong>데이터 전달 보증</strong>이 이루어집니다.</li>
  <li>데이터가 보낸 순서대로 도착하도록 하는 <strong>순서 보증</strong>의 역할을 합니다.</li>
  <li>위와 같은 기능들을 갖고 있어 <strong>신뢰가능</strong>한 프로토콜입니다.</li>
</ol>

<h3 id="tcp-3-way-handshake">TCP 3 way handshake</h3>

<p>클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다.</p>

<ol>
  <li>클라이언트가 서버에게 요청</li>
  <li>서버가 요청을 수락하고 다시 클라이언트에게 요청</li>
  <li>클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송)</li>
  <li>데이터 전송</li>
</ol>

<figure class="figure  figure--center">
  <img class="image" src="/image/221020/Untitled-11.png" alt="" width="" height="" /> 
</figure>

<p>TCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 <strong>클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미</strong>합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다.</p>

<h3 id="장점">장점</h3>

<ul>
  <li>전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다.</li>
  <li>순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.)</li>
</ul>

<figure class="figure  figure--center">
  <img class="image" src="/image/221020/Untitled-12.png" alt="" width="" height="" /> 
</figure>

<hr />

<h3 id="udp">UDP</h3>

<p>사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다.</p>

<h3 id="udp의-특징">UDP의 특징</h3>

<ul>
  <li>하얀 도화지에 비유되며 기능이 거의 없습니다.</li>
  <li>연결 지향성을 띄며 3-way handshake가 없습니다.</li>
  <li>데이터 전달 보증이나 순서 보증이 없습니다.</li>
  <li>IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, <strong>각 패킷의 용도를 구분하기 위해 PORT를 사용</strong>하며. <strong>체크섬은 메세지가 제대로 된 것인지 확인하는 용도</strong>로 사용됩니다.</li>
  <li>UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다.</li>
  <li>주목받는 이유로 아래와 같은 사항들이 있습니다.
    <ol>
      <li>TCP의 단점인 3 way handshake로 인한 시간</li>
      <li>여러 데이터들로 인한 데이터 양 증가 → 속도 감소</li>
      <li>TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움</li>
      <li>무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음</li>
    </ol>
  </li>
  <li>UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.</li>
</ul>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[IP(Internet Protocol) IP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다. 클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 ‘패킷’이라는 단위를 사용합니다. 클라이언트 주소, 서버 주소, 보낼 내용 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다. 문제점 비연결성 : 패킷 대상이 없거나 불능이어도 보내게 됩니다. 비신뢰성 : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다. 중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다. 1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다. 프로그램 구분 : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다. TCP/UDP 인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다. 애플리케이션 계층 - HTTP, FTP 전송 계층 - TDP, UDP (IP 보완) 인터넷 계층 - IP 네트워크 인터페이스 계층 - LAN 드라이버 등 순서 일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달 OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함 이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄 서버로 전송 IP, TCP 패킷 정보 패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다. TCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다. TCP의 특징 TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다. 먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake) 데이터가 상대에게 제대로 보내졌는지를 확인하는 데이터 전달 보증이 이루어집니다. 데이터가 보낸 순서대로 도착하도록 하는 순서 보증의 역할을 합니다. 위와 같은 기능들을 갖고 있어 신뢰가능한 프로토콜입니다. TCP 3 way handshake 클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다. 클라이언트가 서버에게 요청 서버가 요청을 수락하고 다시 클라이언트에게 요청 클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송) 데이터 전송 TCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다. 장점 전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다. 순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.) UDP 사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다. UDP의 특징 하얀 도화지에 비유되며 기능이 거의 없습니다. 연결 지향성을 띄며 3-way handshake가 없습니다. 데이터 전달 보증이나 순서 보증이 없습니다. IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, 각 패킷의 용도를 구분하기 위해 PORT를 사용하며. 체크섬은 메세지가 제대로 된 것인지 확인하는 용도로 사용됩니다. UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다. 주목받는 이유로 아래와 같은 사항들이 있습니다. TCP의 단점인 3 way handshake로 인한 시간 여러 데이터들로 인한 데이터 양 증가 → 속도 감소 TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움 무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음 UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">REACT DATEPICKER</title><link href="http://localhost:4000/react/2022/10/11/react_datepicker/" rel="alternate" type="text/html" title="REACT DATEPICKER" /><published>2022-10-11T00:00:00+09:00</published><updated>2022-10-11T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/11/react_datepicker</id><content type="html" xml:base="http://localhost:4000/react/2022/10/11/react_datepicker/"><![CDATA[<p>날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">DateInputForm</span> <span class="na">type</span><span class="p">=</span><span class="s">'date'</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentDateTime</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDateTime</span><span class="si">}</span> <span class="p">/&gt;</span>
<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">DateInputForm</span> <span class="na">type</span><span class="p">=</span><span class="s">'time'</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentTime</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeTime</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/first.gif" alt="" width="35%" height="" /> 
</figure>

<p>하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다.<br />
(링크 : <a href="https://reactdatepicker.com/">React Datepicker crafted by HackerOne</a>)</p>

<p>설치는 아래 코드들로 진행했습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install react-datepicker --save
npm install @types/react-datepicker
</code></pre></div></div>

<hr />

<h3 id="날짜-설정">날짜 설정</h3>

<p>사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">react-datepicker/dist/react-datepicker.css</span><span class="dl">"</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">ReactDatePicker</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-datepicker</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">StyledDatePicker</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">(</span><span class="nx">ReactDatePicker</span><span class="p">)</span><span class="s2">`
  border: none;
  background-color: transparent;
  padding: 0;
`</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledDatePicker</span>
  <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
  <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDate</span><span class="si">}</span>
  <span class="na">dateFormat</span><span class="p">=</span><span class="s">"yyyy.MM.dd"</span>
<span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/date default.png" alt="" width="50%" height="" /> 
</figure>

<p>이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nx">react</span><span class="o">-</span><span class="nx">datepicker</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="nx">__day</span> <span class="p">{</span>
	  <span class="nx">$</span><span class="p">{</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">xSmall</span><span class="p">};</span>
	  <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey4</span><span class="p">};</span>
	  <span class="nl">width</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">100</span><span class="o">%</span> <span class="sr">/ 10</span><span class="se">)</span><span class="err">;
</span>	  <span class="nx">aspect</span><span class="o">-</span><span class="nx">ratio</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="nx">line</span><span class="o">-</span><span class="nx">height</span><span class="p">:</span> <span class="nx">initial</span><span class="p">;</span>
	  <span class="nl">display</span><span class="p">:</span> <span class="nx">inline</span><span class="o">-</span><span class="nx">flex</span><span class="p">;</span>
	  <span class="nx">align</span><span class="o">-</span><span class="nx">items</span><span class="p">:</span> <span class="nx">center</span><span class="p">;</span>
	  <span class="nx">justify</span><span class="o">-</span><span class="nx">content</span><span class="p">:</span> <span class="nx">center</span><span class="p">;</span>
	  <span class="nl">margin</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>

	  <span class="p">:</span><span class="nx">hover</span> <span class="p">{</span>
	    <span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="p">:</span> <span class="mi">10</span><span class="nx">rem</span><span class="p">;</span>
	  <span class="p">}</span>

	  <span class="o">&amp;-</span><span class="nx">name</span> <span class="p">{</span>
	    <span class="nx">$</span><span class="p">{</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">xSmall</span><span class="p">};</span>

		<span class="p">...</span>

	  <span class="o">&amp;--</span><span class="nx">disabled</span> <span class="p">{</span>
	    <span class="nx">text</span><span class="o">-</span><span class="nx">decoration</span><span class="p">:</span> <span class="nx">line</span><span class="o">-</span><span class="nx">through</span><span class="p">;</span>
	    <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey3</span><span class="p">};</span>
	  <span class="p">}</span>
	<span class="p">}</span>


</code></pre></div></div>

<p>날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(<code class="language-plaintext highlighter-rouge">react-datepicker__current-month</code>)와 같은 선상에 있으면서 <code class="language-plaintext highlighter-rouge">position: absolute</code>로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 <code class="language-plaintext highlighter-rouge">top</code>으로 직접 받아 처리하도록 우선 구성했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&amp;</span><span class="nx">__current</span> <span class="p">{</span>
  <span class="o">&amp;-</span><span class="nx">month</span> <span class="p">{</span>
    <span class="nx">text</span><span class="o">-</span><span class="nx">align</span><span class="p">:</span> <span class="nx">left</span><span class="p">;</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">left</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">100</span><span class="o">%</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">80</span> <span class="o">-</span> <span class="mi">5</span><span class="nx">px</span><span class="p">);</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">bottom</span><span class="p">:</span> <span class="mf">0.5</span><span class="nx">rem</span><span class="p">;</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">top</span><span class="p">:</span> <span class="mf">0.75</span><span class="nx">rem</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">&amp;</span><span class="nx">__navigation</span> <span class="p">{</span>
	  <span class="o">&amp;--</span><span class="nx">previous</span> <span class="p">{</span>
	    <span class="nl">top</span><span class="p">:</span> <span class="mi">5</span><span class="nx">px</span><span class="p">;</span>
	    <span class="nl">left</span><span class="p">:</span> <span class="nx">unset</span><span class="p">;</span>
	    <span class="nl">right</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">32</span><span class="nx">px</span><span class="p">);</span>
	  <span class="p">}</span>
	  <span class="o">&amp;--</span><span class="nx">next</span> <span class="p">{</span>
	    <span class="nl">top</span><span class="p">:</span> <span class="mi">5</span><span class="nx">px</span><span class="p">;</span>
	    <span class="nl">right</span><span class="p">:</span> <span class="mi">0</span><span class="nx">px</span><span class="p">;</span>
	  <span class="p">}</span>
	  <span class="o">&amp;-</span><span class="nx">icon</span> <span class="p">{</span>
	    <span class="p">::</span><span class="nx">before</span> <span class="p">{</span>
	      <span class="nl">border</span><span class="p">:</span> <span class="nx">none</span><span class="p">;</span>
	    <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>datepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledDatePicker</span>
  <span class="na">selected</span><span class="p">=</span><span class="si">{</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">appointmentDateTime</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 선택된 날짜를 지정</span>
  <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDate</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">dateFormat</span><span class="p">=</span><span class="s">"yyyy.MM.dd"</span>
  <span class="c1">// input에 보이는 날짜 형식 설정</span>
  <span class="na">minDate</span><span class="p">=</span><span class="si">{</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()</span><span class="si">}</span>
  <span class="c1">// 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨</span>
  <span class="na">showPopperArrow</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
  <span class="c1">// 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정</span>
  <span class="na">formatWeekDay</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">nameOfDay</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">nameOfDay</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경</span>
  <span class="na">nextMonthButtonLabel</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronRight"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.75</span><span class="si">}</span> <span class="p">/&gt;</span><span class="si">}</span>
  <span class="c1">// 다음 달 보기 버튼 표현방식 변경</span>
  <span class="na">previousMonthButtonLabel</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronLeft"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.75</span><span class="si">}</span> <span class="p">/&gt;</span><span class="si">}</span>
  <span class="c1">// 이전 달 보기 버튼 표현방식 변경</span>
<span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/date finish.gif" alt="" width="50%" height="" /> 
</figure>

<h3 id="시간-설정">시간 설정</h3>

<p>시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다.</p>

<div style="display: flex">
  <figure class="figure  figure--center">
  <img class="image" src="/image/221011/time design.png" alt="" width="65%" height="" /> 
</figure>

  <figure class="figure  figure--center">
  <img class="image" src="/image/221011/time default.png" alt="" width="100%" height="" /> 
</figure>

</div>

<p>왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다.</p>

<p>시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">StyledTimePicker</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">(</span><span class="nx">ReactDatePicker</span><span class="p">)</span><span class="s2">`
  width: 100%;
  border: none;
  background-color: transparent;
  padding: 0;

  :focus {
    outline: none;
  }
`</span><span class="p">;</span>

<span class="p">...</span>

<span class="o">&amp;</span><span class="nx">__header</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">&amp;--</span><span class="nx">time</span> <span class="p">{</span>
    <span class="nx">background</span><span class="o">-</span><span class="nx">color</span><span class="p">:</span> <span class="nx">transparent</span><span class="p">;</span>
    <span class="nx">border</span><span class="o">-</span><span class="nx">bottom</span><span class="p">:</span> <span class="nx">none</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">&amp;-</span><span class="nx">time__header</span> <span class="p">{</span>
  <span class="nx">$</span><span class="p">{</span><span class="nx">flexCenter</span><span class="p">};</span>

  <span class="nx">justify</span><span class="o">-</span><span class="nx">content</span><span class="p">:</span> <span class="nx">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">word</span><span class="o">-</span><span class="nx">spacing</span><span class="p">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="mi">0</span> <span class="nx">auto</span><span class="p">;</span>
  <span class="nx">white</span><span class="o">-</span><span class="nx">space</span><span class="p">:</span> <span class="nx">pre</span><span class="p">;</span>
  <span class="nx">font</span><span class="o">-</span><span class="nx">size</span><span class="p">:</span> <span class="mi">8</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">font</span><span class="o">-</span><span class="nx">weight</span><span class="p">:</span> <span class="mi">400</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="mi">25</span><span class="nx">px</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey4</span><span class="p">};</span>
<span class="p">}</span>

<span class="p">...</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">TimeInputWrapper</span> <span class="na">isTimeFocused</span><span class="p">=</span><span class="si">{</span><span class="nx">isTimeFocused</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledTimePicker</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeTimeTest</span><span class="si">}</span>
    <span class="c1">// 기존 input과 동일</span>
    <span class="na">timeIntervals</span><span class="p">=</span><span class="si">{</span><span class="nx">timeIntervals</span><span class="si">}</span>
    <span class="c1">// 시간 설정의 간격을 조절함</span>
    <span class="na">showTimeSelect</span>
    <span class="na">showTimeSelectOnly</span>
    <span class="c1">// 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함</span>
    <span class="na">selected</span><span class="p">=</span><span class="si">{</span><span class="nx">currentTimeDateType</span><span class="si">}</span>
    <span class="c1">// 선택된 시간에 selected 클래스를 지정함</span>
    <span class="na">showPopperArrow</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
    <span class="na">timeFormat</span><span class="p">=</span><span class="s">"HH mm aa"</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentTime</span><span class="si">}</span>
    <span class="na">timeCaption</span><span class="p">=</span><span class="s">"HOUR MINUTE"</span>
    <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsTimeFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
    <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsTimeFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronDown"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.9</span><span class="si">}</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">TimeInputWrapper</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다.</p>

<p>단, 시간 설정을 할 때에는 <code class="language-plaintext highlighter-rouge">showTimeSelect</code>, <code class="language-plaintext highlighter-rouge">showTimeSelectOnly</code> 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다.</p>

<p>시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/time finish.gif" alt="" width="45%" height="" /> 
</figure>

<h3 id="특이-사항">특이 사항</h3>

<p>스타일 관련 작업들을 진행하면서, <code class="language-plaintext highlighter-rouge">!important</code>를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. <code class="language-plaintext highlighter-rouge">!important</code>를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.</p>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다. &lt;S.DateInputForm type='date' value={appointmentDateTime} onChange={handelChangeDateTime} /&gt; &lt;S.DateInputForm type='time' value={appointmentTime} onChange={handelChangeTime} /&gt; 하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다. (링크 : React Datepicker crafted by HackerOne) 설치는 아래 코드들로 진행했습니다. npm install react-datepicker --save npm install @types/react-datepicker 날짜 설정 사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다. import "react-datepicker/dist/react-datepicker.css"; import ReactDatePicker from "react-datepicker"; export const StyledDatePicker = styled(ReactDatePicker)` border: none; background-color: transparent; padding: 0; `; &lt;S.StyledDatePicker onFocus={() =&gt; setIsDateFocused(true)} onBlur={() =&gt; setIsDateFocused(false)} onChange={handelChangeDate} dateFormat="yyyy.MM.dd" /&gt; 이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다. .react-datepicker { &amp;__day { ${fonts.xSmall}; color: ${colors.grey4}; width: calc(100% / 10); aspect-ratio: 1; line-height: initial; display: inline-flex; align-items: center; justify-content: center; margin: 0; :hover { border-radius: 10rem; } &amp;-name { ${fonts.xSmall}; ... &amp;--disabled { text-decoration: line-through; color: ${colors.grey3}; } } 날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(react-datepicker__current-month)와 같은 선상에 있으면서 position: absolute로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 top으로 직접 받아 처리하도록 우선 구성했습니다. &amp;__current { &amp;-month { text-align: left; padding-left: calc(100% * 7 / 80 - 5px); padding-bottom: 0.5rem; padding-top: 0.75rem; } } &amp;__navigation { &amp;--previous { top: 5px; left: unset; right: calc(32px); } &amp;--next { top: 5px; right: 0px; } &amp;-icon { ::before { border: none; } } } } datepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다. &lt;S.StyledDatePicker selected={new Date(appointmentDateTime)} // 선택된 날짜를 지정 onFocus={() =&gt; setIsDateFocused(true)} // 기존 input과 동일 onBlur={() =&gt; setIsDateFocused(false)} // 기존 input과 동일 onChange={handelChangeDate} // 기존 input과 동일 dateFormat="yyyy.MM.dd" // input에 보이는 날짜 형식 설정 minDate={new Date()} // 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨 showPopperArrow={false} // 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정 formatWeekDay={(nameOfDay) =&gt; nameOfDay.substring(0, 1)} // 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경 nextMonthButtonLabel={&lt;Icon iconName="ChevronRight" iconSize={0.75} /&gt;} // 다음 달 보기 버튼 표현방식 변경 previousMonthButtonLabel={&lt;Icon iconName="ChevronLeft" iconSize={0.75} /&gt;} // 이전 달 보기 버튼 표현방식 변경 /&gt; 시간 설정 시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다. 왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다. 시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다. export const StyledTimePicker = styled(ReactDatePicker)` width: 100%; border: none; background-color: transparent; padding: 0; :focus { outline: none; } `; ... &amp;__header { padding: 0; &amp;--time { background-color: transparent; border-bottom: none; } } &amp;-time__header { ${flexCenter}; justify-content: left; width: 100px; word-spacing: 10px; margin: 0 auto; white-space: pre; font-size: 8px; font-weight: 400; height: 25px; color: ${colors.grey4}; } ... &lt;S.TimeInputWrapper isTimeFocused={isTimeFocused}&gt; &lt;S.StyledTimePicker onChange={handleChangeTimeTest} // 기존 input과 동일 timeIntervals={timeIntervals} // 시간 설정의 간격을 조절함 showTimeSelect showTimeSelectOnly // 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함 selected={currentTimeDateType} // 선택된 시간에 selected 클래스를 지정함 showPopperArrow={false} timeFormat="HH mm aa" value={appointmentTime} timeCaption="HOUR MINUTE" onFocus={() =&gt; setIsTimeFocused(true)} onBlur={() =&gt; setIsTimeFocused(false)} /&gt; &lt;Icon iconName="ChevronDown" iconSize={0.9} /&gt; &lt;/S.TimeInputWrapper&gt; 날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다. 단, 시간 설정을 할 때에는 showTimeSelect, showTimeSelectOnly 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다. 시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다. 특이 사항 스타일 관련 작업들을 진행하면서, !important를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. !important를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">깊이 우선 그래프 순회</title><link href="http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C-copy/" rel="alternate" type="text/html" title="깊이 우선 그래프 순회" /><published>2022-10-10T00:00:00+09:00</published><updated>2022-10-10T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C%20copy</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C-copy/"><![CDATA[<p>트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다.</p>

<p>여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다.</p>

<ul>
  <li>위키피디아의 링크 내 이동 시 최단 거리 찾기</li>
  <li>페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능</li>
  <li>GPS 네비게이션</li>
  <li>미로 문제 풀기</li>
</ul>

<h3 id="dfs-순회">DFS 순회?</h3>

<p>그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다.</p>

<p>핵심은 각 노드마다 있는 가지 중 <strong>방문하지 않은 곳을 방문하는</strong> 형식으로 이루어집니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="na">A</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">B</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">C</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">D</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">E</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">F</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221010/graph.png" alt="" width="35%" height="" /> 
</figure>

<h3 id="재귀형-dfs-순회">재귀형 DFS 순회</h3>

<p>재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">depthFirstRecursive</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과를 담을 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문한 곳을 나타내는 객체</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">graph</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 해당 함수가 사용되는 전체 그래프</span>
  <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">point</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="c1">// 값이 없을경우에 대한 예외 처리</span>
    <span class="nx">visited</span><span class="p">[</span><span class="nx">point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="c1">// dfs가 사용되었으므로 방문했음을 표기</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
    <span class="c1">// 결과에 해당 포인트에 대한 결과 입력</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">point</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextPoint</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 해당 포인트와 연결된 다음 포인트에 대해서 처리</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextPoint</span><span class="p">])</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">nextPoint</span><span class="p">);</span>
      <span class="c1">// 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리</span>
    <span class="p">});</span>
  <span class="p">};</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span>
	<span class="c1">// 시작 지점에서 처리 시작</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">depthFirstRecursive</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// [ 'A', 'B', 'D', 'E', 'C', 'F' ]</span>
</code></pre></div></div>

<p>재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다.</p>

<p>여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다.</p>

<h3 id="반복형-dfs-순회">반복형 DFS 순회</h3>

<p><code class="language-plaintext highlighter-rouge">while</code>을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">depthFirstIterative</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문 확인 배열</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">graph</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 현재 그래프</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nx">vertex</span><span class="p">];</span>
  <span class="c1">// 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴</span>

  <span class="kd">let</span> <span class="nx">curVertex</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="c1">// while문을 돌면서 현재의 위치를 나타내는 변수</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curVertex</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="c1">// DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요!</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curVertex</span><span class="p">);</span>
    <span class="c1">// 결과에 방문에 대한 결과값 처리</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">curVertex</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextVertex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 현재 위치의 다음 위치들에 대해서 방문 여부 확인</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
      <span class="c1">// 방문하지 않았을 시 stack에 추가</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에,</span>
      <span class="c1">// stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextVertex</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221010/graph order.png" alt="" width="35%" height="" /> 
</figure>

<p>반복을 사용하는 경우 <code class="language-plaintext highlighter-rouge">while</code>문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다.</p>

<p><code class="language-plaintext highlighter-rouge">while</code>을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다.</p>

<p>그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다. 여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다. 위키피디아의 링크 내 이동 시 최단 거리 찾기 페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능 GPS 네비게이션 미로 문제 풀기 DFS 순회? 그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다. 핵심은 각 노드마다 있는 가지 중 방문하지 않은 곳을 방문하는 형식으로 이루어집니다. { A: [ 'B', 'C' ], B: [ 'A', 'D' ], C: [ 'A', 'E' ], D: [ 'B', 'E', 'F' ], E: [ 'C', 'D', 'F' ], F: [ 'D', 'E' ] } 재귀형 DFS 순회 재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다. depthFirstRecursive(vertex) { const result = []; // 결과를 담을 배열 const visited = {}; // 방문한 곳을 나타내는 객체 const { graph } = this; // 해당 함수가 사용되는 전체 그래프 const dfs = (point) =&gt; { if (!point) return null; // 값이 없을경우에 대한 예외 처리 visited[point] = true; // dfs가 사용되었으므로 방문했음을 표기 result.push(point); // 결과에 해당 포인트에 대한 결과 입력 graph[point].forEach((nextPoint) =&gt; { // 해당 포인트와 연결된 다음 포인트에 대해서 처리 if (!visited[nextPoint]) dfs(nextPoint); // 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리 }); }; dfs(vertex); // 시작 지점에서 처리 시작 return result; } console.log(g.depthFirstRecursive("A")); // [ 'A', 'B', 'D', 'E', 'C', 'F' ] 재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다. 여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다. 반복형 DFS 순회 while을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다. depthFirstIterative(vertex) { const result = []; // 결과 배열 const visited = {}; // 방문 확인 배열 const { graph } = this; // 현재 그래프 const stack = [vertex]; // 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴 let curVertex; visited[vertex] = true; // while문을 돌면서 현재의 위치를 나타내는 변수 while (stack.length) { curVertex = stack.pop(); // DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요! result.push(curVertex); // 결과에 방문에 대한 결과값 처리 graph[curVertex].forEach((nextVertex) =&gt; { // 현재 위치의 다음 위치들에 대해서 방문 여부 확인 if (visited[nextVertex]) return; // 방문하지 않았을 시 stack에 추가 visited[nextVertex] = true; // 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에, // stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음 stack.push(nextVertex); }); } return result; } 반복을 사용하는 경우 while문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다. while을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다. 그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">자동 스크롤을 위한 React의 Callback Ref</title><link href="http://localhost:4000/react/2022/09/25/CallBackRef-copy/" rel="alternate" type="text/html" title="자동 스크롤을 위한 React의 Callback Ref" /><published>2022-09-25T00:00:00+09:00</published><updated>2022-09-25T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/09/25/CallBackRef%20copy</id><content type="html" xml:base="http://localhost:4000/react/2022/09/25/CallBackRef-copy/"><![CDATA[<p>채팅을 구현하는 상황에서, 채팅의 경우 첫 렌더링 시 무조건 가장 하단의 채팅부터 보여주어야 하기 때문에, 이를 위해서 렌더링 후 바로 채팅의 하단을 보여주는 것을 구현했습니다.</p>

<p>이 상황에서 기존에는 두 가지 방법을 사용했습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">window</code>의 <code class="language-plaintext highlighter-rouge">scroll</code> 기능 사용하기</li>
  <li><code class="language-plaintext highlighter-rouge">useEffect</code>와 <code class="language-plaintext highlighter-rouge">ref</code>를 적용해 보여주기</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">scrollTo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">offsetHeight</span><span class="p">);</span>
</code></pre></div></div>

<p>두 방법 중 처음에는 위와 같이 1번의 방법을 사용했으나, 리액트의 특성을 살리지 못한다는 판단이 들어(<code class="language-plaintext highlighter-rouge">document.body</code>와 같은 부분에서), 2번의 방법을 시도했었습니다.</p>

<p><code class="language-plaintext highlighter-rouge">useEffect</code>를 사용하고, 의존성에 <code class="language-plaintext highlighter-rouge">ref</code>를 부여하는 방법으로 원래 해결을 하려고 했으나, 이는 올바르지 않은 방법임을 곧 알게 됐습니다.</p>

<p>왜냐하면, 렌더링을 건너뛰는<code class="language-plaintext highlighter-rouge">useEffect</code> 의 경우, 컴포넌트가 다시 렌더링이 이루어질 때까지 <code class="language-plaintext highlighter-rouge">ref</code>가 업데이트 된 것을 확인할 수가 없기 때문입니다. 즉, 이미 설정된 <code class="language-plaintext highlighter-rouge">ref</code>에 대해서는 <code class="language-plaintext highlighter-rouge">useEffect</code> 내부의 메소드가 작동하지만(원래 한 번 동작하므로), 이후에는 <code class="language-plaintext highlighter-rouge">ref</code>의 변경이 있어도, 그 순서가 <code class="language-plaintext highlighter-rouge">useEffect</code>보다 늦다면, 의존성 배열에 담아주어도 전혀 반응하지 않습니다.</p>

<p>즉, <code class="language-plaintext highlighter-rouge">ref</code>를 <code class="language-plaintext highlighter-rouge">useEffect</code>에 넣는 것은 렌더링이 모두 이루어진 다음에 수행하는 데에 적합하지 않은 방식이기 때문에, <code class="language-plaintext highlighter-rouge">ref</code>의 지정에 따른 메소드를 수행하는 방법이 필요했습니다.</p>

<p>그 과정에서 발견한 것이 <code class="language-plaintext highlighter-rouge">callback ref</code>라는 개념인데, 이는 React에 기본적으로 내장된 기능으로서, React Element의 <code class="language-plaintext highlighter-rouge">ref</code> props에 <code class="language-plaintext highlighter-rouge">useCallback</code>으로 설정된 함수를 넣어주는 경우, 해당 React Element가 파라미터가 되어, 해당 함수를 실행하게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//**callback ref for scroll to bottom */</span>
<span class="kd">const</span> <span class="nx">scrollToBottomRef</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">lastChatDiv</span><span class="p">:</span> <span class="nx">HTMLDivElement</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">lastChatDiv</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// change target only if last chat didn't exist</span>
  <span class="nx">setLastChat</span><span class="p">((</span><span class="nx">prevLastChat</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">prevLastChat</span> <span class="p">?</span> <span class="nx">prevLastChat</span> <span class="p">:</span> <span class="nx">lastChatDiv</span><span class="p">));</span>
  <span class="nx">lastChatDiv</span><span class="p">.</span><span class="nx">scrollIntoView</span><span class="p">({</span> <span class="na">block</span><span class="p">:</span> <span class="dl">"</span><span class="s2">end</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">},</span> <span class="p">[]);</span>
</code></pre></div></div>

<p>위 함수가 해당 기능을 하는 함수인데, 위와 같이 lastChatDiv라는 element를 받는 함수를 만들어, 해당 함수 내에 원하는 기능이 이루어지도록 했습니다.</p>

<p>위 함수를 통해, 처음에 페이지에 진입하는 상황에 대해서 지정된 요소(가장 하단 요소)로 스크롤이 이루어지도록 만들었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="p">(</span>
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Date</span><span class="p">&gt;</span>2021년 5월 29일<span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Date</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Chats</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">chatroomLogs</span><span class="si">}</span>
      <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">EmptyBlock</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">scrollToBottomRef</span><span class="si">}</span> <span class="p">/&gt;</span>
      // 최하단에 만들어지는 빈 블록으로, 이 곳에 설정을 해주어 이 곳에 이동이
      되도록 합니다.
    <span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Chats</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
<span class="p">);</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[채팅을 구현하는 상황에서, 채팅의 경우 첫 렌더링 시 무조건 가장 하단의 채팅부터 보여주어야 하기 때문에, 이를 위해서 렌더링 후 바로 채팅의 하단을 보여주는 것을 구현했습니다. 이 상황에서 기존에는 두 가지 방법을 사용했습니다. window의 scroll 기능 사용하기 useEffect와 ref를 적용해 보여주기 window.scrollTo(0, document.body.offsetHeight); 두 방법 중 처음에는 위와 같이 1번의 방법을 사용했으나, 리액트의 특성을 살리지 못한다는 판단이 들어(document.body와 같은 부분에서), 2번의 방법을 시도했었습니다. useEffect를 사용하고, 의존성에 ref를 부여하는 방법으로 원래 해결을 하려고 했으나, 이는 올바르지 않은 방법임을 곧 알게 됐습니다. 왜냐하면, 렌더링을 건너뛰는useEffect 의 경우, 컴포넌트가 다시 렌더링이 이루어질 때까지 ref가 업데이트 된 것을 확인할 수가 없기 때문입니다. 즉, 이미 설정된 ref에 대해서는 useEffect 내부의 메소드가 작동하지만(원래 한 번 동작하므로), 이후에는 ref의 변경이 있어도, 그 순서가 useEffect보다 늦다면, 의존성 배열에 담아주어도 전혀 반응하지 않습니다. 즉, ref를 useEffect에 넣는 것은 렌더링이 모두 이루어진 다음에 수행하는 데에 적합하지 않은 방식이기 때문에, ref의 지정에 따른 메소드를 수행하는 방법이 필요했습니다. 그 과정에서 발견한 것이 callback ref라는 개념인데, 이는 React에 기본적으로 내장된 기능으로서, React Element의 ref props에 useCallback으로 설정된 함수를 넣어주는 경우, 해당 React Element가 파라미터가 되어, 해당 함수를 실행하게 됩니다. //**callback ref for scroll to bottom */ const scrollToBottomRef = useCallback((lastChatDiv: HTMLDivElement) =&gt; { if (!lastChatDiv) return; // change target only if last chat didn't exist setLastChat((prevLastChat) =&gt; (prevLastChat ? prevLastChat : lastChatDiv)); lastChatDiv.scrollIntoView({ block: "end" }); }, []); 위 함수가 해당 기능을 하는 함수인데, 위와 같이 lastChatDiv라는 element를 받는 함수를 만들어, 해당 함수 내에 원하는 기능이 이루어지도록 했습니다. 위 함수를 통해, 처음에 페이지에 진입하는 상황에 대해서 지정된 요소(가장 하단 요소)로 스크롤이 이루어지도록 만들었습니다. return ( &lt;S.Wrapper&gt; &lt;S.Date&gt;2021년 5월 29일&lt;/S.Date&gt; &lt;S.Chats&gt; {chatroomLogs} &lt;S.EmptyBlock ref={scrollToBottomRef} /&gt; // 최하단에 만들어지는 빈 블록으로, 이 곳에 설정을 해주어 이 곳에 이동이 되도록 합니다. &lt;/S.Chats&gt; &lt;/S.Wrapper&gt; );]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SOCKET 연결 및 채팅</title><link href="http://localhost:4000/javascript/2022/08/16/socket/" rel="alternate" type="text/html" title="SOCKET 연결 및 채팅" /><published>2022-08-16T00:00:00+09:00</published><updated>2022-08-16T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/08/16/socket</id><content type="html" xml:base="http://localhost:4000/javascript/2022/08/16/socket/"><![CDATA[<p>채팅과 관련된 기능들을 구현하면서 백엔드와의 협의 후 Sock.JS와 Stomp.JS를 사용하게 됐습니다. 이 두 가지를 사용하기에 앞서 두 가지가 어떠한 역할을 하는지, 왜 이것들을 써야하는지 간단하게 살펴보고 어떻게 사용하는 지 적어보고자 합니다.</p>

<h2 id="web-socket">Web Socket</h2>

<p>TCP 연결에 완전 이중 통신 채널을 제공하는 컴퓨터 프로토콜입니다. 일반적인 서버 - 클라이언트의 관계가 stateless인 것에 반해, Web Socket은 stateful한 방식을 사용해, 지속적인 연결이 이루어지게 됩니다.</p>

<p>서버 - 클라이언트간 웹소켓 연결은 HTTP 프로토콜을 통해 이루어지며, 연결의 시작은 클라이언트가 서버로 random key를 보냅니다. 이후 서버에서 random key를 통해 토큰을 만든 뒤, 클라이언트에 response를 보내고, 이를 통해 handshake 과정이 이루어져서 양방향 통신이 진행됩니다.</p>

<p>서버 - 클라이언트간 웹소켓 연결(TCP/IP)이 이루어지고 일정 시간이 지나면 HTTP 연결은 자동으로 끊어지게 됩니다.</p>

<h2 id="sockjs">SockJS</h2>

<p>(<a href="https://velog.io/@yyong3519/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%9B%B9%EC%86%8C%EC%BC%932">큰 도움을 주신 사이트</a>)</p>

<p>브라우저에서 web socket을 지원하지 않는 경우에도 web socket을 사용 가능하게 해주는 WebSocket Emulation으로서 사용되는 라이브러리입니다.</p>

<p>브라우저와 서버 사이의 짧은 지연시간, 크로스 브라우징의 지원이 장점입니다.</p>

<p>(현재 서버에서는 Spring을 사용하고 있어, Sock JS를 사용했으며, 서버에서 Node.js를 사용할 경우, Socket.io를 사용합니다.)</p>

<p>구성과 전송타입은 아래와 같고 추후에 아래 내용들을 자세히 정리할 예정입니다!</p>

<h3 id="구성">구성</h3>

<ul>
  <li>SockJS Protocol</li>
  <li>SockJS Javascript Client: 브라우저용 클라이언트 라이브러리</li>
  <li>SockJS Server: Spring-websocket 모듈로 제공</li>
  <li>SockJS Java Client: Spring-websocket 모듈로 제공</li>
</ul>

<h3 id="전송-타입">전송 타입</h3>

<ol>
  <li>WebSocket</li>
  <li>HTTP Streaming</li>
  <li>HTTP Long Polling</li>
</ol>

<h2 id="stompjs">StompJS</h2>

<p>(<a href="https://dev-gorany.tistory.com/m/235">추후 참고할 만한 링크</a>)</p>

<p>웹소켓의 서브 프로토콜로서, 프로토콜 연결, 메세지 전송, 상대방 구독 기능을 제공하는 텍스트 기반 메세지 프로토콜입니다. stomp를 이용하면 여러 개의 채팅방 개설이 가능하다는 장점이 있습니다.</p>

<p>서버가 Spring을 사용할 경우, 보통 SockJS, StompJS 이 두 가지를 통해 소켓 연결을 진행하게 됩니다.</p>

<h2 id="사용">사용</h2>

<h3 id="설치">설치</h3>

<p>아래 코드를 통해서 기본적인 sockjs, stompjs를 설치할 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install --save-dev sockjs-client stompjs
</code></pre></div></div>

<h3 id="sockjs-stompjs-연결">SockJS, StompJS 연결</h3>

<p>이후 주소를 설정하고 Sock을 새로 만든 뒤, 이를 Stomp Client 위에서 작동할 수 있도록 설정합니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">SockJs</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">sockjs-client</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">StompJs</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">stompjs</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 들어갈 주소 설정</span>
<span class="kd">const</span> <span class="nx">sockServer</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">REACT_APP_BASE_URL</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">WEBSOCKET</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJs</span><span class="p">(</span><span class="nx">sockServer</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="stomp-client로-서버에-연결-요청">Stomp Client로 서버에 연결 요청</h3>

<p>Stomp Client에 연결을 요청하고, 해당 요청이 성공적일 시 구독으로 진행할 작업을 적어줍니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">connectChatroom</span> <span class="o">=</span> <span class="p">(</span><span class="nx">subscribeParams</span><span class="p">:</span> <span class="nx">subscribeParamsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
  <span class="c1">// 현재 서버에서 확인을 위해 필요로 하는 헤더</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">// stompClient.debug = () =&gt; null;</span>
    <span class="c1">// console 창에 나오게 되는 내용들이 보이지 않도록 함</span>
    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="nx">headers</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">subscribeChat</span><span class="p">(</span><span class="nx">subscribeParams</span><span class="p">));</span>
    <span class="c1">// 연결을 시도함</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="원하는-주소로-구독-및-메세지-올-때-처리하기">원하는 주소로 구독 및 메세지 올 때 처리하기</h3>

<p><code class="language-plaintext highlighter-rouge">subscribeChat</code>이라는 함수를 따로 만들어, Stomp Client가 연결에 성공할 시 진행할 작업을 따로 빼내어 정리해주었습니다. <code class="language-plaintext highlighter-rouge">stompClient.connect</code>를 통해서 연결이 이루어지게 되는데, 이는 서버에 connect 프레임을 전송하는 것으로, 이 프레임에 <code class="language-plaintext highlighter-rouge">header</code>, <code class="language-plaintext highlighter-rouge">body</code>를 넣을 수 있고 현재는 <code class="language-plaintext highlighter-rouge">header</code>만 보낸 상황입니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">subscribeChat</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">onReceive</span><span class="p">,</span>
  <span class="nx">chatroomId</span><span class="p">,</span>
  <span class="nx">chatroomIds</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">subscribeParamsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">subscribeToStomp</span> <span class="o">=</span> <span class="p">(</span><span class="na">id</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">subscribeURL</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">TOPIC</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">CHATROOM_MEMBERS</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
    <span class="c1">// 서버와 협의된 구독 URL</span>
    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">subscribeURL</span><span class="p">,</span> <span class="nx">onReceive</span><span class="p">,</span> <span class="nx">headers</span><span class="p">);</span>
    <span class="c1">// Stomp Client에서 구독 후, 이후 메세지가 올 시 처리할 값을 onReceive 함수로 처리함</span>
  <span class="p">};</span>

  <span class="c1">// id값이 한 개일 때, 여러 개일 때를 구분해서 구독을 진행하도록 설정</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">chatroomId</span><span class="p">)</span> <span class="nx">subscribeToStomp</span><span class="p">(</span><span class="nx">chatroomId</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">chatroomIds</span><span class="p">)</span> <span class="nx">chatroomIds</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">id</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">subscribeToStomp</span><span class="p">(</span><span class="nx">id</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>현재 앱의 특성상 <code class="language-plaintext highlighter-rouge">id</code>값을 하나만 받는 경우(채팅 상세에 들어갈 시), <code class="language-plaintext highlighter-rouge">id</code>값을 여러 개 받는 경우(모든 채팅의 알림을 받을 시)에 대해 같은 형식의 처리가 이루어지기 때문에 아래와 같이 같은 함수 내에서 구분해 처리하도록 했습니다.</p>

<p><code class="language-plaintext highlighter-rouge">subscribeURL</code>을 통해서 구독할 주소를 설정하게 되고, 이후 그 주소를 통해 등록한 곳으로부터 메세지가 오면 onReceive 함수를 통해 처리를 할 수 있게 됩니다.</p>

<h3 id="구독-끊기">구독 끊기</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">unsubscribe</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">stompClient</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">(</span><span class="dl">"</span><span class="s2">sub-0</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">unsubscribe</code> 함수를 통해 구독을 끊을 수 있으며, 서버와의 연결 해제가 아닌 <strong>해당 주소에 대한 구독만 끊어내는</strong> 개념으로 볼 수 있습니다.</p>

<h3 id="연결-끊기">연결 끊기</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">disconnectChatroom</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="c1">// stompClient.debug = () =&gt; null;</span>
    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">unsubscribe</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">diconnect</code>를 통해서 서버와의 연결을 해제할 수 있으며, 이 때에도 콜백 함수를 통해 특정 작업을 진행할 수 있습니다.</p>

<hr />

<h2 id="추가적인-문제">추가적인 문제</h2>

<p>(위에 반영되었습니다.)</p>

<p>아래의 코드로 호출 시 하나의 구독 주소에 여러번 접근하는 형식이 적용되어, 문제가 발생합니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">useChatAlarm</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">contents</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useRecoilValueLoadable</span><span class="p">(</span><span class="nx">chatroomIdsState</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">state</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">hasValue</span><span class="dl">"</span> <span class="o">||</span> <span class="o">!</span><span class="nx">contents</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="nx">contents</span><span class="p">?.</span><span class="nx">forEach</span><span class="p">(({</span> <span class="nx">id</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">connectChatroom</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">chatSocket</span><span class="p">();</span>
        <span class="nx">connectChatroom</span><span class="p">({</span> <span class="na">chatroomId</span><span class="p">:</span> <span class="nx">id</span> <span class="p">});</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="p">[</span><span class="nx">state</span><span class="p">]);</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">subscribeChat</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">setter</span><span class="p">,</span> <span class="nx">chatroomId</span> <span class="p">}:</span> <span class="nx">subscribeParamsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">subscribeURL</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">TOPIC</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">CHATROOM_MEMBERS</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">chatroomId</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="c1">// 하나의 id만 등록이 가능함</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>

  <span class="c1">// 이 부분을 forEach로 반복하기 때문에, 같은 주소(subscribeURL)에 반복적인 요청이 들어가게 됨</span>
  <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span>
    <span class="nx">subscribeURL</span><span class="p">,</span>
    <span class="c1">// 콜백 함수가 직접적으로 들어가 있어, 다른 작업이 필요한 경우, 이 곳을 직접적으로 고쳐야 함</span>
    <span class="p">(</span><span class="nx">chatData</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newChat</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">chatData</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
      <span class="nx">setter</span><span class="p">((</span><span class="nx">chats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">newChats</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">chats</span><span class="p">,</span> <span class="nx">newChat</span><span class="p">];</span>
        <span class="k">return</span> <span class="nx">newChats</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">},</span>
    <span class="nx">headers</span>
  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/220816/error.png" alt="" width="100%" height="" /> 
</figure>

<p>사진과 같이 같은 주소에 대한 여러 번의 호출로 인해 연결이 끊겨버린다는 문제가 발생합니다.</p>

<h2 id="해결-방법">해결 방법</h2>

<h3 id="1-onset-함수-및-주소-분리">1. <code class="language-plaintext highlighter-rouge">onSet</code> 함수 및 주소 분리</h3>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">subscribeParamsType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">onSet</span><span class="p">:</span> <span class="p">(</span><span class="na">chatData</span><span class="p">:</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
  <span class="nl">chatroomId</span><span class="p">?:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">chatroomIds</span><span class="p">?:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">|</span> <span class="kr">number</span><span class="p">[];</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">subscribeChat</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">onSet</span><span class="p">,</span> <span class="nx">chatroomId</span><span class="p">,</span> <span class="nx">chatroomIds</span> <span class="p">}:</span> <span class="nx">subscribeParamsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">subscribeToStomp</span> <span class="o">=</span> <span class="p">(</span><span class="na">id</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">subscribeURL</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">TOPIC</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">CHATROOM_MEMBERS</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
		<span class="c1">// id 값에 따라 주소가 나뉠 수 있도록 공통 함수를 설정</span>
    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">subscribeURL</span><span class="p">,</span> <span class="nx">onSet</span><span class="p">,</span> <span class="nx">headers</span><span class="p">);</span>
		<span class="c1">// subscribe 내에서 콜백(onSet)을 만드는 것이 아니라 이를 분리해 외부에서 적용하도록</span>
  <span class="p">};</span>
	<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">chatroomId</code>의 개수가 늘어나는 경우에 대해서 이전 코드에서는 제대로 된 해결책이 없어 우선 이 사항부터 해결하기 위해 <code class="language-plaintext highlighter-rouge">onSet</code>이라는 set이 발생했을 때의 함수를 먼저 따로 빼냈습니다. 이로 인해 set이 발생했을 때의 사항에 대해서는 직접적으로 사용하는 곳에서 처리를 하도록 빼낼 수 있었고, 아래 코드와 같이 사용하는 곳에서 set 상황을 컨트롤 할 수 있게 됐습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getNewChatMessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">chatData</span><span class="p">:</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newChat</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">chatData</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
  <span class="nx">setCurChats</span><span class="p">((</span><span class="nx">chats</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newChats</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">chats</span><span class="p">,</span> <span class="nx">newChat</span><span class="p">];</span>

    <span class="k">return</span> <span class="nx">newChats</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">};</span>
<span class="c1">// onSet 함수로, 들어온 값에 대해 새로운 채팅에 추가하는 함수</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">disconnectChatroom</span><span class="p">,</span> <span class="nx">connectChatroom</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">chatroomSocket</span><span class="p">();</span>
  <span class="nx">connectChatroom</span><span class="p">({</span> <span class="na">onSet</span><span class="p">:</span> <span class="nx">getNewChatMessage</span><span class="p">,</span> <span class="nx">chatroomId</span> <span class="p">});</span>
  <span class="c1">// 연결할 때 함수를 대입</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">disconnectChatroom</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[]);</span>
</code></pre></div></div>

<h3 id="2-id-개수에-따른-상황-분리">2. id 개수에 따른 상황 분리</h3>

<p>id가 하나인 경우와 여러개인 경우에 대해서 구독하는 방식이 약간의 차이가 존재하는데, 이를 해결하기 위해 상황별로 구독하는 방법을 바꾸도록 설정해 문제를 해결했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">chatroomId</span><span class="p">)</span> <span class="nx">subscribeToStomp</span><span class="p">(</span><span class="nx">chatroomId</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">chatroomIds</span><span class="p">)</span> <span class="nx">chatroomIds</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">id</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">subscribeToStomp</span><span class="p">(</span><span class="nx">id</span><span class="p">));</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="JAVASCRIPT" /><summary type="html"><![CDATA[채팅과 관련된 기능들을 구현하면서 백엔드와의 협의 후 Sock.JS와 Stomp.JS를 사용하게 됐습니다. 이 두 가지를 사용하기에 앞서 두 가지가 어떠한 역할을 하는지, 왜 이것들을 써야하는지 간단하게 살펴보고 어떻게 사용하는 지 적어보고자 합니다. Web Socket TCP 연결에 완전 이중 통신 채널을 제공하는 컴퓨터 프로토콜입니다. 일반적인 서버 - 클라이언트의 관계가 stateless인 것에 반해, Web Socket은 stateful한 방식을 사용해, 지속적인 연결이 이루어지게 됩니다. 서버 - 클라이언트간 웹소켓 연결은 HTTP 프로토콜을 통해 이루어지며, 연결의 시작은 클라이언트가 서버로 random key를 보냅니다. 이후 서버에서 random key를 통해 토큰을 만든 뒤, 클라이언트에 response를 보내고, 이를 통해 handshake 과정이 이루어져서 양방향 통신이 진행됩니다. 서버 - 클라이언트간 웹소켓 연결(TCP/IP)이 이루어지고 일정 시간이 지나면 HTTP 연결은 자동으로 끊어지게 됩니다. SockJS (큰 도움을 주신 사이트) 브라우저에서 web socket을 지원하지 않는 경우에도 web socket을 사용 가능하게 해주는 WebSocket Emulation으로서 사용되는 라이브러리입니다. 브라우저와 서버 사이의 짧은 지연시간, 크로스 브라우징의 지원이 장점입니다. (현재 서버에서는 Spring을 사용하고 있어, Sock JS를 사용했으며, 서버에서 Node.js를 사용할 경우, Socket.io를 사용합니다.) 구성과 전송타입은 아래와 같고 추후에 아래 내용들을 자세히 정리할 예정입니다! 구성 SockJS Protocol SockJS Javascript Client: 브라우저용 클라이언트 라이브러리 SockJS Server: Spring-websocket 모듈로 제공 SockJS Java Client: Spring-websocket 모듈로 제공 전송 타입 WebSocket HTTP Streaming HTTP Long Polling StompJS (추후 참고할 만한 링크) 웹소켓의 서브 프로토콜로서, 프로토콜 연결, 메세지 전송, 상대방 구독 기능을 제공하는 텍스트 기반 메세지 프로토콜입니다. stomp를 이용하면 여러 개의 채팅방 개설이 가능하다는 장점이 있습니다. 서버가 Spring을 사용할 경우, 보통 SockJS, StompJS 이 두 가지를 통해 소켓 연결을 진행하게 됩니다. 사용 설치 아래 코드를 통해서 기본적인 sockjs, stompjs를 설치할 수 있습니다. npm install --save-dev sockjs-client stompjs SockJS, StompJS 연결 이후 주소를 설정하고 Sock을 새로 만든 뒤, 이를 Stomp Client 위에서 작동할 수 있도록 설정합니다. import SockJs from "sockjs-client"; import StompJs from "stompjs"; // 들어갈 주소 설정 const sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; const sock = new SockJs(sockServer); const stompClient = StompJs.over(sock); Stomp Client로 서버에 연결 요청 Stomp Client에 연결을 요청하고, 해당 요청이 성공적일 시 구독으로 진행할 작업을 적어줍니다. const connectChatroom = (subscribeParams: subscribeParamsType) =&gt; { const headers = getAuthHeaders(); // 현재 서버에서 확인을 위해 필요로 하는 헤더 try { // stompClient.debug = () =&gt; null; // console 창에 나오게 되는 내용들이 보이지 않도록 함 stompClient.connect(headers, () =&gt; subscribeChat(subscribeParams)); // 연결을 시도함 } catch (error) { console.log(error); } }; 원하는 주소로 구독 및 메세지 올 때 처리하기 subscribeChat이라는 함수를 따로 만들어, Stomp Client가 연결에 성공할 시 진행할 작업을 따로 빼내어 정리해주었습니다. stompClient.connect를 통해서 연결이 이루어지게 되는데, 이는 서버에 connect 프레임을 전송하는 것으로, 이 프레임에 header, body를 넣을 수 있고 현재는 header만 보낸 상황입니다. const subscribeChat = ({ onReceive, chatroomId, chatroomIds, }: subscribeParamsType) =&gt; { const headers = getAuthHeaders(); const subscribeToStomp = (id: string | number) =&gt; { const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`; // 서버와 협의된 구독 URL stompClient.subscribe(subscribeURL, onReceive, headers); // Stomp Client에서 구독 후, 이후 메세지가 올 시 처리할 값을 onReceive 함수로 처리함 }; // id값이 한 개일 때, 여러 개일 때를 구분해서 구독을 진행하도록 설정 if (chatroomId) subscribeToStomp(chatroomId); if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id)); }; 현재 앱의 특성상 id값을 하나만 받는 경우(채팅 상세에 들어갈 시), id값을 여러 개 받는 경우(모든 채팅의 알림을 받을 시)에 대해 같은 형식의 처리가 이루어지기 때문에 아래와 같이 같은 함수 내에서 구분해 처리하도록 했습니다. subscribeURL을 통해서 구독할 주소를 설정하게 되고, 이후 그 주소를 통해 등록한 곳으로부터 메세지가 오면 onReceive 함수를 통해 처리를 할 수 있게 됩니다. 구독 끊기 const unsubscribe = () =&gt; { stompClient.unsubscribe("sub-0"); }; unsubscribe 함수를 통해 구독을 끊을 수 있으며, 서버와의 연결 해제가 아닌 해당 주소에 대한 구독만 끊어내는 개념으로 볼 수 있습니다. 연결 끊기 const disconnectChatroom = () =&gt; { try { // stompClient.debug = () =&gt; null; stompClient.disconnect(() =&gt; unsubscribe()); } catch (error) { console.log(error); } }; diconnect를 통해서 서버와의 연결을 해제할 수 있으며, 이 때에도 콜백 함수를 통해 특정 작업을 진행할 수 있습니다. 추가적인 문제 (위에 반영되었습니다.) 아래의 코드로 호출 시 하나의 구독 주소에 여러번 접근하는 형식이 적용되어, 문제가 발생합니다. const useChatAlarm = () =&gt; { const { state, contents } = useRecoilValueLoadable(chatroomIdsState); return () =&gt; { useEffect(() =&gt; { if (state !== "hasValue" || !contents) return; contents?.forEach(({ id }) =&gt; { const { connectChatroom } = chatSocket(); connectChatroom({ chatroomId: id }); }); }, [state]); }; }; const subscribeChat = ({ setter, chatroomId }: subscribeParamsType) =&gt; { const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${chatroomId}`; // 하나의 id만 등록이 가능함 const headers = getAuthHeaders(); // 이 부분을 forEach로 반복하기 때문에, 같은 주소(subscribeURL)에 반복적인 요청이 들어가게 됨 stompClient.subscribe( subscribeURL, // 콜백 함수가 직접적으로 들어가 있어, 다른 작업이 필요한 경우, 이 곳을 직접적으로 고쳐야 함 (chatData) =&gt; { const newChat = JSON.parse(chatData.body); setter((chats) =&gt; { const newChats = [...chats, newChat]; return newChats; }); }, headers ); }; 사진과 같이 같은 주소에 대한 여러 번의 호출로 인해 연결이 끊겨버린다는 문제가 발생합니다. 해결 방법 1. onSet 함수 및 주소 분리 type subscribeParamsType = { onSet: (chatData: StompJs.Message) =&gt; void; chatroomId?: string | number; chatroomIds?: string[] | number[]; }; const subscribeChat = ({ onSet, chatroomId, chatroomIds }: subscribeParamsType) =&gt; { const subscribeToStomp = (id: string | number) =&gt; { const headers = getAuthHeaders(); const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`; // id 값에 따라 주소가 나뉠 수 있도록 공통 함수를 설정 stompClient.subscribe(subscribeURL, onSet, headers); // subscribe 내에서 콜백(onSet)을 만드는 것이 아니라 이를 분리해 외부에서 적용하도록 }; ... }; chatroomId의 개수가 늘어나는 경우에 대해서 이전 코드에서는 제대로 된 해결책이 없어 우선 이 사항부터 해결하기 위해 onSet이라는 set이 발생했을 때의 함수를 먼저 따로 빼냈습니다. 이로 인해 set이 발생했을 때의 사항에 대해서는 직접적으로 사용하는 곳에서 처리를 하도록 빼낼 수 있었고, 아래 코드와 같이 사용하는 곳에서 set 상황을 컨트롤 할 수 있게 됐습니다. const getNewChatMessage = (chatData: StompJs.Message) =&gt; { const newChat = JSON.parse(chatData.body); setCurChats((chats) =&gt; { const newChats = [...chats, newChat]; return newChats; }); }; // onSet 함수로, 들어온 값에 대해 새로운 채팅에 추가하는 함수 useEffect(() =&gt; { const { disconnectChatroom, connectChatroom } = chatroomSocket(); connectChatroom({ onSet: getNewChatMessage, chatroomId }); // 연결할 때 함수를 대입 return () =&gt; disconnectChatroom(); }, []); 2. id 개수에 따른 상황 분리 id가 하나인 경우와 여러개인 경우에 대해서 구독하는 방식이 약간의 차이가 존재하는데, 이를 해결하기 위해 상황별로 구독하는 방법을 바꾸도록 설정해 문제를 해결했습니다. if (chatroomId) subscribeToStomp(chatroomId); if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">DATA CONSTRUCTOR</title><link href="http://localhost:4000/dev/2022/01/10/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="DATA CONSTRUCTOR" /><published>2022-01-10T00:00:00+09:00</published><updated>2022-01-10T00:00:00+09:00</updated><id>http://localhost:4000/dev/2022/01/10/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/dev/2022/01/10/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"><![CDATA[<p>여기서는 간략하게 비선형 구조, 선형 구조로 나누어 살펴본다.<br />
추후에 더 자세한 정리가 이루어지면 링크를 걸어놓을 예정이다.</p>

<h1 id="1-비선형-구조">1. 비선형 구조</h1>

<p>하나의 데이터 안에 여러 개의 자료가 존재할 수 있는 것을 말한다.</p>

<h2 id="a-트리">A. 트리</h2>

<p>정점과 선분을 이용해 <strong>사이클을 이루지 않도록 구성</strong>한 그래프 형태로, 방향성이 존재해 부모 ∙ 자식 계층 구조가 명확하다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조.png" alt="" width="50%" height="" /> 
</figure>

<h2 id="b-그래프">B. 그래프</h2>

<p>정점, 선분을 이용해 <strong>사이클을 이루도록 구성</strong>한 것으로, 순환이 가능하다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 1.png" alt="" width="50%" height="" /> 
</figure>

<hr />

<h1 id="2-선형-구조">2. 선형 구조</h1>

<p>자료를 구성하는 데이터를 순차적으로 나열한 형태를 말한다.<br />
종류로는 배열(선형 리스트), 연결 리스트, 스택, 큐, 테크 등이 있다.<br />
포인터 등을 사용해 자료를 연결하면 그 결과가 일직선 상에 표시되거나 하나의 원상에 표시된다.</p>

<h2 id="a-배열-array">A. 배열 (Array)</h2>

<p>인덱스를 갖고 있으며, 순차적으로 데이터가 삽입, 삭제될 수 있는 구조이다.<br />
데이터의 순차적 삽입, 삭제 시 가장 효과적이다.<br />
<strong>인덱스를 사용해 검색이 빠르다</strong>는 장점이 있지만, <strong>중간 삽입 ∙ 삭제가 어렵다</strong>는 단점이 있다.</p>

<h2 id="b-연결리스트-linked-list"><a href="https://jinjeon.github.io/dev/2022/01/10/연결리스트/">B. 연결리스트 (Linked List)</a></h2>

<p>자료 항목 순서에 따라 노드의 포인터 부분을 이용해 서로 연결한 구조이다.<br />
 노드의 삽입, 삭제 작업이 용이하며, 기억 공간이 연속적으로 놓이지 않아도 저장이 가능하다.<br />
 <strong>중간 삽입 ∙ 삭제가 빠르고 용이하다</strong>는 장점이 있지만, <strong>접근 속도가 느리며 중간 노드 연결이 끊어질 시 다음 노드를 찾기 어렵다</strong>는 단점이 있다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 2.png" alt="" width="75%" height="" /> 
</figure>

<h2 id="c-스택-stack">C. 스택 (Stack)</h2>

<p>리스트의 한 쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 구조이다.<br />
Last In, First Out / 인터럽트가 발생하여 복귀주소를 저장할 때 사용한다.<br />
스택의 용도로 7가지가 있다.</p>

<ol>
  <li>부 프로그램 호출 시 복귀주소 저장</li>
  <li>함수 호출 순서 제어</li>
  <li>인터럽트가 발생해 복귀 주소 저장 시</li>
  <li>후위 표기법으로 표현된 산술식 연산</li>
  <li>0 주소 지정방식 명령어 자료 저장소</li>
  <li>재귀 프로그램 순서 제어</li>
  <li>컴파일러를 이용한 언어 번역</li>
</ol>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 3.png" alt="" width="60%" height="" /> 
</figure>

<h2 id="d-큐-queue">D. 큐 (Queue)</h2>

<p>한 쪽에서는 삽입, 다른 쪽에서는 삭제가 이루어지는 구조이다.<br />
시작과 끝을 표시하는 두 개의 포인터가 존재한다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 4.png" alt="" width="75%" height="" /> 
</figure>

<h2 id="e-데크-deq--double-ended-queue">E. 데크 (DEQ : Double Ended Queue)</h2>

<p>스택, 큐의 장점만을 갖고 만든 것으로, <strong>삽입과 삭제가 리스트 양쪽에서 모두 발생하는 구조</strong>이다.<br />
입력이 한쪽, 출력이 양쪽에서 일어나는 <strong>입력제한</strong>과 입력이 양쪽, 출력이 한쪽에서 일어나는 <strong>출력제한</strong>이 있다.</p>

<hr />

<h1 id="링크">링크</h1>

<ul>
  <li>데이터 구조 안내<br />
<a href="https://dnf-lover.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%84%A0%ED%98%95-%EB%B9%84%EC%84%A0%ED%98%95-%EB%B6%84%EB%A5%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B0%81-%EC%A2%85%EB%A5%98%EC%99%80-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%B3%84-%ED%8A%B9%EC%A7%95-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC">https://dnf-lover.tistory.com/entry/자료구조-자료구조의-선형-비선형-분류에-따른-각-종류와-자료구조별-특징-간단-정리</a><br />
<a href="https://server-engineer.tistory.com/130">https://server-engineer.tistory.com/130</a></li>
  <li>생활코딩 : 자료구조 안내<br />
<a href="https://opentutorials.org/module/1335/8821">https://opentutorials.org/module/1335/8821</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="DEV" /><summary type="html"><![CDATA[여기서는 간략하게 비선형 구조, 선형 구조로 나누어 살펴본다. 추후에 더 자세한 정리가 이루어지면 링크를 걸어놓을 예정이다. 1. 비선형 구조 하나의 데이터 안에 여러 개의 자료가 존재할 수 있는 것을 말한다. A. 트리 정점과 선분을 이용해 사이클을 이루지 않도록 구성한 그래프 형태로, 방향성이 존재해 부모 ∙ 자식 계층 구조가 명확하다. B. 그래프 정점, 선분을 이용해 사이클을 이루도록 구성한 것으로, 순환이 가능하다. 2. 선형 구조 자료를 구성하는 데이터를 순차적으로 나열한 형태를 말한다. 종류로는 배열(선형 리스트), 연결 리스트, 스택, 큐, 테크 등이 있다. 포인터 등을 사용해 자료를 연결하면 그 결과가 일직선 상에 표시되거나 하나의 원상에 표시된다. A. 배열 (Array) 인덱스를 갖고 있으며, 순차적으로 데이터가 삽입, 삭제될 수 있는 구조이다. 데이터의 순차적 삽입, 삭제 시 가장 효과적이다. 인덱스를 사용해 검색이 빠르다는 장점이 있지만, 중간 삽입 ∙ 삭제가 어렵다는 단점이 있다. B. 연결리스트 (Linked List) 자료 항목 순서에 따라 노드의 포인터 부분을 이용해 서로 연결한 구조이다. 노드의 삽입, 삭제 작업이 용이하며, 기억 공간이 연속적으로 놓이지 않아도 저장이 가능하다. 중간 삽입 ∙ 삭제가 빠르고 용이하다는 장점이 있지만, 접근 속도가 느리며 중간 노드 연결이 끊어질 시 다음 노드를 찾기 어렵다는 단점이 있다. C. 스택 (Stack) 리스트의 한 쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 구조이다. Last In, First Out / 인터럽트가 발생하여 복귀주소를 저장할 때 사용한다. 스택의 용도로 7가지가 있다. 부 프로그램 호출 시 복귀주소 저장 함수 호출 순서 제어 인터럽트가 발생해 복귀 주소 저장 시 후위 표기법으로 표현된 산술식 연산 0 주소 지정방식 명령어 자료 저장소 재귀 프로그램 순서 제어 컴파일러를 이용한 언어 번역 D. 큐 (Queue) 한 쪽에서는 삽입, 다른 쪽에서는 삭제가 이루어지는 구조이다. 시작과 끝을 표시하는 두 개의 포인터가 존재한다. E. 데크 (DEQ : Double Ended Queue) 스택, 큐의 장점만을 갖고 만든 것으로, 삽입과 삭제가 리스트 양쪽에서 모두 발생하는 구조이다. 입력이 한쪽, 출력이 양쪽에서 일어나는 입력제한과 입력이 양쪽, 출력이 한쪽에서 일어나는 출력제한이 있다. 링크 데이터 구조 안내 https://dnf-lover.tistory.com/entry/자료구조-자료구조의-선형-비선형-분류에-따른-각-종류와-자료구조별-특징-간단-정리 https://server-engineer.tistory.com/130 생활코딩 : 자료구조 안내 https://opentutorials.org/module/1335/8821]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">LINKED LIST</title><link href="http://localhost:4000/dev/2022/01/10/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="LINKED LIST" /><published>2022-01-10T00:00:00+09:00</published><updated>2022-01-10T00:00:00+09:00</updated><id>http://localhost:4000/dev/2022/01/10/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/dev/2022/01/10/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/"><![CDATA[<h1 id="1-배열과-연결리스트의-장단점-비교">1. 배열과 연결리스트의 장단점 비교</h1>

<h2 id="1-1-배열">1-1. 배열</h2>

<ul>
  <li>장점 : 랜덤 엑세스가 빠르다.</li>
  <li>단점 : 메모리 사용이 비효율적이다. 배열 내 데이터 이동 및 재구성이 어렵다.</li>
</ul>

<h2 id="1-2-연결리스트">1-2. 연결리스트</h2>

<ul>
  <li>장점 : 동적 메모리 사용이 가능하다. 메모리 사용이 효율적이다. 대용량 데이터 처리에 적합하다.</li>
  <li>단점 : 특정 위치 데이터 검색 시 느리다. 메모리의 추가적인 사용이 필요하다.</li>
</ul>

<hr />

<h1 id="2-노드">2. 노드</h1>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 5.png" alt="" width="50%" height="" /> 
</figure>

<p>연결리스트는 ‘노드’라는 객체로 이루어져 있다.<br />
노드는 저장할 공간과 다음 주소를 가리킬 공간으로 나뉘게 된다.<br />
입력 정보를 위의 <code class="language-plaintext highlighter-rouge">DATA</code> 영역에 담고 노드가 추가될 때 <code class="language-plaintext highlighter-rouge">NEXT ADDRESS</code>를 이용해 다음 노드와 연결하게 된다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 6.png" alt="" width="75%" height="" /> 
</figure>

<p>각 노드는 연속된 공간이 아닌 <strong>메모리의 여러 부분에 분포</strong>되어 있다.<br />
노드마다 <strong>NEXT ADDRESS를 저장</strong>해 다음 노드로 갈 수 있다.<br />
<strong>마지막 노드는 다음 주소가 NULL</strong>로 표시된다.</p>

<hr />

<h1 id="3-연결리스트-구현">3. 연결리스트 구현</h1>

<p>‘초기화(init)’, ‘삽입(insert)’, ‘삭제(remove)’를 진행할 수 있는 함수가 필요하다.</p>

<h2 id="3-1-초기화">3-1. 초기화</h2>

<p>처음에 노드를 생성하는 과정을 말한다.<br />
노드에 접근하기 위해서 맨 처음 노드 주소를 가리킬 노드가 필요하다.(HEAD)</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 7.png" alt="" width="50%" height="" /> 
</figure>

<h2 id="3-2-삽입">3-2. 삽입</h2>

<h3 id="a-앞에-삽입하는-경우">A. 앞에 삽입하는 경우</h3>

<p>HEAD의 뒤에서 처리가 이루어지게 된다.
<strong>’새로운 노드의 NEXT → 현재 HEAD의 NEXT’<br />
’HEAD의 NEXT → 새로운 노드의 DATA’</strong><br />
의 형태로 이루어지게 되며 아래의 그림과 같은 방식이 된다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 8.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="b-뒤에-삽입하는-경우">B. 뒤에 삽입하는 경우</h3>

<p>앞의 과정과 반대로, HEAD대신 TAIL을 사용한다.<br />
<strong>’새로운 노드의 NEXT → NULL’,<br />
’TAIL의 NEXT의 NEXT’ → ‘새로운 노드의 DATA’,
’TAIL의 NEXT → 새로운 노드의 DATA’</strong><br />
의 형태로 이루어지며, 아래의 그림과 같이 된다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 9.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="c-원하는-위치에-삽입하는-경우">C. 원하는 위치에 삽입하는 경우</h3>

<p>특정 위치에 삽입할 경우(여기서는 FIRST와 SECOND사이), 삽입할 위치를 찾는 노드(LOCATION)가 먼저 필요하다.<br />
이전에는 HEAD, TAIL과 같은 위치가 있는 노드가 있었지만, 지금은 없는 경우이므로 직접적인 설정이 필요하다.<br />
<strong>’LOCATION의 NEXT → FIRST의 DATA’,<br />
’새로운 노드의 NEXT → SECOND의 DATA’,<br />
’FIRST의 NEXT → 새로운 노드의 DATA’</strong><br />
의 형태로 이루어진다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 10.png" alt="" width="100%" height="" /> 
</figure>

<h2 id="3-3-삭제">3-3. 삭제</h2>

<p>원하는 위치에 삽입하는 경우와 비슷하다.<br />
그러나, 삭제할 노드(DELETE)의 전 ∙ 후를 연결해야 하기에 새로운 노드(PRE)가 필요하다.<br />
<strong>’LOCATION의 NEXT → DELETE의 DATA’,<br />
’PRE의 NEXT의 NEXT → DELETE의 NEXT’,<br />
’DELETE를 삭제’</strong><br />
의 순서로 이루어지며 아래 그림의 형태와 같다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/220110/자료구조 11.png" alt="" width="50%" height="" /> 
</figure>

<hr />

<h1 id="링크">링크</h1>

<ul>
  <li>연결리스트 안내<br />
<a href="https://sycho-lego.tistory.com/17">https://sycho-lego.tistory.com/17</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="DEV" /><summary type="html"><![CDATA[1. 배열과 연결리스트의 장단점 비교 1-1. 배열 장점 : 랜덤 엑세스가 빠르다. 단점 : 메모리 사용이 비효율적이다. 배열 내 데이터 이동 및 재구성이 어렵다. 1-2. 연결리스트 장점 : 동적 메모리 사용이 가능하다. 메모리 사용이 효율적이다. 대용량 데이터 처리에 적합하다. 단점 : 특정 위치 데이터 검색 시 느리다. 메모리의 추가적인 사용이 필요하다. 2. 노드 연결리스트는 ‘노드’라는 객체로 이루어져 있다. 노드는 저장할 공간과 다음 주소를 가리킬 공간으로 나뉘게 된다. 입력 정보를 위의 DATA 영역에 담고 노드가 추가될 때 NEXT ADDRESS를 이용해 다음 노드와 연결하게 된다. 각 노드는 연속된 공간이 아닌 메모리의 여러 부분에 분포되어 있다. 노드마다 NEXT ADDRESS를 저장해 다음 노드로 갈 수 있다. 마지막 노드는 다음 주소가 NULL로 표시된다. 3. 연결리스트 구현 ‘초기화(init)’, ‘삽입(insert)’, ‘삭제(remove)’를 진행할 수 있는 함수가 필요하다. 3-1. 초기화 처음에 노드를 생성하는 과정을 말한다. 노드에 접근하기 위해서 맨 처음 노드 주소를 가리킬 노드가 필요하다.(HEAD) 3-2. 삽입 A. 앞에 삽입하는 경우 HEAD의 뒤에서 처리가 이루어지게 된다. ’새로운 노드의 NEXT → 현재 HEAD의 NEXT’ ’HEAD의 NEXT → 새로운 노드의 DATA’ 의 형태로 이루어지게 되며 아래의 그림과 같은 방식이 된다. B. 뒤에 삽입하는 경우 앞의 과정과 반대로, HEAD대신 TAIL을 사용한다. ’새로운 노드의 NEXT → NULL’, ’TAIL의 NEXT의 NEXT’ → ‘새로운 노드의 DATA’, ’TAIL의 NEXT → 새로운 노드의 DATA’ 의 형태로 이루어지며, 아래의 그림과 같이 된다. C. 원하는 위치에 삽입하는 경우 특정 위치에 삽입할 경우(여기서는 FIRST와 SECOND사이), 삽입할 위치를 찾는 노드(LOCATION)가 먼저 필요하다. 이전에는 HEAD, TAIL과 같은 위치가 있는 노드가 있었지만, 지금은 없는 경우이므로 직접적인 설정이 필요하다. ’LOCATION의 NEXT → FIRST의 DATA’, ’새로운 노드의 NEXT → SECOND의 DATA’, ’FIRST의 NEXT → 새로운 노드의 DATA’ 의 형태로 이루어진다. 3-3. 삭제 원하는 위치에 삽입하는 경우와 비슷하다. 그러나, 삭제할 노드(DELETE)의 전 ∙ 후를 연결해야 하기에 새로운 노드(PRE)가 필요하다. ’LOCATION의 NEXT → DELETE의 DATA’, ’PRE의 NEXT의 NEXT → DELETE의 NEXT’, ’DELETE를 삭제’ 의 순서로 이루어지며 아래 그림의 형태와 같다. 링크 연결리스트 안내 https://sycho-lego.tistory.com/17]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Shell Script</title><link href="http://localhost:4000/dev/2022/01/09/%EC%89%98/" rel="alternate" type="text/html" title="Shell Script" /><published>2022-01-09T00:00:00+09:00</published><updated>2022-01-09T00:00:00+09:00</updated><id>http://localhost:4000/dev/2022/01/09/%EC%89%98</id><content type="html" xml:base="http://localhost:4000/dev/2022/01/09/%EC%89%98/"><![CDATA[<h1 id="shell">Shell</h1>

<blockquote>
  <p>OS와 대화하는 프로그램으로, 여러 종류가 있으며 그 예시로 ‘bash, zsh’가 있다.</p>
</blockquote>

<h2 id="1-shell-script">1. Shell Script?</h2>

<p>Shell의 종류는 Bourne Shell, Bash, ksh, zsh가 있다.<br />
Bash는 Bourne-Agin Shell의 약자로 명령형 편집 기능을 제공하며 리눅스에서 가장 많이 사용된다.<br />
zsh는 z셸 스크립을 위한 명령 인터프리터이다.<br />
Shell Script(sh file)를 사용하게 되며, 이는 txt 형식으로 저장되는 프로그램으로, shell이 실행할 수 있는 명령들의 집합이라고 볼 수 있다.<br />
자동화 작업들을 shell script로 만들어 편리한 사용이 가능하다.</p>

<h2 id="2-shell-script-파일-생성-작성-실행">2. Shell Script 파일 생성, 작성, 실행</h2>

<ul>
  <li>생성 : <code class="language-plaintext highlighter-rouge">vi (filename).sh</code>을 입력해 파일을 생성할 수 있으며, 이 곳에서 shell script를 작성하게 된다.</li>
  <li>입력 : <code class="language-plaintext highlighter-rouge">i</code>키를 누르면 입력이 가능한 상태가 되며, 한 줄 씩 작성을 진행하면 된다.</li>
  <li>저장 : <code class="language-plaintext highlighter-rouge">esc</code>키를 누른 뒤, <code class="language-plaintext highlighter-rouge">:wq</code>키를 입력해 나오면 된다.</li>
  <li>실행 : <code class="language-plaintext highlighter-rouge">sh (filename).sh</code>를 입력하면 저장된 내용이 실행된다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
echo "HIHIHI!"
pwd
ls
</code></pre></div></div>

<p>위와 같이 작성을 한 뒤, 실행하면 아래의 사진과 같은 결과가 나온다.<br />
입력값 불러오기(<code class="language-plaintext highlighter-rouge">echo</code>), 현재 위치 경로 출력(<code class="language-plaintext highlighter-rouge">pwd</code>), 현재 위치 디렉토리 파일 출력(<code class="language-plaintext highlighter-rouge">ls</code>)의 순서대로 나온 것을 볼 수 있다.</p>

<p><img src="/image/220109/12.png" alt="drawing" width="100%" /></p>

<h2 id="3-shell-script내-간단한-문법들">3. Shell Script내 간단한 문법들</h2>

<h3 id="3-1-반복문---for">3-1. 반복문 - for</h3>

<p>기본적으로 사용하는 반복문으로 for가 있다. <code class="language-plaintext highlighter-rouge">for in - do - done</code>의 형태로 이루어지며, 코드로 보면 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>file <span class="k">in</span> <span class="nv">$files</span>
<span class="k">do
	</span><span class="nv">filename</span><span class="o">=</span><span class="sb">`</span><span class="nb">basename</span> <span class="nv">$file</span><span class="sb">`</span>
<span class="k">done</span>
</code></pre></div></div>

<p>변수로 지정해준 $files내의 각 요소들을 변수명 file로 지정해주었고, do - done 사이에 이와 관련된 내용들을 작성해주면 된다.</p>

<h3 id="3-2-파일-디렉토리-찾기---find">3-2. 파일, 디렉토리 찾기 - find</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"DAY*"</span>

find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"DAY*"</span> <span class="nt">-type</span> d
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"DAY*"</span> <span class="nt">-type</span> f
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">‘.’</code>은 현재 디렉토리 내의 모든 파일, <code class="language-plaintext highlighter-rouge">-name</code>은 이름으로 찾는 것, <code class="language-plaintext highlighter-rouge">“DAY*”</code>는 DAY라는 형식으로 이루어진 모든 파일임을 말한다.<br />
<code class="language-plaintext highlighter-rouge">-type d</code>는 디렉토리로, <code class="language-plaintext highlighter-rouge">-type f</code>는 파일로 찾는다는 것을 말한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-empty</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-empty</code>를 이용해 빈 파일을 찾는 데에 사용할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-size</span> +100M
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-size</code>를 이용해 특정 크기 이상, 이하의 파일을 찾는 데에 사용할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s2">"DAY*"</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-exec</code>를 이용해 부가적인 작업의 수행이 가능하다.<br />
검색된 파일이 <code class="language-plaintext highlighter-rouge">{}</code> 위치에 들어오게 되고, 추가적인 작업을 이어나가면 된다.</p>

<h3 id="3-3-디렉토리-생성--삭제">3-3. 디렉토리 생성 ∙ 삭제</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>ABC
<span class="nb">rm</span> <span class="nt">-rf</span> ABC
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mkdir</code>를 이용해 뒤에 나오는 단어의 이름으로 디렉토리를 생성할 수 있다.<br />
<code class="language-plaintext highlighter-rouge">rm</code>을 이용해 파일 및 디렉토리의 삭제가 가능하다. 단, 디렉토리의 삭제를 위해서는 <code class="language-plaintext highlighter-rouge">-r</code>이라는 옵션이 들어가야하고, <code class="language-plaintext highlighter-rouge">-f</code>라는 옵션을 함께 사용하면, 경고 없이 <strong>모두 강제로 삭제된다.</strong></p>

<h3 id="3-4-경로에서-파일명-가져오기">3-4. 경로에서 파일명 가져오기</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dirname</span><span class="o">=</span><span class="sb">`</span><span class="nb">basename</span> <span class="nv">$dir</span><span class="sb">`</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">basename</code>을 이용하면 특정 경로를 나타내는 값들의 마지막 부분,<br />
예를 들면, <code class="language-plaintext highlighter-rouge">home/ABC/backup/test.txt</code>와 같은 상황에서 <code class="language-plaintext highlighter-rouge">test.txt</code>만 나오도록 할 수 있다.<br />
위 코드의 경우, ` dirname=```의 형태를 갖고 있는데, 이렇게 할 경우,  <code class="language-plaintext highlighter-rouge">dirname</code>이라는 변수가 만들어지고, <code class="language-plaintext highlighter-rouge">$dirname</code>로 활용할 수 있다.</p>

<h3 id="3-5-문자열-일부-가져오기">3-5. 문자열 일부 가져오기</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">dirnum</span><span class="o">=</span><span class="k">${</span><span class="nv">dirname</span>:3<span class="k">}</span>

<span class="c"># dirname : "HELLO WORLD"</span>
<span class="c"># dirnum : LO WORLD</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">dirname</code>의 값으로 나오는 문자열 중, 네 번째<code class="language-plaintext highlighter-rouge">(3+1)</code>의 값부터 문자열을 잘라 표현해준다. 즉, 뒤에 나오는 숫자에 맞는 순서의 문자부터 그 뒤의 값들을 보여준다.</p>

<h3 id="3-6-조건문-사용하기---if">3-6. 조건문 사용하기 - if</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="nv">$filename</span> <span class="o">]</span>
<span class="k">then</span>
  ...
<span class="k">else</span>
	...
<span class="k">fi</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">if</code> 의 내부에 값이 true일 경우, <code class="language-plaintext highlighter-rouge">then</code>의 다음에 오는 과정들을 처리하고, 아닐경우 <code class="language-plaintext highlighter-rouge">else</code>의 뒤에 오는 과정들을 처리한다. 이 과정을 <code class="language-plaintext highlighter-rouge">fi</code>가 나올 때까지 진행한다.<br />
조건문의 여러 상황에 대해 정리된 <a href="https://hand-over.tistory.com/32">자료 링크</a>가 있어 아래에 추가적으로 적는다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># if 여러 상황에 대해서</span>
<span class="o">[</span> <span class="nt">-z</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 문자열의 길이가 0이면 TRUE
<span class="o">[</span> <span class="nt">-n</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 문자열의 길이가 0이 아니면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-eq</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A와 B값이 같으면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-ne</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A와 B값이 다르면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-gt</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A가 B보다 크면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-ge</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A가 B보다 크거나 같으면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-lt</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A가 B보다 작으면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-le</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A가 B보다 작거나 같으면 TRUE

<span class="o">[</span> 조건식A <span class="nt">-a</span> 조건식B <span class="o">]</span> : 조건식 A와 B가 모두 TRUE이면 TRUE <span class="o">(&amp;&amp;</span> 와 동일<span class="o">)</span>
<span class="o">[</span> 조건식A <span class="nt">-o</span> 조건식B <span class="o">]</span> : 조건식 A가 TRUE거나 조건식B가 TRUE면 TRUE <span class="o">(||</span> 와 동일<span class="o">)</span>

파일관련
<span class="o">[</span> <span class="nt">-d</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 디렉토리면 TRUE
<span class="o">[</span> <span class="nt">-e</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이<span class="o">(</span>노드, 디렉토리, 소켓 등등 모두<span class="o">)</span> 존재하면 TRUE
<span class="o">[</span> <span class="nt">-L</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 심볼릭 링크면 TRUE
<span class="o">[</span> <span class="nt">-r</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 읽기 가능하면 TRUE
<span class="o">[</span> <span class="nt">-s</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일의 크기가 0 보다 크면 TRUE
<span class="o">[</span> <span class="nt">-w</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 쓰기 가능하면 TRUE
<span class="o">[</span> <span class="nt">-x</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 실행 가능하면 TRUE
<span class="o">[</span> <span class="nt">-c</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 Special character file 이면 TRUE
<span class="o">[</span> <span class="nt">-f</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 디렉토리가 아닌 일반 regular 파일이면 TRUE
<span class="o">[</span> <span class="nt">-S</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="o">]</span> : A 파일이 소켓이면 TRUE
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-nt</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A 파일 B 파일보다 최신파일이면 참
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-ot</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span>  : A 파일이 B 파일보다 이전파일이면 참
<span class="o">[</span> <span class="k">${</span><span class="nv">A</span><span class="k">}</span> <span class="nt">-ef</span> <span class="k">${</span><span class="nv">B</span><span class="k">}</span> <span class="o">]</span> : A 파일과 B 파일이 같은 파일이면 참
</code></pre></div></div>

<h3 id="3-7-결과값-표시---echo">3-7. 결과값 표시 - echo</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>text or 변수명
</code></pre></div></div>

<p>적혀진 텍스트, 혹은 변수의 값을 표현해준다.<br />
JavaScript의 <code class="language-plaintext highlighter-rouge">console.log</code>와 같은 역할을 한다고 볼 수 있어, Shell Script 사용 시 사용자에게 보여주어야 할 메세지가 있을 때에도 사용할 수 있다.</p>

<h3 id="3-8-시간-구하기---date">3-8. 시간 구하기 - date</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">date

</span><span class="nv">day</span><span class="o">=</span><span class="sb">`</span><span class="nb">date</span> +%Y%m%d<span class="sb">`</span>
</code></pre></div></div>

<p>date라고 작성할 시 <code class="language-plaintext highlighter-rouge">2022년 1월 10일 월요일 01시 51분 38초 KST</code> 와 같이 결과값이 나오게 된다.<br />
위의 코드같은 경우, 결과 값으로 20220110가 나오게 되며, 이를 활용해 다양한 날짜의 표현이 가능하다. <a href="https://iamfreeman.tistory.com/entry/리눅스-date-명령어를-이용한-시간-확인-및-설정하기">세세한 여러 표현 방법을 알려주는 링크</a>를 참고하면 좋을 듯 하다.</p>

<h3 id="3-9-파일-압축하기---zip">3-9. 파일 압축하기 - zip</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip BACKUP_<span class="nv">$day</span>.zip ./BEFORE_ZIP

zip AAA.zip <span class="nt">-r</span> ./<span class="k">*</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">zip “파일이름” “압축할 디렉토리”</code> 의 순서로 작성하면 된다.<br />
두 번째와 같이 <code class="language-plaintext highlighter-rouge">-r</code>을 작성하면 현재폴더의 모든 것 및 하위 폴더들도 모두 압축하게 된다.</p>

<h3 id="3-10-다른-서버로의-파일-전송---scp">3-10. 다른 서버로의 파일 전송 - scp</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로컬에서 원격</span>
scp <span class="o">[</span>전송할 파일 경로] <span class="o">[</span>유저명]@[IP주소]:[받을 경로]

<span class="c"># 원격에서 로컬</span>
scp <span class="o">[</span>유저명]@[IP주소]:[전송할 파일 경로] <span class="o">[</span>받을 경로]

<span class="c"># 원격에서 원격</span>
scp <span class="o">[</span>유저명]@[IP주소]:[전송할 파일 경로] <span class="o">[</span>유저명]@[IP주소]:[받을 경로]
</code></pre></div></div>

<p>scp ./BACKUP_$day.zip $ubuntuserver:backup와 같이 작성하면, 내 서버내의 특정 파일을 다른 원격으로 보내는 경우로, 첫 번째 예시의 사례와 같다.</p>

<hr />

<h1 id="링크">링크</h1>

<ul>
  <li>쉘 스크립트 생성<br />
<a href="https://jaynamm.tistory.com/entry/Shell-Script-Shell-Script-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8B%A4%ED%96%89">https://jaynamm.tistory.com/entry/Shell-Script-Shell-Script-생성-및-실행</a><br />
<a href="https://rrecoder.tistory.com/62">https://rrecoder.tistory.com/62</a></li>
  <li>쉘 스크립트 scp 간단 사용법<br />
<a href="https://doheejin.github.io/linux/2021/03/03/linux-scp.html">https://doheejin.github.io/linux/2021/03/03/linux-scp.html</a></li>
  <li>터미널 디렉토리, 파일 삭제 방법<br />
<a href="https://www.delftstack.com/ko/howto/linux/how-to-delete-files-and-directories-in-linux-terminal/">https://www.delftstack.com/ko/howto/linux/how-to-delete-files-and-directories-in-linux-terminal/</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="DEV" /><summary type="html"><![CDATA[Shell OS와 대화하는 프로그램으로, 여러 종류가 있으며 그 예시로 ‘bash, zsh’가 있다. 1. Shell Script? Shell의 종류는 Bourne Shell, Bash, ksh, zsh가 있다. Bash는 Bourne-Agin Shell의 약자로 명령형 편집 기능을 제공하며 리눅스에서 가장 많이 사용된다. zsh는 z셸 스크립을 위한 명령 인터프리터이다. Shell Script(sh file)를 사용하게 되며, 이는 txt 형식으로 저장되는 프로그램으로, shell이 실행할 수 있는 명령들의 집합이라고 볼 수 있다. 자동화 작업들을 shell script로 만들어 편리한 사용이 가능하다. 2. Shell Script 파일 생성, 작성, 실행 생성 : vi (filename).sh을 입력해 파일을 생성할 수 있으며, 이 곳에서 shell script를 작성하게 된다. 입력 : i키를 누르면 입력이 가능한 상태가 되며, 한 줄 씩 작성을 진행하면 된다. 저장 : esc키를 누른 뒤, :wq키를 입력해 나오면 된다. 실행 : sh (filename).sh를 입력하면 저장된 내용이 실행된다. #!/bin/bash echo "HIHIHI!" pwd ls 위와 같이 작성을 한 뒤, 실행하면 아래의 사진과 같은 결과가 나온다. 입력값 불러오기(echo), 현재 위치 경로 출력(pwd), 현재 위치 디렉토리 파일 출력(ls)의 순서대로 나온 것을 볼 수 있다. 3. Shell Script내 간단한 문법들 3-1. 반복문 - for 기본적으로 사용하는 반복문으로 for가 있다. for in - do - done의 형태로 이루어지며, 코드로 보면 다음과 같다. for file in $files do filename=`basename $file` done 변수로 지정해준 $files내의 각 요소들을 변수명 file로 지정해주었고, do - done 사이에 이와 관련된 내용들을 작성해주면 된다. 3-2. 파일, 디렉토리 찾기 - find find . -name "DAY*" find . -name "DAY*" -type d find . -name "DAY*" -type f ‘.’은 현재 디렉토리 내의 모든 파일, -name은 이름으로 찾는 것, “DAY*”는 DAY라는 형식으로 이루어진 모든 파일임을 말한다. -type d는 디렉토리로, -type f는 파일로 찾는다는 것을 말한다. find . -empty -empty를 이용해 빈 파일을 찾는 데에 사용할 수 있다. find . -size +100M -size를 이용해 특정 크기 이상, 이하의 파일을 찾는 데에 사용할 수 있다. find . -name "DAY*" -exec ls -l {} \; -exec를 이용해 부가적인 작업의 수행이 가능하다. 검색된 파일이 {} 위치에 들어오게 되고, 추가적인 작업을 이어나가면 된다. 3-3. 디렉토리 생성 ∙ 삭제 mkdir ABC rm -rf ABC mkdir를 이용해 뒤에 나오는 단어의 이름으로 디렉토리를 생성할 수 있다. rm을 이용해 파일 및 디렉토리의 삭제가 가능하다. 단, 디렉토리의 삭제를 위해서는 -r이라는 옵션이 들어가야하고, -f라는 옵션을 함께 사용하면, 경고 없이 모두 강제로 삭제된다. 3-4. 경로에서 파일명 가져오기 dirname=`basename $dir` basename을 이용하면 특정 경로를 나타내는 값들의 마지막 부분, 예를 들면, home/ABC/backup/test.txt와 같은 상황에서 test.txt만 나오도록 할 수 있다. 위 코드의 경우, ` dirname=```의 형태를 갖고 있는데, 이렇게 할 경우, dirname이라는 변수가 만들어지고, $dirname로 활용할 수 있다. 3-5. 문자열 일부 가져오기 dirnum=${dirname:3} # dirname : "HELLO WORLD" # dirnum : LO WORLD dirname의 값으로 나오는 문자열 중, 네 번째(3+1)의 값부터 문자열을 잘라 표현해준다. 즉, 뒤에 나오는 숫자에 맞는 순서의 문자부터 그 뒤의 값들을 보여준다. 3-6. 조건문 사용하기 - if if [ -f $filename ] then ... else ... fi if 의 내부에 값이 true일 경우, then의 다음에 오는 과정들을 처리하고, 아닐경우 else의 뒤에 오는 과정들을 처리한다. 이 과정을 fi가 나올 때까지 진행한다. 조건문의 여러 상황에 대해 정리된 자료 링크가 있어 아래에 추가적으로 적는다. # if 여러 상황에 대해서 [ -z ${A} ] : A 문자열의 길이가 0이면 TRUE [ -n ${A} ] : A 문자열의 길이가 0이 아니면 TRUE [ ${A} -eq ${B} ] : A와 B값이 같으면 TRUE [ ${A} -ne ${B} ] : A와 B값이 다르면 TRUE [ ${A} -gt ${B} ] : A가 B보다 크면 TRUE [ ${A} -ge ${B} ] : A가 B보다 크거나 같으면 TRUE [ ${A} -lt ${B} ] : A가 B보다 작으면 TRUE [ ${A} -le ${B} ] : A가 B보다 작거나 같으면 TRUE [ 조건식A -a 조건식B ] : 조건식 A와 B가 모두 TRUE이면 TRUE (&amp;&amp; 와 동일) [ 조건식A -o 조건식B ] : 조건식 A가 TRUE거나 조건식B가 TRUE면 TRUE (|| 와 동일) 파일관련 [ -d ${A} ] : A 파일이 디렉토리면 TRUE [ -e ${A} ] : A 파일이(노드, 디렉토리, 소켓 등등 모두) 존재하면 TRUE [ -L ${A} ] : A 파일이 심볼릭 링크면 TRUE [ -r ${A} ] : A 파일이 읽기 가능하면 TRUE [ -s ${A} ] : A 파일의 크기가 0 보다 크면 TRUE [ -w ${A} ] : A 파일이 쓰기 가능하면 TRUE [ -x ${A} ] : A 파일이 실행 가능하면 TRUE [ -c ${A} ] : A 파일이 Special character file 이면 TRUE [ -f ${A} ] : A 파일이 디렉토리가 아닌 일반 regular 파일이면 TRUE [ -S ${A} ] : A 파일이 소켓이면 TRUE [ ${A} -nt ${B} ] : A 파일 B 파일보다 최신파일이면 참 [ ${A} -ot ${B} ] : A 파일이 B 파일보다 이전파일이면 참 [ ${A} -ef ${B} ] : A 파일과 B 파일이 같은 파일이면 참 3-7. 결과값 표시 - echo echo text or 변수명 적혀진 텍스트, 혹은 변수의 값을 표현해준다. JavaScript의 console.log와 같은 역할을 한다고 볼 수 있어, Shell Script 사용 시 사용자에게 보여주어야 할 메세지가 있을 때에도 사용할 수 있다. 3-8. 시간 구하기 - date date day=`date +%Y%m%d` date라고 작성할 시 2022년 1월 10일 월요일 01시 51분 38초 KST 와 같이 결과값이 나오게 된다. 위의 코드같은 경우, 결과 값으로 20220110가 나오게 되며, 이를 활용해 다양한 날짜의 표현이 가능하다. 세세한 여러 표현 방법을 알려주는 링크를 참고하면 좋을 듯 하다. 3-9. 파일 압축하기 - zip zip BACKUP_$day.zip ./BEFORE_ZIP zip AAA.zip -r ./* zip “파일이름” “압축할 디렉토리” 의 순서로 작성하면 된다. 두 번째와 같이 -r을 작성하면 현재폴더의 모든 것 및 하위 폴더들도 모두 압축하게 된다. 3-10. 다른 서버로의 파일 전송 - scp # 로컬에서 원격 scp [전송할 파일 경로] [유저명]@[IP주소]:[받을 경로] # 원격에서 로컬 scp [유저명]@[IP주소]:[전송할 파일 경로] [받을 경로] # 원격에서 원격 scp [유저명]@[IP주소]:[전송할 파일 경로] [유저명]@[IP주소]:[받을 경로] scp ./BACKUP_$day.zip $ubuntuserver:backup와 같이 작성하면, 내 서버내의 특정 파일을 다른 원격으로 보내는 경우로, 첫 번째 예시의 사례와 같다. 링크 쉘 스크립트 생성 https://jaynamm.tistory.com/entry/Shell-Script-Shell-Script-생성-및-실행 https://rrecoder.tistory.com/62 쉘 스크립트 scp 간단 사용법 https://doheejin.github.io/linux/2021/03/03/linux-scp.html 터미널 디렉토리, 파일 삭제 방법 https://www.delftstack.com/ko/howto/linux/how-to-delete-files-and-directories-in-linux-terminal/]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Linux, Ubuntu, SSH</title><link href="http://localhost:4000/dev/2022/01/06/%EB%A6%AC%EB%88%85%EC%8A%A4/" rel="alternate" type="text/html" title="Linux, Ubuntu, SSH" /><published>2022-01-06T00:00:00+09:00</published><updated>2022-01-06T00:00:00+09:00</updated><id>http://localhost:4000/dev/2022/01/06/%EB%A6%AC%EB%88%85%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/dev/2022/01/06/%EB%A6%AC%EB%88%85%EC%8A%A4/"><![CDATA[<h1 id="리눅스">리눅스</h1>

<h2 id="1-개발환경">1. 개발환경</h2>

<ul>
  <li>로컬 컴퓨터, 리모트 컴퓨터 : 웹 서버에 배포하기 위해서 로컬 컴퓨터에서 작업한 내용을 리모트 컴퓨터로 옮기게 된다.</li>
  <li>로컬 컴퓨터, 가상 컴퓨터 : 물리적 환경에서만 리모트 컴퓨터를 쓸 수 있는 제약을 막기 위해 <strong>가상 컴퓨터에서의 배포</strong>를 진행해보게 되며, 이를 위해 가상 환경 구현을 진행한다.</li>
  <li>유닉스 : iOS, OS X 등의 베이스가 되는 컴퓨터의 운영체제로, 1969년 벨 연구소 직원인 켄 톰슨이 게임의 원활한 진행을 위해 고안하다가 만들었다.</li>
  <li>리눅스 : 윈도우, 맥OS와 달리 무료로 제공되는 운영체제로, ‘리누스 토르발스’가 1991년에 만들었다.</li>
</ul>

<h1 id="linux">Linux</h1>

<h2 id="1-linux의-특징">1. Linux의 특징</h2>

<p>유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 <strong>‘오픈 소스’</strong>를 꼽을 수 있다.<br />
커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다.
즉, 이 커널로 자신의 운영 체제를 개발할 수 있다.<br />
Linux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다.<br />
장치 메모리를 관리하고 프로세스를 관리하는 역할을 수행한다.<br />
현재 여러 사용자가 기본 설정에 따라 다운로드할 수 있는 Linux 배포판을 사용할 수 있으며, 이 배포판은 여러 개발자들이 만들었다.<br />
현재 Linux 커널은 운영 체제 역할을 위한 다양한 배포판을 지원하는데, 이 중 하나가 바로 <strong>Ubuntu</strong>이다.</p>

<h2 id="2-linux의-장점">2. Linux의 장점</h2>

<p>안정적이며 안전한 운영 체제이며 여러 사용자가 동시 작업할 수 있기 때문에 다중 사용자 시스템으로 사용된다.<br />
많은 프로세서를 지원하며 멀티 태스킹으로 많은 프로세스의 실행이 가능하다.</p>

<h2 id="3-osoperating-system-운영체제">3. OS(Operating System, 운영체제)</h2>

<p>컴퓨터 시스템의 하드웨어, 소프트웨어 자원들을 효율적으로 운영해, 사용자의 시스템 이용을 편리하도록 하는 <strong>시스템 소프트웨어</strong>를 말한다.<br />
애플리케이션들이 동작하도록 자원을 관리하며 <strong>핵심 소프트웨어</strong>의 역할을 수행한다.<br />
추가적으로, 외부의 접근을 방어하는 역할도 수행한다.<br />
운영체제는 <strong>사용자 영역</strong>과 <strong>커널 영역</strong>으로 나눌 수 있다.</p>

<ul>
  <li>사용자 영역 : 사용자의 프로그램 사용을 위한 공간이다.</li>
  <li>커널 영역 : 사용자 영역의 사용 프로그램을 안전하고 효율적으로 작동하기 위해 컴퓨터 자원을 관리하는 공간이다.</li>
</ul>

<h2 id="4-kernal커널">4. Kernal(커널)</h2>

<p>컴퓨터의 운영체제의 핵심이 되는 프로그램으로, 시스템의 모든 것을 통제하는 역할을 수행한다.<br />
운영체제의 프로그램 수행을 위한 여러 서비스를 제공한다.<br />
보안, 자원관리, 추상화 같은 역할을 수행한다.</p>

<h2 id="5-배포판">5. 배포판?</h2>

<p>리눅스에서 작동하는 여러 프로그램을 모아 놓은 것으로, 이렇게 여러 프로그램이 모여 주어진 일을 수행하는 경우가 있으며, 이 중 하나가 Ubuntu이다.</p>

<h2 id="6-parallels-ubuntu-설치">6. Parallels, Ubuntu 설치</h2>

<p>이미 윈도우 사용을 위해 Parallels 구입을 한 상태이기 때문에 Parallels로 Ubuntu 설치를 진행했다.<br />
우선, <a href="https://ubuntu.com">Ubuntu</a> 페이지에서 다운로드를 진행하면 <code class="language-plaintext highlighter-rouge">ubuntu-20.04.3-desktop-amd64.iso</code>라는 이름의 파일이 생기게 된다.<br />
Parallels에서 새로운 OS 설치 버튼을 클릭하면 다운로드된 iso파일을 스스로 인식해 진행할 수 있다.</p>

<p><img src="/image/220106/2.png" alt="drawing" width="100%" /></p>

<p><img src="/image/220106/3.png" alt="drawing" width="100%" /></p>

<p>일반적인 윈도우 같은 운영체제의 설치와 같은 방식으로 진행되며, 따라서 진행을 하다보면 Ubuntu의 설치가 완료된다.</p>

<p><img src="/image/220106/4.png" alt="drawing" width="100%" /></p>

<h2 id="7-ssh-설정">7. SSH 설정</h2>

<p>원격 접속 설정을 위해 ssh 설정을 해야 하는데, Ubuntu 내의 터미널 파일을 켜야 한다.</p>

<p><img src="/image/220106/5.png" alt="drawing" width="100%" /></p>

<p>좌측 하단에 메뉴 버튼을 클릭 시 이러한 창이 나오는데, 거기서 terminal을 찾아서 실행하면 된다. 단축키는 <code class="language-plaintext highlighter-rouge">Ctrl + Alt + T</code>(맥에서는 아직 찾지 못함)</p>

<p><img src="/image/220106/6.png" alt="drawing" width="100%" /></p>

<p>위와 같은 창이 나오게 되고, ssh와 관련된 입력들을 넣어주면 된다.</p>

<h3 id="1-ssh-server-install">1) SSH server install</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo apt update
$ sudo apt install openssh-server
</code></pre></div></div>

<p>위 명령어를 입력해 SSH server를 설치한다.<br />
설치 여부의 확인을 위해 <code class="language-plaintext highlighter-rouge">sudo systemctl status ssh</code>를 입력하면 아래와 같은 결과가 나오는 것을 볼 수 있다.</p>

<p><img src="/image/220106/7.png" alt="drawing" width="100%" /></p>

<p>여기서 <strong>active(running)</strong>이라는 표시가 있으면 제대로 동작하고 있다고 할 수 있다.<br />
만약, 동작하지 않을 시 아래의 명령어 중 하나를 입력해 실행시킨다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo systemctl enable ssh
$ sudo systemctl start ssh
</code></pre></div></div>

<h3 id="2-firewall">2) Firewall</h3>

<p>방화벽을 사용 중일 경우, SSH를 허용해야 하며, <code class="language-plaintext highlighter-rouge">$ sudo ufw allow ssh</code>를 입력해 허용할 수 있다.<br />
방화벽 사용 여부의 확인은 <code class="language-plaintext highlighter-rouge">$ sudo ufw status</code>를 통해 할 수 있다.</p>

<h3 id="3-client">3) Client</h3>

<p>Ubuntu는 기본적으로 SSH client가 설치되어 있는데, 혹시 설치되지 않은 경우에는 <code class="language-plaintext highlighter-rouge">$ sudo apt-get install openssh-client</code>를 통해 설치할 수 있다.<br />
Client에서의 실행을 위해 username과 IP주소가 필요한데, IP주소는 <code class="language-plaintext highlighter-rouge">ip a</code>명령어를 통해서 확인할 수 있다.<br />
명령어 입력 시 긴 줄이 나오게 되는데, 이 중 <code class="language-plaintext highlighter-rouge">inet (IP주소)/24 brd~</code>라고 되어 있는 부분에서 IP주소를 가져오면 된다.</p>

<p><img src="/image/220106/8.png" alt="drawing" width="100%" /></p>

<p>원래의 이용하는 PC(Client)에서 터미널로 들어가 <code class="language-plaintext highlighter-rouge">username@IP</code>를 입력하면 접속과 관련된 질문이 나오고, yes를 누른 뒤 비밀번호 입력까지 완료하면 접속이 된다.</p>

<p><img src="/image/220106/9.png" alt="drawing" width="100%" /></p>

<p>접속을 나오고 싶을 때에는 <code class="language-plaintext highlighter-rouge">exit</code>를 입력하면 나올 수 있고, SSH 종료를 위해서 <code class="language-plaintext highlighter-rouge">sudo systemctl stop ssh</code>를 입력하면 된다.</p>

<p><img src="/image/220106/10.png" alt="drawing" width="100%" /></p>

<h3 id="4-directory-생성">4) Directory 생성</h3>

<p><code class="language-plaintext highlighter-rouge">mkdir (filename)</code>입력 시 생성이 가능하다.<br />
이전과 같이 원격으로 접속을 하고, 입력하게 될 시, 새로운 디렉토리가 만들어지게 된다.</p>

<p><img src="/image/220106/11.png" alt="drawing" width="100%" /></p>

<p><code class="language-plaintext highlighter-rouge">ls</code>는 디렉토리 내의 파일 목록들을 보여주는데, <code class="language-plaintext highlighter-rouge">mkdir</code>을 한 뒤 다시 보면 생성된 것을 확인할 수 있다.</p>

<h3 id="5-접근-권한-부여">5) 접근 권한 부여</h3>

<p>chmod라는 명령어를 통해서 파일과 폴더에 대한 접근권한을 부여할 수 있다.<br />
정확한 명령어는 아래와 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod [옵션] [사용자] [설정기호] [권한] [file or directory]
</code></pre></div></div>

<ul>
  <li>접근 권한 문자열</li>
</ul>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>기호</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>접근권한</td>
      <td>r</td>
      <td>읽기</td>
    </tr>
    <tr>
      <td> </td>
      <td>w</td>
      <td>쓰기</td>
    </tr>
    <tr>
      <td> </td>
      <td>x</td>
      <td>실행</td>
    </tr>
    <tr>
      <td>수행 연산</td>
      <td>+</td>
      <td>권한 추가</td>
    </tr>
    <tr>
      <td> </td>
      <td>-</td>
      <td>권한 제거</td>
    </tr>
    <tr>
      <td> </td>
      <td>+</td>
      <td>권한 부여</td>
    </tr>
    <tr>
      <td>사용자</td>
      <td>u</td>
      <td>user의 약자, 소유자</td>
    </tr>
    <tr>
      <td> </td>
      <td>g</td>
      <td>group의 약자, 그룹</td>
    </tr>
    <tr>
      <td> </td>
      <td>o</td>
      <td>other의 약자, 일반 사용자</td>
    </tr>
    <tr>
      <td> </td>
      <td>a</td>
      <td>all의 약자, 모든 사용자</td>
    </tr>
    <tr>
      <td> </td>
      <td>비어 있음</td>
      <td>a와 동일</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>접근 권한 숫자열</li>
</ul>

<table>
  <thead>
    <tr>
      <th>8진수</th>
      <th>2진수</th>
      <th>파일 모드</th>
      <th>권한</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>000</td>
      <td>- - -</td>
      <td>권한 없음</td>
    </tr>
    <tr>
      <td>1</td>
      <td>001</td>
      <td>- - x</td>
      <td>실행</td>
    </tr>
    <tr>
      <td>2</td>
      <td>010</td>
      <td>- w -</td>
      <td>쓰기</td>
    </tr>
    <tr>
      <td>3</td>
      <td>011</td>
      <td>- w x</td>
      <td>쓰기, 실행</td>
    </tr>
    <tr>
      <td>4</td>
      <td>100</td>
      <td>r - -</td>
      <td>읽기</td>
    </tr>
    <tr>
      <td>5</td>
      <td>101</td>
      <td>r - x</td>
      <td>읽기, 실행</td>
    </tr>
    <tr>
      <td>6</td>
      <td>110</td>
      <td>r w -</td>
      <td>읽기, 쓰기</td>
    </tr>
    <tr>
      <td>7</td>
      <td>111</td>
      <td>r w x</td>
      <td>읽기, 쓰기, 실행</td>
    </tr>
  </tbody>
</table>

<p>숫자열 세 개를 작성하는 경우, 소유자<code class="language-plaintext highlighter-rouge">(u)</code>, 그룹<code class="language-plaintext highlighter-rouge">(g)</code>, 일반사용자<code class="language-plaintext highlighter-rouge">(o)</code>의 순서로 권한을 부여한다.<br />
예를 들어 <code class="language-plaintext highlighter-rouge">754</code>의 경우 <strong>소유자는 7(읽기, 쓰기, 실행), 그룹은 5(읽기, 실행), 일반사용자는 4(읽기)</strong>가 가능한 것으로 설정할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jinjeon@ubuntu:~$ chmod 764 test
</code></pre></div></div>

<p>위와 같이 입력 시, test 디렉토리에 소유자 7, 그룹 6, 일반 사용자 4의 권한을 준 것이다.</p>

<h1 id="링크">링크</h1>

<ul>
  <li>VirtualBox, Ubuntu 설치 안내<br />
<a href="https://popcorn16.tistory.com/85">https://popcorn16.tistory.com/85</a></li>
  <li>parallels, Ubuntu 설치 안내<br />
<a href="https://m.blog.naver.com/woodkill/220790227283">https://m.blog.naver.com/woodkill/220790227283</a></li>
  <li>Linux, Ubuntu의 차이<br />
<a href="https://hanamon.kr/리눅스는-무엇이고-우분투는-무엇인가/">https://ko.strephonsays.com/difference-between-linux-and-ubuntu</a></li>
  <li>SSH 설치 및 접속 방법<br />
<a href="https://codechacha.com/ko/ubuntu-install-openssh/">https://codechacha.com/ko/ubuntu-install-openssh/</a><br />
<a href="https://jmoon.co.kr/183">https://jmoon.co.kr/183</a></li>
  <li>Ubuntu root 계정 전환 방법<br />
<a href="https://gabii.tistory.com/entry/Ubuntu-%EC%B4%88%EA%B8%B0-root-%EA%B3%84%EC%A0%95-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EA%B3%84%EC%A0%95-%EC%A0%84%ED%99%98">https://gabii.tistory.com/entry/Ubuntu-초기-root-계정-설정-및-계정-전환</a></li>
  <li>폴더 권한 변경(764)<br />
<a href="https://itworld.gmax8.com/25">https://itworld.gmax8.com/25</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="DEV" /><summary type="html"><![CDATA[리눅스 1. 개발환경 로컬 컴퓨터, 리모트 컴퓨터 : 웹 서버에 배포하기 위해서 로컬 컴퓨터에서 작업한 내용을 리모트 컴퓨터로 옮기게 된다. 로컬 컴퓨터, 가상 컴퓨터 : 물리적 환경에서만 리모트 컴퓨터를 쓸 수 있는 제약을 막기 위해 가상 컴퓨터에서의 배포를 진행해보게 되며, 이를 위해 가상 환경 구현을 진행한다. 유닉스 : iOS, OS X 등의 베이스가 되는 컴퓨터의 운영체제로, 1969년 벨 연구소 직원인 켄 톰슨이 게임의 원활한 진행을 위해 고안하다가 만들었다. 리눅스 : 윈도우, 맥OS와 달리 무료로 제공되는 운영체제로, ‘리누스 토르발스’가 1991년에 만들었다. Linux 1. Linux의 특징 유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 ‘오픈 소스’를 꼽을 수 있다. 커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다. 즉, 이 커널로 자신의 운영 체제를 개발할 수 있다. Linux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다. 장치 메모리를 관리하고 프로세스를 관리하는 역할을 수행한다. 현재 여러 사용자가 기본 설정에 따라 다운로드할 수 있는 Linux 배포판을 사용할 수 있으며, 이 배포판은 여러 개발자들이 만들었다. 현재 Linux 커널은 운영 체제 역할을 위한 다양한 배포판을 지원하는데, 이 중 하나가 바로 Ubuntu이다. 2. Linux의 장점 안정적이며 안전한 운영 체제이며 여러 사용자가 동시 작업할 수 있기 때문에 다중 사용자 시스템으로 사용된다. 많은 프로세서를 지원하며 멀티 태스킹으로 많은 프로세스의 실행이 가능하다. 3. OS(Operating System, 운영체제) 컴퓨터 시스템의 하드웨어, 소프트웨어 자원들을 효율적으로 운영해, 사용자의 시스템 이용을 편리하도록 하는 시스템 소프트웨어를 말한다. 애플리케이션들이 동작하도록 자원을 관리하며 핵심 소프트웨어의 역할을 수행한다. 추가적으로, 외부의 접근을 방어하는 역할도 수행한다. 운영체제는 사용자 영역과 커널 영역으로 나눌 수 있다. 사용자 영역 : 사용자의 프로그램 사용을 위한 공간이다. 커널 영역 : 사용자 영역의 사용 프로그램을 안전하고 효율적으로 작동하기 위해 컴퓨터 자원을 관리하는 공간이다. 4. Kernal(커널) 컴퓨터의 운영체제의 핵심이 되는 프로그램으로, 시스템의 모든 것을 통제하는 역할을 수행한다. 운영체제의 프로그램 수행을 위한 여러 서비스를 제공한다. 보안, 자원관리, 추상화 같은 역할을 수행한다. 5. 배포판? 리눅스에서 작동하는 여러 프로그램을 모아 놓은 것으로, 이렇게 여러 프로그램이 모여 주어진 일을 수행하는 경우가 있으며, 이 중 하나가 Ubuntu이다. 6. Parallels, Ubuntu 설치 이미 윈도우 사용을 위해 Parallels 구입을 한 상태이기 때문에 Parallels로 Ubuntu 설치를 진행했다. 우선, Ubuntu 페이지에서 다운로드를 진행하면 ubuntu-20.04.3-desktop-amd64.iso라는 이름의 파일이 생기게 된다. Parallels에서 새로운 OS 설치 버튼을 클릭하면 다운로드된 iso파일을 스스로 인식해 진행할 수 있다. 일반적인 윈도우 같은 운영체제의 설치와 같은 방식으로 진행되며, 따라서 진행을 하다보면 Ubuntu의 설치가 완료된다. 7. SSH 설정 원격 접속 설정을 위해 ssh 설정을 해야 하는데, Ubuntu 내의 터미널 파일을 켜야 한다. 좌측 하단에 메뉴 버튼을 클릭 시 이러한 창이 나오는데, 거기서 terminal을 찾아서 실행하면 된다. 단축키는 Ctrl + Alt + T(맥에서는 아직 찾지 못함) 위와 같은 창이 나오게 되고, ssh와 관련된 입력들을 넣어주면 된다. 1) SSH server install $ sudo apt update $ sudo apt install openssh-server 위 명령어를 입력해 SSH server를 설치한다. 설치 여부의 확인을 위해 sudo systemctl status ssh를 입력하면 아래와 같은 결과가 나오는 것을 볼 수 있다. 여기서 active(running)이라는 표시가 있으면 제대로 동작하고 있다고 할 수 있다. 만약, 동작하지 않을 시 아래의 명령어 중 하나를 입력해 실행시킨다. $ sudo systemctl enable ssh $ sudo systemctl start ssh 2) Firewall 방화벽을 사용 중일 경우, SSH를 허용해야 하며, $ sudo ufw allow ssh를 입력해 허용할 수 있다. 방화벽 사용 여부의 확인은 $ sudo ufw status를 통해 할 수 있다. 3) Client Ubuntu는 기본적으로 SSH client가 설치되어 있는데, 혹시 설치되지 않은 경우에는 $ sudo apt-get install openssh-client를 통해 설치할 수 있다. Client에서의 실행을 위해 username과 IP주소가 필요한데, IP주소는 ip a명령어를 통해서 확인할 수 있다. 명령어 입력 시 긴 줄이 나오게 되는데, 이 중 inet (IP주소)/24 brd~라고 되어 있는 부분에서 IP주소를 가져오면 된다. 원래의 이용하는 PC(Client)에서 터미널로 들어가 username@IP를 입력하면 접속과 관련된 질문이 나오고, yes를 누른 뒤 비밀번호 입력까지 완료하면 접속이 된다. 접속을 나오고 싶을 때에는 exit를 입력하면 나올 수 있고, SSH 종료를 위해서 sudo systemctl stop ssh를 입력하면 된다. 4) Directory 생성 mkdir (filename)입력 시 생성이 가능하다. 이전과 같이 원격으로 접속을 하고, 입력하게 될 시, 새로운 디렉토리가 만들어지게 된다. ls는 디렉토리 내의 파일 목록들을 보여주는데, mkdir을 한 뒤 다시 보면 생성된 것을 확인할 수 있다. 5) 접근 권한 부여 chmod라는 명령어를 통해서 파일과 폴더에 대한 접근권한을 부여할 수 있다. 정확한 명령어는 아래와 같다. chmod [옵션] [사용자] [설정기호] [권한] [file or directory] 접근 권한 문자열 구분 기호 설명 접근권한 r 읽기   w 쓰기   x 실행 수행 연산 + 권한 추가   - 권한 제거   + 권한 부여 사용자 u user의 약자, 소유자   g group의 약자, 그룹   o other의 약자, 일반 사용자   a all의 약자, 모든 사용자   비어 있음 a와 동일 접근 권한 숫자열 8진수 2진수 파일 모드 권한 0 000 - - - 권한 없음 1 001 - - x 실행 2 010 - w - 쓰기 3 011 - w x 쓰기, 실행 4 100 r - - 읽기 5 101 r - x 읽기, 실행 6 110 r w - 읽기, 쓰기 7 111 r w x 읽기, 쓰기, 실행 숫자열 세 개를 작성하는 경우, 소유자(u), 그룹(g), 일반사용자(o)의 순서로 권한을 부여한다. 예를 들어 754의 경우 소유자는 7(읽기, 쓰기, 실행), 그룹은 5(읽기, 실행), 일반사용자는 4(읽기)가 가능한 것으로 설정할 수 있다. jinjeon@ubuntu:~$ chmod 764 test 위와 같이 입력 시, test 디렉토리에 소유자 7, 그룹 6, 일반 사용자 4의 권한을 준 것이다. 링크 VirtualBox, Ubuntu 설치 안내 https://popcorn16.tistory.com/85 parallels, Ubuntu 설치 안내 https://m.blog.naver.com/woodkill/220790227283 Linux, Ubuntu의 차이 https://ko.strephonsays.com/difference-between-linux-and-ubuntu SSH 설치 및 접속 방법 https://codechacha.com/ko/ubuntu-install-openssh/ https://jmoon.co.kr/183 Ubuntu root 계정 전환 방법 https://gabii.tistory.com/entry/Ubuntu-초기-root-계정-설정-및-계정-전환 폴더 권한 변경(764) https://itworld.gmax8.com/25]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">디지털 논리회로</title><link href="http://localhost:4000/dev/2022/01/03/%EB%94%94%EC%A7%80%ED%84%B8_%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C/" rel="alternate" type="text/html" title="디지털 논리회로" /><published>2022-01-03T00:00:00+09:00</published><updated>2022-01-03T00:00:00+09:00</updated><id>http://localhost:4000/dev/2022/01/03/%EB%94%94%EC%A7%80%ED%84%B8_%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C</id><content type="html" xml:base="http://localhost:4000/dev/2022/01/03/%EB%94%94%EC%A7%80%ED%84%B8_%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C/"><![CDATA[<h1 id="디지털-논리회로란">디지털 논리회로란?</h1>

<blockquote>
  <p>이산적인 숫자를 게이트 입력으로 받아, 입력 논리의 필요 조건을 만족, 불만족하는 지에 대해 1 또는 0의 신호로 출력하는 하드웨어 소자이다.</p>
</blockquote>

<p>디지털 논리회로의 연결을 통해 <em>컴퓨터의</em> 구성 부품을 만들게 된다.<br />
또한, 논리적 사고를 위한 가장 기본적인 동작으로 프로그래밍 논리 구조와 연결된다.</p>

<h2 id="종류">종류</h2>

<ul>
  <li>AND 게이트(논리곱) : 두 입력 모두 1인 경우에만 1, 나머지는 0이 출력된다.</li>
</ul>

<p><img src="/image/220103/ANDgate.png" alt="drawing" width="25%" /></p>

<ul>
  <li>OR 게이트(논리합) : 두 입력 중 1이 존재할 경우 1, 아닐 시 0이 출력된다.</li>
</ul>

<p><img src="/image/220103/ORgate.png" alt="drawing" width="25%" /></p>

<ul>
  <li>NOT 게이트(논리부정, INVERTOR) : 입력이 반전되어 출력된다.</li>
</ul>

<p><img src="/image/220103/NOTgate.png" alt="drawing" width="25%" /></p>

<ul>
  <li>NAND 게이트 : 두 입력 중 하나 이상 0인 경우 1, 나머지는 0이 출력된다.
즉, 두 입력이 모두 1인 경우 0이 출력된다. AND 게이트와 반대의 역할을 한다.</li>
</ul>

<p><img src="/image/220103/NANDgate.png" alt="drawing" width="25%" /></p>

<ul>
  <li>NOR 게이트(부정논리합) : 두 입력 중 하나 이상 1인 경우 0, 나머지는 1이 출력된다.
즉, 두 입력 모두 0인 경우에 1이 출력된다.
OR 게이트와 반대의 역할을 한다.</li>
</ul>

<p><img src="/image/220103/NORgate.png" alt="drawing" width="25%" /></p>

<ul>
  <li>XOR 게이트(배타적 논리합) : 입력이 같을 경우 0, 다를 경우 1이 출력된다. 참 입력의 개수가 홀수일 때 참을 내보낸다.</li>
</ul>

<p><img src="/image/220103/XORgate.png" alt="drawing" width="25%" /></p>

<h2 id="이진수">이진수</h2>

<p>전원이 켜진 상태와 꺼진 상태를 각각 true, false의 형태로 나타낼 수 있으며, 이런 방식을 수학자 조지 부울의 이름을 따서 Boolean 타입이라고 부른다.<br />
Boolean 타입은 <strong>논리대수의 기본 타입</strong>이며 동시에 디지털 시스템을 구성하는 하드웨어 및 소프트웨어의 <strong>가장 기본적인 타입</strong>이다.<br />
모든 전자부품은 전기의 흐름 유무로 Boolean 타입을 나타낼 수 있으며, 이 개념의 확장으로 모든 10진수 숫자를 2진수 코드로 나타낼 수 있다.<br />
예시로, 1비트(bit)는 2개(0-1)의 값을 나타낼 수 있고, 2비트는 4개(0-3), 3비트는 8개(0-7)의 값을 나타낼 수 있다. 그리고 이는 각각 2^(비트수)의 형태로 나타난다.</p>

<h2 id="반가산기half-adder">반가산기(half-adder)</h2>

<p>두 개의 비트를 더하는 과정에서, 결과값을 2비트의 값으로 표현해볼 수 있다.<br />
<img src="/image/220103/halfAdder.png" alt="drawing" width="50%" /></p>

<!-- <div width="50%"> -->

<table>
  <thead>
    <tr>
      <th>+</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>00</td>
      <td>01</td>
    </tr>
    <tr>
      <td>1</td>
      <td>01</td>
      <td>10</td>
    </tr>
  </tbody>
</table>

<!-- </div> -->

<p>왼쪽과 같이 2비트의 값으로 나타낼 수 있고, 한 비트 내의 두 이진수를 더하면, 두 비트가 되어 각각의 비트를 합(sum)비트, 자리올림(carry)비트라고 한다.</p>

<ul>
  <li>합비트</li>
</ul>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>자리올림비트</li>
</ul>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h2 id="전가산기full-adder">전가산기(full-adder)</h2>

<p>두번째 자리부터는 자리올림이 발생한 경우에 대해서도 더해줘야 하기 때문에, 세 개의 이진수를 더하는 경우에는 두 개의 반가산기 및 OR 게이트를 활용하는 전가산기를 사용한다.</p>

<p><img src="/image/220103/fullAdder.png" alt="drawing" width="50%" />
<img src="/image/220103/fullAdder2.png" alt="drawing" width="75%" /></p>

<hr />

<h1 id="10진법과-2진법">10진법과 2진법</h1>

<h2 id="10진법">10진법</h2>

<p>10의 배수의 단위로 숫자를 나누어 나타내는 방법이다. 10단위가 올라갈 때마다 숫자가 증가하는 모습을 보인다.</p>

<h2 id="2진법">2진법</h2>

<p>2의 배수의 단위로 숫자를 나누어 나타낸다. 2단위가 증가 시 숫자가 올라가게 된다. 가장 작은 단위는 2^0 단위로, 이 한 단위를 비트(bit)로 표현하게 된다.</p>]]></content><author><name>JinJeon</name></author><category term="DEV" /><summary type="html"><![CDATA[디지털 논리회로란? 이산적인 숫자를 게이트 입력으로 받아, 입력 논리의 필요 조건을 만족, 불만족하는 지에 대해 1 또는 0의 신호로 출력하는 하드웨어 소자이다. 디지털 논리회로의 연결을 통해 컴퓨터의 구성 부품을 만들게 된다. 또한, 논리적 사고를 위한 가장 기본적인 동작으로 프로그래밍 논리 구조와 연결된다. 종류 AND 게이트(논리곱) : 두 입력 모두 1인 경우에만 1, 나머지는 0이 출력된다. OR 게이트(논리합) : 두 입력 중 1이 존재할 경우 1, 아닐 시 0이 출력된다. NOT 게이트(논리부정, INVERTOR) : 입력이 반전되어 출력된다. NAND 게이트 : 두 입력 중 하나 이상 0인 경우 1, 나머지는 0이 출력된다. 즉, 두 입력이 모두 1인 경우 0이 출력된다. AND 게이트와 반대의 역할을 한다. NOR 게이트(부정논리합) : 두 입력 중 하나 이상 1인 경우 0, 나머지는 1이 출력된다. 즉, 두 입력 모두 0인 경우에 1이 출력된다. OR 게이트와 반대의 역할을 한다. XOR 게이트(배타적 논리합) : 입력이 같을 경우 0, 다를 경우 1이 출력된다. 참 입력의 개수가 홀수일 때 참을 내보낸다. 이진수 전원이 켜진 상태와 꺼진 상태를 각각 true, false의 형태로 나타낼 수 있으며, 이런 방식을 수학자 조지 부울의 이름을 따서 Boolean 타입이라고 부른다. Boolean 타입은 논리대수의 기본 타입이며 동시에 디지털 시스템을 구성하는 하드웨어 및 소프트웨어의 가장 기본적인 타입이다. 모든 전자부품은 전기의 흐름 유무로 Boolean 타입을 나타낼 수 있으며, 이 개념의 확장으로 모든 10진수 숫자를 2진수 코드로 나타낼 수 있다. 예시로, 1비트(bit)는 2개(0-1)의 값을 나타낼 수 있고, 2비트는 4개(0-3), 3비트는 8개(0-7)의 값을 나타낼 수 있다. 그리고 이는 각각 2^(비트수)의 형태로 나타난다. 반가산기(half-adder) 두 개의 비트를 더하는 과정에서, 결과값을 2비트의 값으로 표현해볼 수 있다. + 0 1 0 00 01 1 01 10 왼쪽과 같이 2비트의 값으로 나타낼 수 있고, 한 비트 내의 두 이진수를 더하면, 두 비트가 되어 각각의 비트를 합(sum)비트, 자리올림(carry)비트라고 한다. 합비트   0 1 0 0 1 1 1 0 자리올림비트   0 1 0 0 0 1 0 1 전가산기(full-adder) 두번째 자리부터는 자리올림이 발생한 경우에 대해서도 더해줘야 하기 때문에, 세 개의 이진수를 더하는 경우에는 두 개의 반가산기 및 OR 게이트를 활용하는 전가산기를 사용한다. 10진법과 2진법 10진법 10의 배수의 단위로 숫자를 나누어 나타내는 방법이다. 10단위가 올라갈 때마다 숫자가 증가하는 모습을 보인다. 2진법 2의 배수의 단위로 숫자를 나누어 나타낸다. 2단위가 증가 시 숫자가 올라가게 된다. 가장 작은 단위는 2^0 단위로, 이 한 단위를 비트(bit)로 표현하게 된다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>