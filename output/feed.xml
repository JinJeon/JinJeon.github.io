<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-11-22T21:39:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JINJEONIMUM</title><subtitle></subtitle><author><name>JinJeon</name></author><entry><title type="html">socket 연결 해제 시 재연결 시도</title><link href="http://localhost:4000/javascript/2022/11/22/socket-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EC%8B%9C-%EC%9E%AC%EC%97%B0%EA%B2%B0-%EC%8B%9C%EB%8F%84/" rel="alternate" type="text/html" title="socket 연결 해제 시 재연결 시도" /><published>2022-11-22T00:00:00+09:00</published><updated>2022-11-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/11/22/socket%20%EC%97%B0%EA%B2%B0%20%ED%95%B4%EC%A0%9C%20%EC%8B%9C%20%EC%9E%AC%EC%97%B0%EA%B2%B0%20%EC%8B%9C%EB%8F%84</id><content type="html" xml:base="http://localhost:4000/javascript/2022/11/22/socket-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EC%8B%9C-%EC%9E%AC%EC%97%B0%EA%B2%B0-%EC%8B%9C%EB%8F%84/"><![CDATA[<h3 id="socket-연결이-끊길-시-다시-연결하는-방법">socket 연결이 끊길 시 다시 연결하는 방법</h3>

<p>연결이 끊기는 경우, <strong>StompJS는 다시 연결하기 위해서 새롭게 SockJS와 StompJS를 설정해주어야 한다</strong>는 <a href="https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over">사실</a>을 알게 되었습니다. 이를 토대로 기존에 작성된 코드가 새로운 SockJS, StompJS를 만들 수 없어, 새롭게 만들 수 있는 형태로 변환하고 어느 컴포넌트에서든 이를 사용할 수 있게 수정했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/0.png" alt="" width="100%" height="" /> 
</figure>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존에 작성된 형태로, 한 번 만들어진 뒤, 이를 다시 사용하는 데에 어려움이 따름</span>
<span class="kd">const</span> <span class="nx">sockServer</span> <span class="o">=</span> <span class="nx">API</span><span class="p">.</span><span class="nx">WEBSOCKET</span><span class="p">;</span> <span class="c1">// 들어갈 주소 설정</span>
<span class="kd">const</span> <span class="nx">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJs</span><span class="p">(</span><span class="nx">sockServer</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 새롭게 작성된 형태로, getStompClient를 호출해 어디서든 다시 소켓 재연결을 시도할 수 있음</span>
<span class="kd">let</span> <span class="nx">stompClient</span><span class="p">:</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">Client</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStompClient</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sockServer</span> <span class="o">=</span> <span class="nx">API</span><span class="p">.</span><span class="nx">WEBSOCKET</span><span class="p">;</span> <span class="c1">// 들어갈 주소 설정</span>
  <span class="kd">const</span> <span class="nx">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJs</span><span class="p">(</span><span class="nx">sockServer</span><span class="p">);</span>
  <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">getStompClient</span><span class="p">();</span>
</code></pre></div></div>

<p>위와 같이, stomp에 연결을 요청할 수 있는 메소드를 만들고, 이를 에러가 발생해 끊기는 상황에서 다시 연결할 때 사용하도록 설정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">maxRetryCount</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">retryCount</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nx">connectStomp</span><span class="p">({</span>
  <span class="na">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 에러가 발생했을 때</span>
    <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="c1">// 연결이 끊겼음을 알림</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">retryCount</span><span class="p">.</span><span class="nx">current</span> <span class="o">&lt;=</span> <span class="nx">maxRetryCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 재시도 횟수가 아직 남아있는 경우</span>
      <span class="nx">retryCount</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">// stomp client를 새로 만들고 socket에 연결함</span>
      <span class="nx">getStompClient</span><span class="p">();</span>
      <span class="nx">connectSocket</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">...</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위와 같은 형태의 코드를 작성함으로서 총 3번의 재시도를 하도록 하였고, 이후의 재시도는 없도록 설정을 해두었습니다. 하지만 이러한 식으로 진행할 경우, 노트북을 닫았다 다시 켜는 상황(네트워크와 브라우저가 자체적으로 멈추는 상황)에 대해서는 올바르게 재요청을 보내 다시 소켓은 연결하지만 <strong>와이파이를 끄는 경우는 이를 제대로 처리할 수가 없었습니다.</strong></p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/1.gif" alt="" width="100%" height="" /> 
</figure>

<h3 id="재시도를-하는-조건-변경하기">재시도를 하는 조건 변경하기</h3>

<p>이러한 문제를 해결하기 위해서 첫번째로, 지속적으로 브라우저가 연결을 시도하도록 하고, 재시도를 하는 빈도는 ‘횟수’가 아니라 ‘시간’으로 설정해야한다고 판단했습니다. 이를 위해 연결이 끊긴 상황이 발생할 때 일정 시간 주기로 다시 연결을 시도하도록 기능을 추가하고자 했습니다.</p>

<p>처음에는 StompJS 내에 존재하는 <code class="language-plaintext highlighter-rouge">heartbeat</code>이라는 것을 사용하고자 했습니다. 하지만, <code class="language-plaintext highlighter-rouge">heartbeat</code>으로는 와이파이와 같은 인터넷 연결이 끊긴 상황을 인식할 수 없다는 것을 알게 됐고, <code class="language-plaintext highlighter-rouge">setTimeout</code>을 통해 직접적인 확인이 필요하다고 판단했습니다.</p>

<p>에러로 인해 연결이 끊어지는 경우, setTImeout을 통해 정해진 시간 이후 다시 연결을 시도하도록 코드를 구성했습니다. 이를 통해 에러로 인해 소켓 연결이 끊기는 경우 주기적으로 연결을 재시도하도록 할 수 있었습니다. 그리고 연결이 완료될 경우(<code class="language-plaintext highlighter-rouge">onSuccess</code>), 연결이 되지 않았던 시간(<code class="language-plaintext highlighter-rouge">disconnectTimeRef</code>)을 초기화시켜 다음 연결 해제 시 다시 처음부터 계산을 할 수 있도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">socketConnectRetryInterval</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="c1">// ms</span>
<span class="kd">const</span> <span class="nx">socketConnectRetryIntervalMax</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 10mins</span>
<span class="kd">const</span> <span class="nx">disconnectTimeRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nl">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">disconnectTime</span> <span class="o">=</span> <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">disconnectTime</span> <span class="o">&gt;</span> <span class="nx">socketConnectRetryIntervalMax</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="nx">socketConnectRetryInterval</span><span class="p">;</span>

  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">getStompClient</span><span class="p">();</span>
    <span class="nx">connectSocket</span><span class="p">();</span>
  <span class="p">},</span> <span class="nx">socketConnectRetryInterval</span><span class="p">);</span>
<span class="c1">// 에러가 있는 경우 정해진 시간이 지날 때마다 요청을 보내 확인하도록 함</span>
<span class="p">},</span>
<span class="nx">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">},</span>
</code></pre></div></div>

<p>그리고 이제 인터넷 연결이 끊긴 것을 인지해야 할 필요가 있었는데, 이를 위해서는 브라우저의 내장 기능인 <code class="language-plaintext highlighter-rouge">eventlistener</code>의 <code class="language-plaintext highlighter-rouge">offline</code>을 활용했습니다. offline이 된 상황이 발생할 경우, 에러가 발생한 것과 동일하게 처리를 해주면 되었기에 위의 코드를 따로 빼내어 offline 상황에도 적용이 될 수 있도록 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 소켓 연결을 재시도하는 함수로 따로 빼냄</span>
<span class="kd">const</span> <span class="nx">retrySocketConnect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">disconnectTime</span> <span class="o">=</span> <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">disconnectTime</span> <span class="o">&gt;</span> <span class="nx">socketConnectRetryIntervalMax</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="nx">socketConnectRetryInterval</span><span class="p">;</span>
  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">getStompClient</span><span class="p">();</span>
    <span class="nx">connectSocket</span><span class="p">();</span>
  <span class="p">},</span> <span class="nx">socketConnectRetryInterval</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">connectSocket</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">connectStomp</span><span class="p">({</span>
    <span class="na">onError</span><span class="p">:</span> <span class="nx">retrySocketConnect</span><span class="p">,</span>
    <span class="na">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">noticeParams</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">entryIds</span><span class="p">,</span>
      <span class="nx">keywordIds</span><span class="p">,</span>
      <span class="na">onSubscribeEntries</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
      <span class="na">onSubscribeKeywords</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="na">chatParams</span><span class="p">:</span> <span class="p">{</span> <span class="nx">chatroomIds</span><span class="p">,</span> <span class="nx">onReceiveChat</span> <span class="p">},</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="nx">connectSocket</span><span class="p">();</span>
<span class="c1">// 연결이 끊어질 시, 연결 재시도</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">offline</span><span class="dl">"</span><span class="p">,</span> <span class="nx">retrySocketConnect</span><span class="p">);</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/2.gif" alt="소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨" width="100%" height="" /> 
  <figcaption class="caption">소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨</figcaption>
  
</figure>

<hr />

<h3 id="참고-링크">참고 링크</h3>

<ul>
  <li><a href="https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over">StompJS 관련 안내문</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="JAVASCRIPT" /><summary type="html"><![CDATA[socket 연결이 끊길 시 다시 연결하는 방법 연결이 끊기는 경우, StompJS는 다시 연결하기 위해서 새롭게 SockJS와 StompJS를 설정해주어야 한다는 사실을 알게 되었습니다. 이를 토대로 기존에 작성된 코드가 새로운 SockJS, StompJS를 만들 수 없어, 새롭게 만들 수 있는 형태로 변환하고 어느 컴포넌트에서든 이를 사용할 수 있게 수정했습니다. // 기존에 작성된 형태로, 한 번 만들어진 뒤, 이를 다시 사용하는 데에 어려움이 따름 const sockServer = API.WEBSOCKET; // 들어갈 주소 설정 const sock = new SockJs(sockServer); export const stompClient = StompJs.over(sock); // 새롭게 작성된 형태로, getStompClient를 호출해 어디서든 다시 소켓 재연결을 시도할 수 있음 let stompClient: StompJs.Client; export const getStompClient = () =&gt; { const sockServer = API.WEBSOCKET; // 들어갈 주소 설정 const sock = new SockJs(sockServer); stompClient = StompJs.over(sock); }; getStompClient(); 위와 같이, stomp에 연결을 요청할 수 있는 메소드를 만들고, 이를 에러가 발생해 끊기는 상황에서 다시 연결할 때 사용하도록 설정했습니다. const maxRetryCount = 3; const retryCount = useRef(0); connectStomp({ onError: () =&gt; { // 에러가 발생했을 때 setSocketConnect(false); // 연결이 끊겼음을 알림 if (retryCount.current &lt;= maxRetryCount) { // 재시도 횟수가 아직 남아있는 경우 retryCount.current += 1; // stomp client를 새로 만들고 socket에 연결함 getStompClient(); connectSocket(); } }, ... }); 위와 같은 형태의 코드를 작성함으로서 총 3번의 재시도를 하도록 하였고, 이후의 재시도는 없도록 설정을 해두었습니다. 하지만 이러한 식으로 진행할 경우, 노트북을 닫았다 다시 켜는 상황(네트워크와 브라우저가 자체적으로 멈추는 상황)에 대해서는 올바르게 재요청을 보내 다시 소켓은 연결하지만 와이파이를 끄는 경우는 이를 제대로 처리할 수가 없었습니다. 재시도를 하는 조건 변경하기 이러한 문제를 해결하기 위해서 첫번째로, 지속적으로 브라우저가 연결을 시도하도록 하고, 재시도를 하는 빈도는 ‘횟수’가 아니라 ‘시간’으로 설정해야한다고 판단했습니다. 이를 위해 연결이 끊긴 상황이 발생할 때 일정 시간 주기로 다시 연결을 시도하도록 기능을 추가하고자 했습니다. 처음에는 StompJS 내에 존재하는 heartbeat이라는 것을 사용하고자 했습니다. 하지만, heartbeat으로는 와이파이와 같은 인터넷 연결이 끊긴 상황을 인식할 수 없다는 것을 알게 됐고, setTimeout을 통해 직접적인 확인이 필요하다고 판단했습니다. 에러로 인해 연결이 끊어지는 경우, setTImeout을 통해 정해진 시간 이후 다시 연결을 시도하도록 코드를 구성했습니다. 이를 통해 에러로 인해 소켓 연결이 끊기는 경우 주기적으로 연결을 재시도하도록 할 수 있었습니다. 그리고 연결이 완료될 경우(onSuccess), 연결이 되지 않았던 시간(disconnectTimeRef)을 초기화시켜 다음 연결 해제 시 다시 처음부터 계산을 할 수 있도록 했습니다. const socketConnectRetryInterval = 5000; // ms const socketConnectRetryIntervalMax = 10 * 60 * 1000; // 10mins const disconnectTimeRef = useRef(0); onError: () =&gt; { const disconnectTime = disconnectTimeRef.current; if (disconnectTime &gt; socketConnectRetryIntervalMax) return; disconnectTimeRef.current += socketConnectRetryInterval; setSocketConnect(false); setTimeout(() =&gt; { getStompClient(); connectSocket(); }, socketConnectRetryInterval); // 에러가 있는 경우 정해진 시간이 지날 때마다 요청을 보내 확인하도록 함 }, onConnect: () =&gt; { disconnectTimeRef.current = 0; setSocketConnect(true); }, 그리고 이제 인터넷 연결이 끊긴 것을 인지해야 할 필요가 있었는데, 이를 위해서는 브라우저의 내장 기능인 eventlistener의 offline을 활용했습니다. offline이 된 상황이 발생할 경우, 에러가 발생한 것과 동일하게 처리를 해주면 되었기에 위의 코드를 따로 빼내어 offline 상황에도 적용이 될 수 있도록 해주었습니다. // 소켓 연결을 재시도하는 함수로 따로 빼냄 const retrySocketConnect = () =&gt; { const disconnectTime = disconnectTimeRef.current; if (disconnectTime &gt; socketConnectRetryIntervalMax) return; disconnectTimeRef.current += socketConnectRetryInterval; setSocketConnect(false); setTimeout(() =&gt; { getStompClient(); connectSocket(); }, socketConnectRetryInterval); }; const connectSocket = () =&gt; { connectStomp({ onError: retrySocketConnect, onConnect: () =&gt; { disconnectTimeRef.current = 0; setSocketConnect(true); }, noticeParams: { entryIds, keywordIds, onSubscribeEntries: onSubscribeNotice, onSubscribeKeywords: onSubscribeNotice, }, chatParams: { chatroomIds, onReceiveChat }, }); }; connectSocket(); // 연결이 끊어질 시, 연결 재시도 window.addEventListener("offline", retrySocketConnect); 소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨 참고 링크 StompJS 관련 안내문]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">https 내 http 요청 시 자동 전환</title><link href="http://localhost:4000/html/2022/11/21/https-%EB%82%B4-http-%EC%9A%94%EC%B2%AD-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%A0%84%ED%99%98/" rel="alternate" type="text/html" title="https 내 http 요청 시 자동 전환" /><published>2022-11-21T00:00:00+09:00</published><updated>2022-11-21T00:00:00+09:00</updated><id>http://localhost:4000/html/2022/11/21/https%20%EB%82%B4%20http%20%EC%9A%94%EC%B2%AD%20%EC%8B%9C%20%EC%9E%90%EB%8F%99%20%EC%A0%84%ED%99%98</id><content type="html" xml:base="http://localhost:4000/html/2022/11/21/https-%EB%82%B4-http-%EC%9A%94%EC%B2%AD-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%A0%84%ED%99%98/"><![CDATA[<h3 id="http-요청의-문제점">http 요청의 문제점</h3>

<p>배포 주소와 서버의 API 주소를 https로 바뀐 뒤 실행을 했을 경우, 기존에 카카오 이미지를 크롬에서는 잘 가져오지만 사파리에서는 제대로 가져오지 못하는 문제가 있었습니다. 이 문제는 크롬에서는 자동으로 http 요청을 https로 바꾸어 요청을 보내지만, 사파리에서는 그 기능을 수행하지 못하는 것이 원인이었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221121/0.png" alt="사파리에서 http로 되어 막혔다는 경고" width="100%" height="" /> 
  <figcaption class="caption">사파리에서 http로 되어 막혔다는 경고</figcaption>
  
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221121/1.png" alt="크롬에서 http를 https로 자동 변경했다는 경고" width="100%" height="" /> 
  <figcaption class="caption">크롬에서 http를 https로 자동 변경했다는 경고</figcaption>
  
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221121/2.png" alt="사진을 받아오지 못해 보여주지 못하는 모습" width="100%" height="" /> 
  <figcaption class="caption">사진을 받아오지 못해 보여주지 못하는 모습</figcaption>
  
</figure>

<h3 id="http를-https로-바꾸기">http를 https로 바꾸기</h3>

<p>이를 해결하기 위해서는 서버의 API를 바꿨듯이, 서버에서 받아오는 이미지의 링크도 https로 바꾸는 방법이 있었습니다. 하지만, 이 이미지의 링크같은 경우, http와 https에서 요청 시 동일한 결과가 나오기 때문에, 클라이언트에서 http를 https로 바꾸는 방법을 사용하게 됐습니다.</p>

<p>이러한 경우, HTML 자체적으로 해결이 가능한데, HTML의 ‘meta’ 태그에서 <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta#attr-http-equiv">‘http-equiv’</a> 속성을 설정하여 해결할 수 있습니다. 링크의 설명에 나와있듯, http 헤더를 설정하는 역할을 하며, 이번에는 여기서 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">‘content-security-policy’</a>라는 속성을 사용했습니다. 이 속성은 <strong>관리자가 자신의 페이지에 가져올 수 있는 리소스를 제어</strong>하는 역할을 합니다.</p>

<p>여기서 제어를 위해 사용한 것은 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/upgrade-insecure-requests">‘upgrade-insecure-requests’</a>로, 아래 사진에 나와 있듯, http로 된 것들은 요청을 보내기 전에 https로 처리하고 요청을 보냅니다. 이 때, https로 사용할 수 없는 경우, http로 다시 보내지 않고 요청이 실패했다는 결과를 보여주게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221121/3.png" alt="" width="100%" height="" /> 
</figure>

<p>앞서 말했듯, 현재 사용 중인 http의 경우, 카카오톡에서 받아온 이미지 링크들이며 이들은 https로 대체가 되기 때문에 사용이 가능했습니다. 그래서 아래와 같은 코드를 추가해주어 문제를 해결할 수 있었습니다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span>
  <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span>
  <span class="na">content=</span><span class="s">"upgrade-insecure-requests"</span>
<span class="nt">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221121/4.png" alt="카카오를 통해 받아온 이미지가 정상적으로 나옴" width="100%" height="" /> 
  <figcaption class="caption">카카오를 통해 받아온 이미지가 정상적으로 나옴</figcaption>
  
</figure>]]></content><author><name>JinJeon</name></author><category term="HTML" /><summary type="html"><![CDATA[http 요청의 문제점 배포 주소와 서버의 API 주소를 https로 바뀐 뒤 실행을 했을 경우, 기존에 카카오 이미지를 크롬에서는 잘 가져오지만 사파리에서는 제대로 가져오지 못하는 문제가 있었습니다. 이 문제는 크롬에서는 자동으로 http 요청을 https로 바꾸어 요청을 보내지만, 사파리에서는 그 기능을 수행하지 못하는 것이 원인이었습니다. 사파리에서 http로 되어 막혔다는 경고 크롬에서 http를 https로 자동 변경했다는 경고 사진을 받아오지 못해 보여주지 못하는 모습 http를 https로 바꾸기 이를 해결하기 위해서는 서버의 API를 바꿨듯이, 서버에서 받아오는 이미지의 링크도 https로 바꾸는 방법이 있었습니다. 하지만, 이 이미지의 링크같은 경우, http와 https에서 요청 시 동일한 결과가 나오기 때문에, 클라이언트에서 http를 https로 바꾸는 방법을 사용하게 됐습니다. 이러한 경우, HTML 자체적으로 해결이 가능한데, HTML의 ‘meta’ 태그에서 ‘http-equiv’ 속성을 설정하여 해결할 수 있습니다. 링크의 설명에 나와있듯, http 헤더를 설정하는 역할을 하며, 이번에는 여기서 ‘content-security-policy’라는 속성을 사용했습니다. 이 속성은 관리자가 자신의 페이지에 가져올 수 있는 리소스를 제어하는 역할을 합니다. 여기서 제어를 위해 사용한 것은 ‘upgrade-insecure-requests’로, 아래 사진에 나와 있듯, http로 된 것들은 요청을 보내기 전에 https로 처리하고 요청을 보냅니다. 이 때, https로 사용할 수 없는 경우, http로 다시 보내지 않고 요청이 실패했다는 결과를 보여주게 됩니다. 앞서 말했듯, 현재 사용 중인 http의 경우, 카카오톡에서 받아온 이미지 링크들이며 이들은 https로 대체가 되기 때문에 사용이 가능했습니다. 그래서 아래와 같은 코드를 추가해주어 문제를 해결할 수 있었습니다. &lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" /&gt; 카카오를 통해 받아온 이미지가 정상적으로 나옴]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 20207번</title><link href="http://localhost:4000/algorithm/2022/11/20/20207/" rel="alternate" type="text/html" title="백준 20207번" /><published>2022-11-20T00:00:00+09:00</published><updated>2022-11-20T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/20/20207</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/20/20207/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/20207">QUESTION LINK</a></strong></p>

<p>처음 이 문제를 풀 때에는 주어지는 일정들을 모두 오름차순으로 정리한 뒤, 달력 배열에 직접 표기해가면서 끊어지는 상황마다 직사각형의 합을 구해주고자 했습니다. 하지만, 문제의 조건들을 다시 살펴본 결과 두 가지만 고려하면 된다는 것을 파악할 수 있었습니다.</p>

<ol>
  <li>세로길이는 주어지는 일정들을 직사각형으로 만들 때 일정이 겹치는 날이 가장 많은 곳의 개수와 같음</li>
  <li>가로길이는 일정이 없는 날이 나오기 전까지 중복합을 해주고, 일정이 없는 날이 나올 시 중복합을 사용함</li>
</ol>

<p>위 두 가지 조건을 이용해서 문제를 풀면되었기에, 우선 달력에 모든 일정들을 표기하는 작업을 먼저 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="p">...</span><span class="nx">schedules</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fs</span>
  <span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">trim</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">calendar</span> <span class="o">=</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="mi">365</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)];</span>
<span class="c1">// 달력 내의 모든 값들을 0으로 우선 설정</span>

<span class="nx">schedules</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">schedule</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 각 일정마다 시작일부터 종료일까지 배열에 맞게 -1을 해주고 달력에 넣어줌</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">startDay</span><span class="p">,</span> <span class="nx">endDay</span><span class="p">]</span> <span class="o">=</span> <span class="nx">schedule</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">v</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">startDay</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">endDay</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">calendar</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>그리고 이렇게 설정된 달력을 통해서 가로, 세로, 넓이 합을 달력을 순회하면서 구해주도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">calendar</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">count</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 달력의 마지막 날이며, 일정이 존재하는 경우</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="mi">365</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="nx">y</span><span class="p">)</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">count</span><span class="p">;</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 일정은 없으나 전날까지는 일정이 존재한 경우</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">count</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 일정이 있으나 이전에 일정이 없었던 경우</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">count</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 일정이 이어지는 경우</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="nx">y</span><span class="p">)</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">count</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>해당 문제를 풀면서 예외처리를 제대로 해주지 못했던 것은 위 코드에서 가장 첫 조건식이었습니다. 일정이 끝나는 경우는 무조건 ‘일정이 없는 날이 나올 때’라고 고려를 해서 문제를 풀었으나, 달력의 마지막 날이 끝나는 경우에도 일정이 종료되기 때문에 이를 고려해 조건식을 추가했습니다.</p>

<p>기존에 생각했던 풀이 방식보다 새롭게 알게 된 풀이 방식이 훨씬 간단했고, 예외 조건도 잘 고려해주기만 하면 금방 풀 수 있는 문제였습니다. <strong>문제 풀이와 예외 조건에 대한 고민</strong>이 더 필요하다는 것을 느꼈습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 처음 이 문제를 풀 때에는 주어지는 일정들을 모두 오름차순으로 정리한 뒤, 달력 배열에 직접 표기해가면서 끊어지는 상황마다 직사각형의 합을 구해주고자 했습니다. 하지만, 문제의 조건들을 다시 살펴본 결과 두 가지만 고려하면 된다는 것을 파악할 수 있었습니다. 세로길이는 주어지는 일정들을 직사각형으로 만들 때 일정이 겹치는 날이 가장 많은 곳의 개수와 같음 가로길이는 일정이 없는 날이 나오기 전까지 중복합을 해주고, 일정이 없는 날이 나올 시 중복합을 사용함 위 두 가지 조건을 이용해서 문제를 풀면되었기에, 우선 달력에 모든 일정들을 표기하는 작업을 먼저 했습니다. const [count, ...schedules] = fs .readFileSync(filePath) .toString() .trim() .split("\n"); const calendar = [...Array(365).fill(0)]; // 달력 내의 모든 값들을 0으로 우선 설정 schedules.forEach((schedule) =&gt; { // 각 일정마다 시작일부터 종료일까지 배열에 맞게 -1을 해주고 달력에 넣어줌 const [startDay, endDay] = schedule.split(" ").map((v) =&gt; +v); for (i = startDay - 1; i &lt;= endDay - 1; i += 1) { calendar[i] += 1; } }); 그리고 이렇게 설정된 달력을 통해서 가로, 세로, 넓이 합을 달력을 순회하면서 구해주도록 했습니다. calendar.forEach((count, index) =&gt; { // 달력의 마지막 날이며, 일정이 존재하는 경우 if (index === 365 - 1 &amp;&amp; count) { x += 1; if (count &gt; y) y = count; sum += x * y; return; } // 일정은 없으나 전날까지는 일정이 존재한 경우 if (!count &amp;&amp; x &amp;&amp; y) { sum += x * y; x = 0; y = 0; return; } // 일정이 있으나 이전에 일정이 없었던 경우 if (count &amp;&amp; !x) { x = 1; y = count; return; } // 일정이 이어지는 경우 if (count &amp;&amp; x) { x += 1; if (count &gt; y) y = count; } }); 해당 문제를 풀면서 예외처리를 제대로 해주지 못했던 것은 위 코드에서 가장 첫 조건식이었습니다. 일정이 끝나는 경우는 무조건 ‘일정이 없는 날이 나올 때’라고 고려를 해서 문제를 풀었으나, 달력의 마지막 날이 끝나는 경우에도 일정이 종료되기 때문에 이를 고려해 조건식을 추가했습니다. 기존에 생각했던 풀이 방식보다 새롭게 알게 된 풀이 방식이 훨씬 간단했고, 예외 조건도 잘 고려해주기만 하면 금방 풀 수 있는 문제였습니다. 문제 풀이와 예외 조건에 대한 고민이 더 필요하다는 것을 느꼈습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 10994번</title><link href="http://localhost:4000/algorithm/2022/11/19/10994/" rel="alternate" type="text/html" title="백준 10994번" /><published>2022-11-19T00:00:00+09:00</published><updated>2022-11-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/19/10994</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/19/10994/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/10994">QUESTION LINK</a></strong></p>

<p>예시와 같이 규칙성을 통해, 별을 찍어야 할 위치를 지정해 그려주면 되는 간단한 문제였습니다. 하지만, 처음에 문제에서 규칙성을 찾고 문제를 해결하는 데에 몇 가지 어려운 점이 있었습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*********
*       *
* ***** *
* *   * *
* * * * *
* *   * *
* ***** *
*       *
*********
</code></pre></div></div>

<p>첫 번째는 <strong>반복을 최대한 줄이는 방법</strong>이었습니다. 위의 형태에서 좌우, 상하 대칭인 점을 이용해, 가능한 적은 양의 연산을 하려고 했습니다. 여기서 필요했던 것이 아래 별들의 ‘전체의 길이’와 ‘절반까지의 길이’였습니다. 처음에 이 두 값이 필요하다는 것을 제대로 인지하지 못했고, 이로 인해 결론적으로 같은 계산을 하면 되는 상황들을 자꾸 다시 계산하는 문제가 생겼었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="o">+</span><span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// 처음에 주어진 값</span>
<span class="kd">const</span> <span class="nx">halfLength</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 절반의 값</span>
<span class="kd">const</span> <span class="nx">totalLength</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// 전체 길이의 값</span>
</code></pre></div></div>

<p>두 번째 어려웠던 점은 <strong>규칙성을 적용하는 방식</strong>이였습니다. 문제를 풀면서 처음부터 한 줄마다 배열을 만들고, 그 안에서도 순회를 돌며 별을 채우는 방식을 사용하고자 했었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">][(</span><span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">)]];</span>
<span class="c1">// 각 줄마다의 별을 각 index마다 그려주고 이를 합쳐주고자 함</span>
</code></pre></div></div>

<p>그런데 여기서 처음에 규칙성을 적용하고자 할 때 현재 방문한 줄의 index값(i)와 현재 방문한 정확한 지표의 index값(j)를 어떤 식으로 이어서 적용해야하는지 어려웠었는데, 오히려 i와 j의 값을 다른 계산없이 1:1로 비교를 해주면 된다는 것을 알게 됐습니다.</p>

<p>이를 통해, 아래와 같은 코드를 짤 수 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 결과가 모두 들어오는 배열</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">halfLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 절반만큼만 순회하고, 나머지 절반은 순회동안 채워줌</span>
  <span class="kd">const</span> <span class="nx">newLine</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 현재 방문한 줄의 배열</span>

  <span class="c1">// 현재 방문한 줄의 짝수, 홀수 여부에 따라 다른 규칙을 적용</span>
  <span class="c1">// totalLength - 1 - j의 값을 통해 현재 방문한 곳의 반대편도 같은 값을 넣어줌</span>
  <span class="c1">// i와 j의 비교만으로도 어떤 값을 넣을 지 지정이 가능함</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">halfLength</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">j</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span> <span class="p">?</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">marker</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">marker</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">halfLength</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">j</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">marker</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">marker</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
        <span class="nx">newLine</span><span class="p">[</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">resultArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newLine</span><span class="p">;</span>
  <span class="nx">resultArray</span><span class="p">[</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newLine</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">resultArray</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>이 문제를 풀면서 비록 쉬운 난이도의 문제여도, 정확하게 제게 <strong>필요한 값과 규칙성</strong>을 정리해놓지 못하면 풀이에 상당히 오랜 시간이 걸릴 수 있다는 것을 배울 수 있었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 예시와 같이 규칙성을 통해, 별을 찍어야 할 위치를 지정해 그려주면 되는 간단한 문제였습니다. 하지만, 처음에 문제에서 규칙성을 찾고 문제를 해결하는 데에 몇 가지 어려운 점이 있었습니다. ********* * * * ***** * * * * * * * * * * * * * * * ***** * * * ********* 첫 번째는 반복을 최대한 줄이는 방법이었습니다. 위의 형태에서 좌우, 상하 대칭인 점을 이용해, 가능한 적은 양의 연산을 하려고 했습니다. 여기서 필요했던 것이 아래 별들의 ‘전체의 길이’와 ‘절반까지의 길이’였습니다. 처음에 이 두 값이 필요하다는 것을 제대로 인지하지 못했고, 이로 인해 결론적으로 같은 계산을 하면 되는 상황들을 자꾸 다시 계산하는 문제가 생겼었습니다. const count = +input[0]; // 처음에 주어진 값 const halfLength = count * 2 - 1; // 절반의 값 const totalLength = 1 + (count - 1) * 4; // 전체 길이의 값 두 번째 어려웠던 점은 규칙성을 적용하는 방식이였습니다. 문제를 풀면서 처음부터 한 줄마다 배열을 만들고, 그 안에서도 순회를 돌며 별을 채우는 방식을 사용하고자 했었습니다. [["*", " ", "*"][("*", " ", "*")]]; // 각 줄마다의 별을 각 index마다 그려주고 이를 합쳐주고자 함 그런데 여기서 처음에 규칙성을 적용하고자 할 때 현재 방문한 줄의 index값(i)와 현재 방문한 정확한 지표의 index값(j)를 어떤 식으로 이어서 적용해야하는지 어려웠었는데, 오히려 i와 j의 값을 다른 계산없이 1:1로 비교를 해주면 된다는 것을 알게 됐습니다. 이를 통해, 아래와 같은 코드를 짤 수 있었습니다. const resultArray = []; // 결과가 모두 들어오는 배열 for (let i = 0; i &lt; halfLength; i++) { // 절반만큼만 순회하고, 나머지 절반은 순회동안 채워줌 const newLine = []; // 현재 방문한 줄의 배열 // 현재 방문한 줄의 짝수, 홀수 여부에 따라 다른 규칙을 적용 // totalLength - 1 - j의 값을 통해 현재 방문한 곳의 반대편도 같은 값을 넣어줌 // i와 j의 비교만으로도 어떤 값을 넣을 지 지정이 가능함 if (!(i % 2)) { for (let j = 0; j &lt; halfLength; j++) { if (!(j % 2)) { newLine[j] = "*"; newLine[totalLength - 1 - j] = "*"; } else { const marker = j &lt; i ? " " : "*"; newLine[j] = marker; newLine[totalLength - 1 - j] = marker; } } } else { for (let j = 0; j &lt; halfLength; j++) { if (!(j % 2)) { const marker = j &lt; i ? "*" : " "; newLine[j] = marker; newLine[totalLength - 1 - j] = marker; } else { newLine[j] = " "; newLine[totalLength - 1 - j] = " "; } } } resultArray[i] = newLine; resultArray[totalLength - 1 - i] = newLine; } const result = resultArray.map((v) =&gt; v.join("")).join("\n"); console.log(result); 이 문제를 풀면서 비록 쉬운 난이도의 문제여도, 정확하게 제게 필요한 값과 규칙성을 정리해놓지 못하면 풀이에 상당히 오랜 시간이 걸릴 수 있다는 것을 배울 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">React 개발 시 https 사용하기</title><link href="http://localhost:4000/react/2022/11/15/React-%EA%B0%9C%EB%B0%9C-%EC%8B%9C-https-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="React 개발 시 https 사용하기" /><published>2022-11-15T00:00:00+09:00</published><updated>2022-11-15T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/11/15/React%20%EA%B0%9C%EB%B0%9C%20%EC%8B%9C%20https%20%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/2022/11/15/React-%EA%B0%9C%EB%B0%9C-%EC%8B%9C-https-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"><![CDATA[<h3 id="https로-넘어가게-된-이유">https로 넘어가게 된 이유</h3>

<p>현재 개발 중인 앱을 배포하며, 기존에 http로 되어있던 api들을 https로 변경해주었습니다. 이에 따라 배포된 페이지는 https로 이루어져 api를 정상적으로 받아왔지만, 오히려 개발 중에는 http를 사용 중이어서 아래와 같은 에러가 나왔습니다.</p>

<p>사파리의 경우, SSL 오류로 인해 동작 자체가 멈추었고, 크롬에서는 기본적인 동작은 하나, api를 받아오는 단계를 진행하지 못하는 것을 볼 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/1.png" alt="" width="100%" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/2.png" alt="" width="100%" height="" /> 
</figure>

<p>기존에 개발을 진행할 때에는 CORS를 피하기 위해 http-proxy-middleware를 사용했습니다. 하지만, 현재 상황에서는 따로 이전과 같은 방법이 필요가 없다는 것을 알게 되었고, 현재 개발 환경 상에서 localhost를 https로 설정해주면 된다는 결론을 내렸습니다.</p>

<h3 id="packagejson-설정">package.json 설정</h3>

<p>기본적으로 http가 아닌 https로 개발 환경을 설정합니다. 아래와 같이 https로 이동할 수 있도록 합니다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HTTPS=true react-app-rewired start"</span><span class="p">,</span><span class="w">
  </span><span class="err">//</span><span class="w"> </span><span class="err">HTTPS를</span><span class="w"> </span><span class="err">적용</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<p>하지만, 아래와 같은 에러가 나오는 것을 볼 수 있는데, 이는 연결이 안전하지 않기 때문에 문제가 되어 에러가 나오는 것으로, 이를 해결하기 위해서 SSL 인증서를 만들어주어야 합니다. 여기서는 <code class="language-plaintext highlighter-rouge">mkcert</code>라는 것을 이용해 인증서를 만들었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/3.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="mkcert-사용하기">mkcert 사용하기</h3>

<p>인증서 생성을 위한 인증 기관을 만들기 위해 <code class="language-plaintext highlighter-rouge">mkcert</code>를 설치하게 됩니다. 아래 코드들을 통해서 설치할 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install mkcert
// brew로 mkcert 설치

mkcert -install
// mkcert를 컴퓨터에 설치
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/4.png" alt="" width="100%" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/5.png" alt="" width="100%" height="" /> 
</figure>

<p>그리고 현재 사용 중인 React의 root 디렉토리에 <code class="language-plaintext highlighter-rouge">.cert</code>라는 디렉토리를 만든 뒤, 내부에 인증서를 만들어 넣어줍니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p .cert
// .cert라는 디렉토리를 생성

mkcert -key-file ./.cert/key.pem -cert-file ./.cert/cert.pem "localhost"
// 인증서를 만들어 넣어줌.
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/6.png" alt="" width="100%" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/7.png" alt="" width="100%" height="" /> 
</figure>

<p>그리고 만들어진 디렉토리는 개발 단계에서만 사용되기 때문에, <code class="language-plaintext highlighter-rouge">.gitignore</code>로 커밋 제외해줍니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221115/8.png" alt="" width="100%" height="" /> 
</figure>

<p>마지막으로, React가 시작될 시, SSL 인증서를 포함하도록 하기 위해 아래와 같은 형식의 코드로 <code class="language-plaintext highlighter-rouge">package.json</code>에 작성합니다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HTTPS=true SSL_CRT_FILE=./.cert/cert.pem SSL_KEY_FILE=./.cert/key.pem react-app-rewired start"</span><span class="p">,</span><span class="w">
  </span><span class="err">//</span><span class="w"> </span><span class="err">CRT</span><span class="w"> </span><span class="err">FILE</span><span class="p">,</span><span class="w"> </span><span class="err">KEY</span><span class="w"> </span><span class="err">FILE을</span><span class="w"> </span><span class="err">갖고</span><span class="w"> </span><span class="err">실행하도록</span><span class="w"> </span><span class="err">설정</span><span class="w">
  </span><span class="err">...</span><span class="w">
</span><span class="p">}</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[https로 넘어가게 된 이유 현재 개발 중인 앱을 배포하며, 기존에 http로 되어있던 api들을 https로 변경해주었습니다. 이에 따라 배포된 페이지는 https로 이루어져 api를 정상적으로 받아왔지만, 오히려 개발 중에는 http를 사용 중이어서 아래와 같은 에러가 나왔습니다. 사파리의 경우, SSL 오류로 인해 동작 자체가 멈추었고, 크롬에서는 기본적인 동작은 하나, api를 받아오는 단계를 진행하지 못하는 것을 볼 수 있었습니다. 기존에 개발을 진행할 때에는 CORS를 피하기 위해 http-proxy-middleware를 사용했습니다. 하지만, 현재 상황에서는 따로 이전과 같은 방법이 필요가 없다는 것을 알게 되었고, 현재 개발 환경 상에서 localhost를 https로 설정해주면 된다는 결론을 내렸습니다. package.json 설정 기본적으로 http가 아닌 https로 개발 환경을 설정합니다. 아래와 같이 https로 이동할 수 있도록 합니다. "scripts": { "start": "HTTPS=true react-app-rewired start", // HTTPS를 적용 }, 하지만, 아래와 같은 에러가 나오는 것을 볼 수 있는데, 이는 연결이 안전하지 않기 때문에 문제가 되어 에러가 나오는 것으로, 이를 해결하기 위해서 SSL 인증서를 만들어주어야 합니다. 여기서는 mkcert라는 것을 이용해 인증서를 만들었습니다. mkcert 사용하기 인증서 생성을 위한 인증 기관을 만들기 위해 mkcert를 설치하게 됩니다. 아래 코드들을 통해서 설치할 수 있습니다. brew install mkcert // brew로 mkcert 설치 mkcert -install // mkcert를 컴퓨터에 설치 그리고 현재 사용 중인 React의 root 디렉토리에 .cert라는 디렉토리를 만든 뒤, 내부에 인증서를 만들어 넣어줍니다. mkdir -p .cert // .cert라는 디렉토리를 생성 mkcert -key-file ./.cert/key.pem -cert-file ./.cert/cert.pem "localhost" // 인증서를 만들어 넣어줌. 그리고 만들어진 디렉토리는 개발 단계에서만 사용되기 때문에, .gitignore로 커밋 제외해줍니다. 마지막으로, React가 시작될 시, SSL 인증서를 포함하도록 하기 위해 아래와 같은 형식의 코드로 package.json에 작성합니다. "scripts": { "start": "HTTPS=true SSL_CRT_FILE=./.cert/cert.pem SSL_KEY_FILE=./.cert/key.pem react-app-rewired start", // CRT FILE, KEY FILE을 갖고 실행하도록 설정 ... },]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 5547번</title><link href="http://localhost:4000/algorithm/2022/11/10/5547/" rel="alternate" type="text/html" title="백준 5547번" /><published>2022-11-10T00:00:00+09:00</published><updated>2022-11-10T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/10/5547</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/10/5547/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/5547">QUESTION LINK</a></strong></p>

<p>집을 감싸는 부분의 길이와 내부의 비어있는 곳의 길이를 각각 BFS로 구해야하는 문제였습니다. 풀이의 순서는 아래와 같습니다.</p>

<ol>
  <li>인접한 집들의 길이의 합 구하기 (내부에 빈 공간과 접한 곳의 길이도 포함)</li>
  <li>인접한 집들의 길이의 합 구할 때 비어있는 공간들의 좌표 구하기</li>
  <li>빈 공간 좌표들을 통해 빈 공간들 중 집 내부에 속하는 부분들의 길이 구하기</li>
  <li>인접한 집들의 길이 합 - 집 내부에 속하는 부분들의 길이</li>
</ol>

<p>처음에 1, 2번의 계산 과정을 진행하기 위해, 기존 BFS를 적용하던 방식대로 BFS를 통해 길이들을 구해주고자 했습니다. 이 때, 육각형의 집이기 때문에 BFS를 하면서 총 6군데의 인접한 곳들을 확인하고 넘어가는 방식으로 진행했습니다. 그리고, 집과 빈 공간(좌표를 갖고 있는)이 만나는 지점에 대해서 길이를 1씩 추가하도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">W</span><span class="p">,</span> <span class="nx">H</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">v</span><span class="p">);</span>
<span class="c1">// W는 너비, H는 높이</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// 그래프 변수</span>
<span class="kd">const</span> <span class="nx">visitedWhenLines</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// check houses</span>
<span class="c1">// 집의 둘레를 구할 때 방문 여부를 확인하기 위한 객체</span>
<span class="kd">const</span> <span class="nx">visitedWhenEmtpy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
<span class="c1">// 빈 곳들 중 집 내부에 속한 곳을 구할 때 방문 여부를 확인하기 위한 Set</span>
<span class="kd">const</span> <span class="nx">aroundChangesWithZero</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">];</span> <span class="c1">// 줄의 index가 짝수인 경우에 대한 주변 변경 좌표들</span>
<span class="kd">const</span> <span class="nx">aroundChangesWithOne</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">];</span> <span class="c1">// 줄의 index가 홀수인 경우에 대한 주변 환경 좌표들</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// visited에 key값으로서 활용하기 위한 마커 생성</span>

<span class="kd">const</span> <span class="nx">queueWhenLines</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 집 둘레를 구할 때 사용할 queue</span>
<span class="kd">const</span> <span class="nx">firstMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// 초기 값은 좌표(0,0)으로 설정</span>
<span class="nx">visitedWhenLines</span><span class="p">[</span><span class="nx">firstMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">queueWhenLines</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">firstMarker</span><span class="p">);</span>
<span class="c1">// queue에 초기값을 담아줌</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">graphBoxes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="nx">visitedWhenEmtpy</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">firstMarker</span><span class="p">);</span>
<span class="c1">// 방문한 곳이 비어있는 곳일 때, 추후 집 내부를 확인 시 사용할 visited Set에 마커를 담아줌</span>

<span class="kd">let</span> <span class="nx">curHouse</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">curIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">totalLines</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">emptyLines</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// while 문을 돌면서 queue 내에 있는 것들을 확인해 BFS를 진행함</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">queueWhenLines</span><span class="p">[</span><span class="nx">curIndex</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">curHouse</span> <span class="o">=</span> <span class="nx">queueWhenLines</span><span class="p">[</span><span class="nx">curIndex</span><span class="p">];</span>
  <span class="nx">curIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curHouse</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">v</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">aroundChanges</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">?</span> <span class="nx">aroundChangesWithOne</span> <span class="p">:</span> <span class="nx">aroundChangesWithZero</span><span class="p">;</span>
  <span class="c1">// 높이가 짝수, 홀수인 경우에 다른 방향값을 가져옴</span>
  <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

  <span class="nx">aroundChanges</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">dy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 각각의 방향값에 따른 처리 진행</span>
    <span class="kd">const</span> <span class="nx">aroundY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">aroundX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">aroundY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">aroundY</span> <span class="o">&gt;=</span> <span class="nx">H</span> <span class="o">||</span> <span class="nx">aroundX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">aroundX</span> <span class="o">&gt;=</span> <span class="nx">W</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 값이 존재하지 않는 경우 집이 외부와 닿는 것이므로 길이를 1추가</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">totalLines</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">aroundValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">aroundY</span><span class="p">][</span><span class="nx">aroundX</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="nx">aroundValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="nx">totalLines</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 집이 빈 곳과 맞닿는 경우 길이 1추가</span>

    <span class="kd">const</span> <span class="nx">aroundMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">aroundY</span><span class="p">,</span> <span class="nx">aroundX</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visitedWhenLines</span><span class="p">[</span><span class="nx">aroundMarker</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// 방문하지 않은 곳에 대해서만 queue를 넣어 처리 진행</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">aroundValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="nx">visitedWhenEmtpy</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">aroundMarker</span><span class="p">);</span>
      <span class="c1">// 빈 곳에 대한 추후 처리를 위해 visited Set에 추가</span>
      <span class="nx">visitedWhenLines</span><span class="p">[</span><span class="nx">aroundMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 방문했음을 표기하고 queue에 추가</span>
      <span class="nx">queueWhenLines</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">aroundMarker</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드를 통해, 아래와 같은 Set 값을 얻을 수 있게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Set</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
  <span class="dl">'</span><span class="s1">0,0</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">1,0</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">0,2</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">2,1</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">1,3</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">3,0</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">0,4</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">1,4</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">2,3</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">3,3</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">1,6</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">3,5</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">1,7</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">3,7</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 Set값을 통해 다음으로 진행할 것은 집 내부에 속한 곳을 찾아내는 것입니다. 이 부분에서 계산의 순서는 아래와 같습니다.</p>

<ol>
  <li>구해진 Set을 순회하며 빈 곳들과 연결된 다른 빈 곳들을 따라 들어가는 BFS를 만듬</li>
  <li>빈 곳과 연결된 좌표에 집이 있을 시 길이를 1씩 늘림</li>
  <li>빈 곳과 연결된 좌표가 비어있을 시(외부인 경우) 해당 빈 곳으로부터 시작한 BFS의 모든 길이값은 무효화함</li>
  <li>무효화되지 않은 길이들의 총합을 구함</li>
</ol>

<p>이 때, 순회를 돌면서 방문한 곳들은 다음 순회 시 방문할 필요가 없기 때문에 Set에서 <code class="language-plaintext highlighter-rouge">delete</code>하는 작업을 해줍니다. 이를 위해서 Set이라는 자료 구조를 사용했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 빈 곳들의 모임으로부터 순회를 시작함</span>
<span class="nx">visitedWhenEmtpy</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">marker</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">house</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">marker</span><span class="p">);</span>

  <span class="c1">// queue 순회를 돌면서 연결된 곳들을 계속 탐색함</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">house</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="nx">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">house</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">v</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">aroundChanges</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">?</span> <span class="nx">aroundChangesWithOne</span> <span class="p">:</span> <span class="nx">aroundChangesWithZero</span><span class="p">;</span>
    <span class="c1">// 주변의 요소들의 값들을 확인함</span>
    <span class="nx">aroundChanges</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">dy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">aroundY</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">aroundX</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">;</span>
      <span class="c1">// 주변 요소가 외부일 경우, 해당 BFS는 집 내부에 속한 것이 아니므로 line값을 무효화함</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">aroundY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">aroundY</span> <span class="o">&gt;=</span> <span class="nx">H</span> <span class="o">||</span> <span class="nx">aroundX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">aroundX</span> <span class="o">&gt;=</span> <span class="nx">W</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">line</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">aroundValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">aroundY</span><span class="p">][</span><span class="nx">aroundX</span><span class="p">];</span>
      <span class="c1">// 주변 요소가 같은 비어있는 곳일 경우, Set에서는 해당 값을 순회할 필요가 없으므로 지워주고, queue에 담아줌</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">aroundValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">aroundMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">aroundY</span><span class="p">,</span> <span class="nx">aroundX</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">aroundMarker</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">visitedWhenEmtpy</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">aroundMarker</span><span class="p">);</span>
          <span class="nx">visited</span><span class="p">[</span><span class="nx">aroundMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">aroundMarker</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 주변에 집이 있는 경우, line값을 증가함</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">aroundValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">line</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// 모든 line값들을 더함</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">line</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">emptyLines</span> <span class="o">+=</span> <span class="nx">line</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 기존의 집 주변 값에서 내부 값을 빼어 결과를 구함</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">totalLines</span> <span class="o">-</span> <span class="nx">emptyLines</span><span class="p">;</span>
</code></pre></div></div>

<p>위와 같은 과정을 진행하면서, 가장 큰 어려움을 느꼈던 부분은 순회를 두 번 돌아야 하는 지에 대한 판단을 제대로 하지 못한 것이었습니다. 처음에 집 주변 값(<code class="language-plaintext highlighter-rouge">totalLines</code>)을 구하는 것에는 문제가 없었으나, 집 내부의 빈 곳의 길이(<code class="language-plaintext highlighter-rouge">emptyLines</code>)를 구하는 것에서는 다시 한 번 순회를 돌아야하는 지에 대해 판단하지 못했는데, <strong>미리 빈 곳들의 좌표를 구해놓고, 이를 Set을 통해 최소한 돌도록 처리해주는 부분</strong>이 이번 알고리즘에서 가장 빠르게 문제를 해결하는 데에 도움을 주었던 요소였습니다.</p>

<p>그리고, 문제를 풀며 마지막에 계속해서 해결하지 못했던 한 부분이 있었는데, 이는 아래 코드와 같이 초기 BFS 설정을 할 때, 제대로 queue에 값을 배치해주지 못하는 사소한 부분에서의 문제였습니다. 이러한 실수를 줄이기 위해 미리 확실한 변수를 설정하고 배열에 push의 형태로 대입해주는 것이 안전하다는 것을 느꼈습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">house</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">house</span><span class="p">];</span>
<span class="c1">// queue에 marker의 형태로 값이 들어와야 하는데 잘못된 값을 넣어서</span>
<span class="c1">// 초기에 undefined를 갖고 처리를 진행하는 문제가 발생함</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 집을 감싸는 부분의 길이와 내부의 비어있는 곳의 길이를 각각 BFS로 구해야하는 문제였습니다. 풀이의 순서는 아래와 같습니다. 인접한 집들의 길이의 합 구하기 (내부에 빈 공간과 접한 곳의 길이도 포함) 인접한 집들의 길이의 합 구할 때 비어있는 공간들의 좌표 구하기 빈 공간 좌표들을 통해 빈 공간들 중 집 내부에 속하는 부분들의 길이 구하기 인접한 집들의 길이 합 - 집 내부에 속하는 부분들의 길이 처음에 1, 2번의 계산 과정을 진행하기 위해, 기존 BFS를 적용하던 방식대로 BFS를 통해 길이들을 구해주고자 했습니다. 이 때, 육각형의 집이기 때문에 BFS를 하면서 총 6군데의 인접한 곳들을 확인하고 넘어가는 방식으로 진행했습니다. 그리고, 집과 빈 공간(좌표를 갖고 있는)이 만나는 지점에 대해서 길이를 1씩 추가하도록 했습니다. const [numbers, ...graph] = input; const [W, H] = numbers.split(" ").map((v) =&gt; +v); // W는 너비, H는 높이 const graphBoxes = graph.map((line) =&gt; line.split(" ")); // 그래프 변수 const visitedWhenLines = {}; // check houses // 집의 둘레를 구할 때 방문 여부를 확인하기 위한 객체 const visitedWhenEmtpy = new Set(); // 빈 곳들 중 집 내부에 속한 곳을 구할 때 방문 여부를 확인하기 위한 Set const aroundChangesWithZero = [ [-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1], ]; // 줄의 index가 짝수인 경우에 대한 주변 변경 좌표들 const aroundChangesWithOne = [ [-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0], ]; // 줄의 index가 홀수인 경우에 대한 주변 환경 좌표들 const getMarker = (y, x) =&gt; `${y},${x}`; // visited에 key값으로서 활용하기 위한 마커 생성 const queueWhenLines = []; // 집 둘레를 구할 때 사용할 queue const firstMarker = getMarker(0, 0); // 초기 값은 좌표(0,0)으로 설정 visitedWhenLines[firstMarker] = true; queueWhenLines.push(firstMarker); // queue에 초기값을 담아줌 if (graphBoxes[0][0] === "0") visitedWhenEmtpy.add(firstMarker); // 방문한 곳이 비어있는 곳일 때, 추후 집 내부를 확인 시 사용할 visited Set에 마커를 담아줌 let curHouse; let curIndex = 0; let totalLines = 0; let emptyLines = 0; // while 문을 돌면서 queue 내에 있는 것들을 확인해 BFS를 진행함 while (queueWhenLines[curIndex]) { curHouse = queueWhenLines[curIndex]; curIndex += 1; const [y, x] = curHouse.split(",").map((v) =&gt; +v); const aroundChanges = y % 2 ? aroundChangesWithOne : aroundChangesWithZero; // 높이가 짝수, 홀수인 경우에 다른 방향값을 가져옴 const curValue = graphBoxes[y][x]; aroundChanges.forEach(([dy, dx]) =&gt; { // 각각의 방향값에 따른 처리 진행 const aroundY = y + dy; const aroundX = x + dx; if (aroundY &lt; 0 || aroundY &gt;= H || aroundX &lt; 0 || aroundX &gt;= W) { // 값이 존재하지 않는 경우 집이 외부와 닿는 것이므로 길이를 1추가 if (curValue === "1") totalLines += 1; return; } const aroundValue = graphBoxes[aroundY][aroundX]; if (curValue === "1" &amp;&amp; aroundValue === "0") totalLines += 1; // 집이 빈 곳과 맞닿는 경우 길이 1추가 const aroundMarker = getMarker(aroundY, aroundX); if (!visitedWhenLines[aroundMarker]) { // 방문하지 않은 곳에 대해서만 queue를 넣어 처리 진행 if (aroundValue === "0") visitedWhenEmtpy.add(aroundMarker); // 빈 곳에 대한 추후 처리를 위해 visited Set에 추가 visitedWhenLines[aroundMarker] = true; // 방문했음을 표기하고 queue에 추가 queueWhenLines.push(aroundMarker); } }); } 위 코드를 통해, 아래와 같은 Set 값을 얻을 수 있게 됩니다. Set(14) { '0,0', '1,0', '0,2', '2,1', '1,3', '3,0', '0,4', '1,4', '2,3', '3,3', '1,6', '3,5', '1,7', '3,7' } 이 Set값을 통해 다음으로 진행할 것은 집 내부에 속한 곳을 찾아내는 것입니다. 이 부분에서 계산의 순서는 아래와 같습니다. 구해진 Set을 순회하며 빈 곳들과 연결된 다른 빈 곳들을 따라 들어가는 BFS를 만듬 빈 곳과 연결된 좌표에 집이 있을 시 길이를 1씩 늘림 빈 곳과 연결된 좌표가 비어있을 시(외부인 경우) 해당 빈 곳으로부터 시작한 BFS의 모든 길이값은 무효화함 무효화되지 않은 길이들의 총합을 구함 이 때, 순회를 돌면서 방문한 곳들은 다음 순회 시 방문할 필요가 없기 때문에 Set에서 delete하는 작업을 해줍니다. 이를 위해서 Set이라는 자료 구조를 사용했습니다. // 빈 곳들의 모임으로부터 순회를 시작함 visitedWhenEmtpy.forEach((marker) =&gt; { const queue = []; const visited = {}; let index = 0; let house; let line = 0; visited[marker] = true; queue.push(marker); // queue 순회를 돌면서 연결된 곳들을 계속 탐색함 while (queue[index]) { house = queue[index]; index += 1; const [y, x] = house.split(",").map((v) =&gt; +v); const aroundChanges = y % 2 ? aroundChangesWithOne : aroundChangesWithZero; // 주변의 요소들의 값들을 확인함 aroundChanges.forEach(([dy, dx]) =&gt; { const aroundY = y + dy; const aroundX = x + dx; // 주변 요소가 외부일 경우, 해당 BFS는 집 내부에 속한 것이 아니므로 line값을 무효화함 if (aroundY &lt; 0 || aroundY &gt;= H || aroundX &lt; 0 || aroundX &gt;= W) { line = undefined; return; } const aroundValue = graphBoxes[aroundY][aroundX]; // 주변 요소가 같은 비어있는 곳일 경우, Set에서는 해당 값을 순회할 필요가 없으므로 지워주고, queue에 담아줌 if (aroundValue === "0") { const aroundMarker = getMarker(aroundY, aroundX); if (!visited[aroundMarker]) { visitedWhenEmtpy.delete(aroundMarker); visited[aroundMarker] = true; queue.push(aroundMarker); } } // 주변에 집이 있는 경우, line값을 증가함 if (aroundValue === "1") line += 1; }); } // 모든 line값들을 더함 if (line &gt;= 0) emptyLines += line; }); // 기존의 집 주변 값에서 내부 값을 빼어 결과를 구함 const result = totalLines - emptyLines; 위와 같은 과정을 진행하면서, 가장 큰 어려움을 느꼈던 부분은 순회를 두 번 돌아야 하는 지에 대한 판단을 제대로 하지 못한 것이었습니다. 처음에 집 주변 값(totalLines)을 구하는 것에는 문제가 없었으나, 집 내부의 빈 곳의 길이(emptyLines)를 구하는 것에서는 다시 한 번 순회를 돌아야하는 지에 대해 판단하지 못했는데, 미리 빈 곳들의 좌표를 구해놓고, 이를 Set을 통해 최소한 돌도록 처리해주는 부분이 이번 알고리즘에서 가장 빠르게 문제를 해결하는 데에 도움을 주었던 요소였습니다. 그리고, 문제를 풀며 마지막에 계속해서 해결하지 못했던 한 부분이 있었는데, 이는 아래 코드와 같이 초기 BFS 설정을 할 때, 제대로 queue에 값을 배치해주지 못하는 사소한 부분에서의 문제였습니다. 이러한 실수를 줄이기 위해 미리 확실한 변수를 설정하고 배열에 push의 형태로 대입해주는 것이 안전하다는 것을 느꼈습니다. const visited = {}; let index = 0; let house; let line = 0; visited[marker] = true; const queue = [house]; // queue에 marker의 형태로 값이 들어와야 하는데 잘못된 값을 넣어서 // 초기에 undefined를 갖고 처리를 진행하는 문제가 발생함]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 7576번</title><link href="http://localhost:4000/algorithm/2022/11/09/7576/" rel="alternate" type="text/html" title="백준 7576번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/7576</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/7576/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/7576">QUESTION LINK</a></strong></p>

<p>익은 토마토가 위치한 곳에서 한 번씩 BFS를 시행해, 하루가 지날 때마다 근처 토마토가 익은 것으로 만드는 형식을 적용하고자 했습니다. 즉, 이를 위해서 익은 토마토가 있는 위치 ‘1’ 좌표를 찾아내고, 이 곳에서 BFS가 순차적으로 발생하는 것으로 하고자 구상했습니다. 생각한 순서는 아래와 같습니다.</p>

<ol>
  <li>모든 익은 토마토(’1’)의 좌표 구하기</li>
  <li>하루가 지날 때마다(<code class="language-plaintext highlighter-rouge">day+=1;</code>) 익은 토마토의 좌표로부터 근접한 덜 익은 토마토(’0’)의 값을 ‘1’로 바꾸기</li>
  <li>다음 하루가 지날 때마다 2번과 같은 과정 반복하기</li>
  <li>인접한 곳에 덜 익은 토마토(’0’)가 없을 시 과정 중단하기</li>
</ol>

<h3 id="성공은-했으나-시간-초과">성공은 했으나 시간 초과</h3>

<p>이를 위해, 아래와 같은 코드를 구상했으며, 이를 통해 순차적으로 토마토가 익는 과정을 그려낼 수 있었습니다. 하지만, <strong>시간 초과</strong>가 발생해, 추가적인 수정이 필요했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 첫 익은 토마토가 있는 위치를 받음</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// queue에 들어갈 형태를 만드는 함수</span>

<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// 익은 토마토가 있을 경우, queue 배열에 담아줌</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문 여부를 나타내는 객체</span>
<span class="kd">let</span> <span class="nx">day</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 날짜를 나타냄. 하루가 지나는 것을 확인할 때마다 1씩 오름</span>
<span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>
<span class="c1">// 반복문에서 현재의 위치를 나타내는 값</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
  <span class="c1">// queue에서 가장 처음 요소를 가져와, BFS로 순환하도록 함</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
  <span class="c1">// 좌표 및 날짜를 가져옴</span>
  <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">-1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 방문하지 않았고, 토마토가 있는 경우에만 추가 작업 시행함</span>
    <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="c1">// 방문했음을 표기</span>
    <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">;</span>
    <span class="c1">// 토마토가 있었다는 표기</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">day</span> <span class="o">&lt;</span> <span class="nx">curDay</span><span class="p">)</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">curDay</span><span class="p">;</span>
    <span class="c1">// 현재 설정된 날짜보다 많은 날짜가 지나갔을 시, 그 날짜로 수정</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">curDay</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="c1">// 주변 토마토들을 체크하기 위해 날짜가 하루 더해진 값(curDay + 1)을 대입함</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">isFailed</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// 모든 토마토가 순환한 후, 방문하지 못한 곳이 존재할 시 -1로 변경</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isFailed</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="nx">day</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="시간-초과-원인-제거하기">시간 초과 원인 제거하기</h3>

<p>이 코드에서 시간 초과가 나오게 된 원인 중 하나로, <code class="language-plaintext highlighter-rouge">queue.shift()</code> 부분이 있으며, 이 부분은 <code class="language-plaintext highlighter-rouge">index</code>로 받아 처리하는 방법으로 해결이 가능했습니다. 그리고 다른 원인 중 하나는 위 코드에서 일단 방문한 적이 있는 지를 확인하고 추가적인 작업을 하는게 아니라, 우선 <code class="language-plaintext highlighter-rouge">queue</code>에 담은 뒤, 추가 작업에서 방문 여부를 확인하고 진행하도록 설정이 되어있었습니다. 이로 인해 불필요한 작업이 반복되는 경우가 많아져, 이 부분들을 모두 제외하고 코드를 수정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">toString</span><span class="p">().</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">m</span><span class="p">,</span> <span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">value</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 주변 좌표로 넘어가는 부분의 중복을 없애기 위해 만든 위치 변수들</span>
<span class="kd">const</span> <span class="nx">positionValue</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">];</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// 이전과 달라진 부분. 좌표와 날짜를 받고, 이상이 없을 시 queue에 들어가도록 설정함</span>
<span class="kd">const</span> <span class="nx">checkPosition</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">&gt;=</span> <span class="nx">m</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">day</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">};</span>

<span class="c1">// 이전과 달리, queue에 들어가기 전 방문 여부를 체크해 중복 확인이 발생하지 않도록 함</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">let</span> <span class="nx">targetIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">day</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

<span class="c1">// 기존에 queue에서 직접 빼던 방식과 달리, queue내에서 index를 통해 빼낸 것과 동일한 효과로 필요한 값들을 꺼냄</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">[</span><span class="nx">targetIdx</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">targetIdx</span><span class="p">];</span>
  <span class="nx">targetIdx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">+</span><span class="nx">value</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">-1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">day</span> <span class="o">&lt;</span> <span class="nx">curDay</span><span class="p">)</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">curDay</span><span class="p">;</span>
    <span class="c1">// 주변 위치로 이동하도록 설정하는 부분</span>
    <span class="nx">positionValue</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">dy</span><span class="p">,</span> <span class="nx">dx</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">checkPosition</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">curDay</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">isFailed</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">some</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">some</span><span class="p">((</span><span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isFailed</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="nx">day</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>🔎 <strong>위와 같이 수정을 하여, 백준에서 통과를 하기는 했습니다. 하지만, 이 코드의 경우에도 시간이 상당히 오래 걸려 통과가 됐기 때문에 가능하다면 자바스크립트에서 더 빠르게 처리하는 코드를 찾아보아야 합니다.</strong></p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 익은 토마토가 위치한 곳에서 한 번씩 BFS를 시행해, 하루가 지날 때마다 근처 토마토가 익은 것으로 만드는 형식을 적용하고자 했습니다. 즉, 이를 위해서 익은 토마토가 있는 위치 ‘1’ 좌표를 찾아내고, 이 곳에서 BFS가 순차적으로 발생하는 것으로 하고자 구상했습니다. 생각한 순서는 아래와 같습니다. 모든 익은 토마토(’1’)의 좌표 구하기 하루가 지날 때마다(day+=1;) 익은 토마토의 좌표로부터 근접한 덜 익은 토마토(’0’)의 값을 ‘1’로 바꾸기 다음 하루가 지날 때마다 2번과 같은 과정 반복하기 인접한 곳에 덜 익은 토마토(’0’)가 없을 시 과정 중단하기 성공은 했으나 시간 초과 이를 위해, 아래와 같은 코드를 구상했으며, 이를 통해 순차적으로 토마토가 익는 과정을 그려낼 수 있었습니다. 하지만, 시간 초과가 발생해, 추가적인 수정이 필요했습니다. const [numbers, ...graph] = input; const [m, n] = numbers.split(" ").map((value) =&gt; Number(value)); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const queue = []; // 첫 익은 토마토가 있는 위치를 받음 const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, day) =&gt; `${getMarker(y, x)},${day}`; // queue에 들어갈 형태를 만드는 함수 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "1") queue.push(getQueueItem(lineIndex, boxIndex, 0)); // 익은 토마토가 있을 경우, queue 배열에 담아줌 }); }); const visited = {}; // 방문 여부를 나타내는 객체 let day = 0; // 날짜를 나타냄. 하루가 지나는 것을 확인할 때마다 1씩 오름 let curItem; // 반복문에서 현재의 위치를 나타내는 값 while (queue.length) { curItem = queue.shift(); // queue에서 가장 처음 요소를 가져와, BFS로 순환하도록 함 const [y, x, curDay] = curItem.split(",").map((value) =&gt; Number(value)); // 좌표 및 날짜를 가져옴 const curValue = graphBoxes[y][x]; const curMarker = getMarker(y, x); if (!visited[curMarker] &amp;&amp; curValue !== "-1") { // 방문하지 않았고, 토마토가 있는 경우에만 추가 작업 시행함 visited[curMarker] = true; // 방문했음을 표기 graphBoxes[y][x] = "1"; // 토마토가 있었다는 표기 if (day &lt; curDay) day = curDay; // 현재 설정된 날짜보다 많은 날짜가 지나갔을 시, 그 날짜로 수정 if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, curDay + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, curDay + 1)); if (y + 1 &lt; n) queue.push(getQueueItem(y + 1, x, curDay + 1)); if (x + 1 &lt; m) queue.push(getQueueItem(y, x + 1, curDay + 1)); // 주변 토마토들을 체크하기 위해 날짜가 하루 더해진 값(curDay + 1)을 대입함 } } const isFailed = !!graphBoxes.find((line) =&gt; line.find((box) =&gt; box === "0")); // 모든 토마토가 순환한 후, 방문하지 못한 곳이 존재할 시 -1로 변경 const result = isFailed ? -1 : day; console.log(result); 시간 초과 원인 제거하기 이 코드에서 시간 초과가 나오게 된 원인 중 하나로, queue.shift() 부분이 있으며, 이 부분은 index로 받아 처리하는 방법으로 해결이 가능했습니다. 그리고 다른 원인 중 하나는 위 코드에서 일단 방문한 적이 있는 지를 확인하고 추가적인 작업을 하는게 아니라, 우선 queue에 담은 뒤, 추가 작업에서 방문 여부를 확인하고 진행하도록 설정이 되어있었습니다. 이로 인해 불필요한 작업이 반복되는 경우가 많아져, 이 부분들을 모두 제외하고 코드를 수정했습니다. const input = fs.readFileSync(filePath).toString().trim().split("\n"); const [numbers, ...graph] = input; const [m, n] = numbers.split(" ").map((value) =&gt; +value); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const queue = []; const visited = {}; // 주변 좌표로 넘어가는 부분의 중복을 없애기 위해 만든 위치 변수들 const positionValue = [ [-1, 0], [1, 0], [0, -1], [0, 1], ]; const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, day) =&gt; `${getMarker(y, x)},${day}`; // 이전과 달라진 부분. 좌표와 날짜를 받고, 이상이 없을 시 queue에 들어가도록 설정함 const checkPosition = (y, x, day) =&gt; { if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) return; const marker = getMarker(y, x); if (visited[marker]) return; visited[marker] = true; queue.push(getQueueItem(y, x, day + 1)); }; // 이전과 달리, queue에 들어가기 전 방문 여부를 체크해 중복 확인이 발생하지 않도록 함 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "1") { visited[getMarker(lineIndex, boxIndex)] = true; queue.push(getQueueItem(lineIndex, boxIndex, 0)); } }); }); let targetIdx = 0; let day = 0; let curItem; // 기존에 queue에서 직접 빼던 방식과 달리, queue내에서 index를 통해 빼낸 것과 동일한 효과로 필요한 값들을 꺼냄 while (queue[targetIdx]) { curItem = queue[targetIdx]; targetIdx += 1; const [y, x, curDay] = curItem.split(",").map((value) =&gt; +value); const curValue = graphBoxes[y][x]; if (curValue !== "-1") { graphBoxes[y][x] = "1"; if (day &lt; curDay) day = curDay; // 주변 위치로 이동하도록 설정하는 부분 positionValue.forEach(([dy, dx]) =&gt; checkPosition(y + dy, x + dx, curDay)); } } const isFailed = !!graphBoxes.some((line) =&gt; line.some((box) =&gt; box === "0")); const result = isFailed ? -1 : day; console.log(result); 🔎 위와 같이 수정을 하여, 백준에서 통과를 하기는 했습니다. 하지만, 이 코드의 경우에도 시간이 상당히 오래 걸려 통과가 됐기 때문에 가능하다면 자바스크립트에서 더 빠르게 처리하는 코드를 찾아보아야 합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 2667번</title><link href="http://localhost:4000/algorithm/2022/11/09/2667/" rel="alternate" type="text/html" title="백준 2667번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/2667</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/2667/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/2667">QUESTION LINK</a></strong></p>

<p>그래프 순회를 이용해 해결해야하는 문제였습니다. 문제를 해결하기 위해 일종의 흐름을 짜는 과정이 필요했는데 그 과정은 아래와 같았습니다.</p>

<ol>
  <li>그래프의 각 부분들(여기서는 <code class="language-plaintext highlighter-rouge">box</code>라는 이름으로 설정)을 순회하면서 그 값이 0인지 1인지를 확인</li>
  <li><code class="language-plaintext highlighter-rouge">box</code>의 값이 1인 경우, 해당 <code class="language-plaintext highlighter-rouge">box</code>의 방문 여부를 <code class="language-plaintext highlighter-rouge">true</code>로 설정함</li>
  <li>상하좌우의 <code class="language-plaintext highlighter-rouge">box</code>들을 따라 들어가, 2번과 같은 과정을 반복함</li>
</ol>

<p>위 순서를 따르기 위해 가장 먼저 필요한 것은 해당 그래프를 순회하는 과정을 만드는 것이었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">N</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">countArray</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 각 단지의 개수를 담아두기 위한 배열</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문여부를 확인하기 위한 객체</span>

<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 그래프의 각 라인마다 박스들을 확인함</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">checkBox</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">);</span>
    <span class="c1">// 각 박스마다 그 박스의 값과 방문여부를 확인하는 함수 생성 필요!</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="c1">// graphBoxes의 형태</span>
<span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
</code></pre></div></div>

<p>위 코드에서 보시다시피, 순회를 돌면서 각 위치(<code class="language-plaintext highlighter-rouge">lineIndex</code>, <code class="language-plaintext highlighter-rouge">boxIndex</code>)와 값(<code class="language-plaintext highlighter-rouge">box</code>)에 따라 처리를 해 줄 함수 <code class="language-plaintext highlighter-rouge">checkBox</code>가 필요했습니다. 이 함수는 각 박스의 순회 여부를 결정하고, 순회를 해야하는 경우 상하좌우를 DFS를 통해 순회하도록 설정해야 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// visited 객체의 key값을 만들기 위해 필요한 함수</span>

<span class="kd">const</span> <span class="nx">checkBox</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// y(lineIndex), x(boxIndex), box 값을 받아옴</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// box가 0인 경우 아파트가 없으므로 작업을 종료</span>
  <span class="kd">const</span> <span class="nx">marker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
  <span class="c1">// key값으로 사용될 marker 생성</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">marker</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 이미 방문했을 경우 작업을 종료</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">marker</span><span class="p">];</span>
  <span class="c1">// 첫 값으로 만들어진 marker를 담은 queue 생성</span>
  <span class="kd">let</span> <span class="nx">curMarker</span><span class="p">;</span>
  <span class="c1">// 반복문을 돌면서 목표 지점이 될 marker</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 해당 함수의 시작지점으로부터 얼마나 아파트를 돌았는지 확인하기 위한 변수</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="c1">// 목표지점으로 사용될 marker를 설정</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curMarker</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 몇 번째 줄, 몇 번째 box인지를 알아냄</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 방문하지 않은 값이 "1"인 box들일 경우에만 작업을 진행함</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 방문을 하는 상황으로 설정</span>
      <span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">// 상하좌우를 돌면서 queue에 넣어줌</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="nx">countArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위 함수를 통해서 반복 작업 시 <code class="language-plaintext highlighter-rouge">box</code>가 <strong>방문하지 않은 ‘1’인 경우에만</strong> 그래프 순회를 통해 개수 세기를 진행하도록 할 수 있었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 그래프 순회를 이용해 해결해야하는 문제였습니다. 문제를 해결하기 위해 일종의 흐름을 짜는 과정이 필요했는데 그 과정은 아래와 같았습니다. 그래프의 각 부분들(여기서는 box라는 이름으로 설정)을 순회하면서 그 값이 0인지 1인지를 확인 box의 값이 1인 경우, 해당 box의 방문 여부를 true로 설정함 상하좌우의 box들을 따라 들어가, 2번과 같은 과정을 반복함 위 순서를 따르기 위해 가장 먼저 필요한 것은 해당 그래프를 순회하는 과정을 만드는 것이었습니다. const [N, ...graph] = input; const graphBoxes = graph.map((line) =&gt; line.split("")); const countArray = []; // 각 단지의 개수를 담아두기 위한 배열 const visited = {}; // 방문여부를 확인하기 위한 객체 graphBoxes.forEach((line, lineIndex) =&gt; { // 그래프의 각 라인마다 박스들을 확인함 line.forEach((box, boxIndex) =&gt; { checkBox(lineIndex, boxIndex, box); // 각 박스마다 그 박스의 값과 방문여부를 확인하는 함수 생성 필요! }); }); // graphBoxes의 형태 [ ["0", "1", "1", "0", "1", "0", "0"], ["0", "1", "1", "0", "1", "0", "1"], ["1", "1", "1", "0", "1", "0", "1"], ["0", "0", "0", "0", "1", "1", "1"], ["0", "1", "0", "0", "0", "0", "0"], ["0", "1", "1", "1", "1", "1", "0"], ["0", "1", "1", "1", "0", "0", "0"], ]; 위 코드에서 보시다시피, 순회를 돌면서 각 위치(lineIndex, boxIndex)와 값(box)에 따라 처리를 해 줄 함수 checkBox가 필요했습니다. 이 함수는 각 박스의 순회 여부를 결정하고, 순회를 해야하는 경우 상하좌우를 DFS를 통해 순회하도록 설정해야 했습니다. const getMarker = (y, x) =&gt; `${y},${x}`; // visited 객체의 key값을 만들기 위해 필요한 함수 const checkBox = (lineIndex, boxIndex, box) =&gt; { // y(lineIndex), x(boxIndex), box 값을 받아옴 if (box === "0") return; // box가 0인 경우 아파트가 없으므로 작업을 종료 const marker = getMarker(lineIndex, boxIndex); // key값으로 사용될 marker 생성 if (visited[marker]) return; // 이미 방문했을 경우 작업을 종료 const queue = [marker]; // 첫 값으로 만들어진 marker를 담은 queue 생성 let curMarker; // 반복문을 돌면서 목표 지점이 될 marker let count = 0; // 해당 함수의 시작지점으로부터 얼마나 아파트를 돌았는지 확인하기 위한 변수 while (queue.length) { curMarker = queue.pop(); // 목표지점으로 사용될 marker를 설정 const [y, x] = curMarker.split(",").map((value) =&gt; Number(value)); // 몇 번째 줄, 몇 번째 box인지를 알아냄 if (!visited[curMarker] &amp;&amp; graphBoxes[y][x] === "1") { // 방문하지 않은 값이 "1"인 box들일 경우에만 작업을 진행함 visited[curMarker] = true; // 방문을 하는 상황으로 설정 count += 1; // 상하좌우를 돌면서 queue에 넣어줌 if (y - 1 &gt;= 0) queue.push(getMarker(y - 1, x)); if (x - 1 &gt;= 0) queue.push(getMarker(y, x - 1)); if (y + 1 &lt; N) queue.push(getMarker(y + 1, x)); if (x + 1 &lt; N) queue.push(getMarker(y, x + 1)); } } if (count) countArray.push(count); }; 위 함수를 통해서 반복 작업 시 box가 방문하지 않은 ‘1’인 경우에만 그래프 순회를 통해 개수 세기를 진행하도록 할 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 14940번</title><link href="http://localhost:4000/algorithm/2022/11/09/14940/" rel="alternate" type="text/html" title="백준 14940번" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/09/14940</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/09/14940/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/14940">QUESTION LINK</a></strong></p>

<p>그래프 순회를 하여 기준점으로부터의 거리값을 구하는 문제였습니다. 이 문제의 경우, BFS를 통해 한 점으로 부터 사방으로 이동할 때마다 이동거리를 한 칸 넓히는 방식을 통해 각 칸에서의 길이를 구하면 되었습니다.</p>

<h3 id="잘못된-풀이--각-점으로-부터-2까지의-거리-구하기">잘못된 풀이 : 각 점으로 부터 ‘2’까지의 거리 구하기</h3>

<p>하지만, 초반에 잘못된 방법으로 풀고자 하여, 기준점을 “2”에 두는 것이 아닌, 모든 각각의 점에 대해 기준점을 두고 2까지 가는 데에 필요한 길이를 구하는 방식으로 진행을 하여, 아래와 같은 코드가 나왔고, 이로 인해 <strong>‘시간 초과’</strong>가 계속해서 나오는 문제가 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">M</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">)].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nx">M</span><span class="p">)]);</span>
<span class="c1">// 결과를 담을 배열</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">floor</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">checkBox</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 0일 때 그 위치의 값은 0으로 설정</span>
    <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2일 때 그 위치의 값은 0으로 설정</span>
    <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문여부를 확인하는 객체</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
  <span class="c1">// 최초 값은 함수를 통해 들어온 위치</span>
  <span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 해당 박스의 좌표와 몇 번을 거쳐 왔는지 나타내는 floor 값</span>
    <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 2인 경우 추가적인 queue를 넣지 않고 거쳐온 정도를 넣어준 뒤 종료</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">resultArray</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">floor</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 1인 경우 주변 요소도 확인하도록 queue에 push</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">M</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 문제가 되었던 곳. 모든 값을 돌아 길이를 구하려 해서 시간이 늘어남</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">checkBox</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">box</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">resultArray</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>위 코드로 작성해, 모든 값에 대한 길이를 구하다보니 시간이 늘어나게 되어 이를 해결하기 위한 다른 방법을 찾게 되었습니다.</p>

<h3 id="2를-시작점으로-설정하고-주변-길이-구하기">‘2’를 시작점으로 설정하고 주변 길이 구하기</h3>

<p>여러번의 BFS 순회를 하는 것이 아니라, 한 번의 BFS만을 통해 모든 위치의 값을 구하면 된다는 것을 알게 되었고, 이를 적용하고자 했습니다. 이 때, 문제의 사항 중 고려하지 못했던 부분이 하나 더 있었는데, <strong>‘1’로 된 곳 중, 방문을 아예 하지 못한 곳은 ‘-1’로 처리한다</strong>는 것입니다. 처음에는 이 사항에 대한 고려가 없어 계속 틀렸다는 결과가 나왔는데, 문제를 다시 파악해보니 이와 같은 조건이 같이 있었다는 것을 알았습니다. 문제를 꼼꼼하게 읽는 것이 풀이보다 더 중요하다는 걸 느끼는 순간이었습니다…</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">toString</span><span class="p">().</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">numbers</span><span class="p">,</span> <span class="p">...</span><span class="nx">graph</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">]</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">M</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graphBoxes</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">destination</span> <span class="o">=</span> <span class="p">[];</span>

<span class="c1">// '2'의 위치를 처음에 파악해 저장해둠</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="nx">destination</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">getMarker</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">y</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">x</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">getQueueItem</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">`</span><span class="p">${</span><span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">)}</span><span class="s2">,</span><span class="p">${</span><span class="nx">floor</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="c1">// floor 값은 BFS로 탐색을 들어간 횟수를 나타냄</span>

<span class="kd">const</span> <span class="nx">BFS</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">destY</span><span class="p">,</span> <span class="nx">destX</span><span class="p">]</span> <span class="o">=</span> <span class="nx">destination</span><span class="p">;</span>
  <span class="c1">// '2'의 위치</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문한 곳을 나타내는 객체</span>
  <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">destY</span><span class="p">,</span> <span class="nx">destX</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
  <span class="c1">// 최초값으로 '2'의 위치를 넣어줌. 2는 어느 곳에 대한 이동도 없으므로 floor값은 0</span>
  <span class="kd">let</span> <span class="nx">curItem</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curItem</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">curItem</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="c1">// 방문한 곳의 좌표, 탐색 횟수</span>
    <span class="kd">const</span> <span class="nx">curMarker</span> <span class="o">=</span> <span class="nx">getMarker</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">curValue</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 값이 0인 경우 0으로 설정</span>
      <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">curValue</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 값이 1, 2인 경우 해당 위치를 방문했음을 표기하고 주변 위치를 탐색</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">curMarker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">graphBoxes</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">floor</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">N</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">M</span><span class="p">)</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getQueueItem</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">floor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">BFS</span><span class="p">();</span>

<span class="c1">// 0인 경우, -1인 경우를 표기함</span>
<span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">0</span><span class="dl">"</span><span class="p">)</span> <span class="nx">line</span><span class="p">[</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="nx">line</span><span class="p">[</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">graphBoxes</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>이번 문제를 풀면서 난이도가 쉬운 문제도 문제에 대한 해결 방향을 잘못 잡거나, 문제를 잘못 읽은 경우 문제 풀이에 큰 문제가 생길 수 있음을 다시 느낄 수 있었습니다! 문제 해결에 앞서서 문제 이해 및 풀이를 위한 설계를 조금 더 신경쓰기로 했습니다.</p>

<p><strong>🔎 현재 코드의 경우, 상당히 긴 시간과 메모리를 소모하며 문제를 해결하게 됩니다. 추후 다시 문제를 풀면서 해당 부분에 대한 해결도 필요합니다.</strong></p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 그래프 순회를 하여 기준점으로부터의 거리값을 구하는 문제였습니다. 이 문제의 경우, BFS를 통해 한 점으로 부터 사방으로 이동할 때마다 이동거리를 한 칸 넓히는 방식을 통해 각 칸에서의 길이를 구하면 되었습니다. 잘못된 풀이 : 각 점으로 부터 ‘2’까지의 거리 구하기 하지만, 초반에 잘못된 방법으로 풀고자 하여, 기준점을 “2”에 두는 것이 아닌, 모든 각각의 점에 대해 기준점을 두고 2까지 가는 데에 필요한 길이를 구하는 방식으로 진행을 하여, 아래와 같은 코드가 나왔고, 이로 인해 ‘시간 초과’가 계속해서 나오는 문제가 있었습니다. const [numbers, ...graph] = input; const [n, m] = numbers.split(" "); const N = Number(n); const M = Number(m); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const resultArray = [...Array(N)].map(() =&gt; [...Array(M)]); // 결과를 담을 배열 const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, floor) =&gt; `${getMarker(y, x)},${floor}`; const checkBox = (lineIndex, boxIndex, box) =&gt; { if (box === "0") { // 0일 때 그 위치의 값은 0으로 설정 resultArray[lineIndex][boxIndex] = "0"; return; } if (box === "2") { // 2일 때 그 위치의 값은 0으로 설정 resultArray[lineIndex][boxIndex] = "0"; return; } const visited = {}; // 방문여부를 확인하는 객체 const queue = [getQueueItem(lineIndex, boxIndex, 0)]; // 최초 값은 함수를 통해 들어온 위치 let curItem; while (queue.length) { curItem = queue.shift(); const [y, x, floor] = curItem.split(",").map((value) =&gt; Number(value)); // 해당 박스의 좌표와 몇 번을 거쳐 왔는지 나타내는 floor 값 const curMarker = getMarker(y, x); const curValue = graphBoxes[y][x]; if (!visited[curMarker] &amp;&amp; curValue === "2") { // 2인 경우 추가적인 queue를 넣지 않고 거쳐온 정도를 넣어준 뒤 종료 visited[curMarker] = true; resultArray[lineIndex][boxIndex] = floor; } if (!visited[curMarker] &amp;&amp; curValue === "1") { // 1인 경우 주변 요소도 확인하도록 queue에 push visited[curMarker] = true; if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, floor + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, floor + 1)); if (y + 1 &lt; N) queue.push(getQueueItem(y + 1, x, floor + 1)); if (x + 1 &lt; M) queue.push(getQueueItem(y, x + 1, floor + 1)); } } }; // 문제가 되었던 곳. 모든 값을 돌아 길이를 구하려 해서 시간이 늘어남 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { checkBox(lineIndex, boxIndex, box); }); }); const result = resultArray.map((line) =&gt; line.join(" ")).join("\n"); console.log(result); 위 코드로 작성해, 모든 값에 대한 길이를 구하다보니 시간이 늘어나게 되어 이를 해결하기 위한 다른 방법을 찾게 되었습니다. ‘2’를 시작점으로 설정하고 주변 길이 구하기 여러번의 BFS 순회를 하는 것이 아니라, 한 번의 BFS만을 통해 모든 위치의 값을 구하면 된다는 것을 알게 되었고, 이를 적용하고자 했습니다. 이 때, 문제의 사항 중 고려하지 못했던 부분이 하나 더 있었는데, ‘1’로 된 곳 중, 방문을 아예 하지 못한 곳은 ‘-1’로 처리한다는 것입니다. 처음에는 이 사항에 대한 고려가 없어 계속 틀렸다는 결과가 나왔는데, 문제를 다시 파악해보니 이와 같은 조건이 같이 있었다는 것을 알았습니다. 문제를 꼼꼼하게 읽는 것이 풀이보다 더 중요하다는 걸 느끼는 순간이었습니다… const input = fs.readFileSync(filePath).toString().trim().split("\n"); const [numbers, ...graph] = input; const [n, m] = numbers.split(" "); const N = Number(n); const M = Number(m); const graphBoxes = graph.map((line) =&gt; line.split(" ")); const destination = []; // '2'의 위치를 처음에 파악해 저장해둠 graphBoxes.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "2") destination.push(lineIndex, boxIndex); }); }); const getMarker = (y, x) =&gt; `${y},${x}`; const getQueueItem = (y, x, floor) =&gt; `${getMarker(y, x)},${floor}`; // floor 값은 BFS로 탐색을 들어간 횟수를 나타냄 const BFS = () =&gt; { const [destY, destX] = destination; // '2'의 위치 const visited = {}; // 방문한 곳을 나타내는 객체 const queue = [getQueueItem(destY, destX, 0)]; // 최초값으로 '2'의 위치를 넣어줌. 2는 어느 곳에 대한 이동도 없으므로 floor값은 0 let curItem; while (queue.length) { curItem = queue.shift(); const [y, x, floor] = curItem.split(",").map((value) =&gt; Number(value)); // 방문한 곳의 좌표, 탐색 횟수 const curMarker = getMarker(y, x); const curValue = graphBoxes[y][x]; if (curValue === "0") { // 값이 0인 경우 0으로 설정 graphBoxes[y][x] = 0; } if (!visited[curMarker] &amp;&amp; (curValue === "1" || curValue === "2")) { // 값이 1, 2인 경우 해당 위치를 방문했음을 표기하고 주변 위치를 탐색 visited[curMarker] = true; graphBoxes[y][x] = floor; if (y - 1 &gt;= 0) queue.push(getQueueItem(y - 1, x, floor + 1)); if (x - 1 &gt;= 0) queue.push(getQueueItem(y, x - 1, floor + 1)); if (y + 1 &lt; N) queue.push(getQueueItem(y + 1, x, floor + 1)); if (x + 1 &lt; M) queue.push(getQueueItem(y, x + 1, floor + 1)); } } }; BFS(); // 0인 경우, -1인 경우를 표기함 graphBoxes.forEach((line) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "0") line[boxIndex] = 0; if (box === "1") line[boxIndex] = -1; }); }); const result = graphBoxes.map((line) =&gt; line.join(" ")).join("\n"); console.log(result); 이번 문제를 풀면서 난이도가 쉬운 문제도 문제에 대한 해결 방향을 잘못 잡거나, 문제를 잘못 읽은 경우 문제 풀이에 큰 문제가 생길 수 있음을 다시 느낄 수 있었습니다! 문제 해결에 앞서서 문제 이해 및 풀이를 위한 설계를 조금 더 신경쓰기로 했습니다. 🔎 현재 코드의 경우, 상당히 긴 시간과 메모리를 소모하며 문제를 해결하게 됩니다. 추후 다시 문제를 풀면서 해당 부분에 대한 해결도 필요합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 16918번</title><link href="http://localhost:4000/algorithm/2022/11/08/16918/" rel="alternate" type="text/html" title="백준 16918번" /><published>2022-11-08T00:00:00+09:00</published><updated>2022-11-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/08/16918</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/08/16918/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/16918">QEUSTION LINK</a></strong></p>

<h3 id="1-첫-풀이-방식--규칙-사용하기-실패">1. 첫 풀이 방식 : 규칙 사용하기 (실패)</h3>

<p>문제에서 일종의 규칙을 찾은 뒤, 이후 문제가 되는 부분에 대해서만 처리를 해주고자 했습니다. 가장 처음에 한 것은 상황을 구분 짓는 것이었는데, 해당 문제의 경우 총 세 가지 경우의 수가 반복되고 있었습니다.</p>

<ol>
  <li>처음에 주어진 폭탄의 상황</li>
  <li>모든 위치에 폭탄이 들어간 상황</li>
  <li>처음 위치와 반대로 폭탄이 설치된 상황</li>
</ol>

<p>이 상황들 중 3번에 대한 처리만 하면 될 것이라는 생각으로, 처음에 주어진 폭탄의 상황을 먼저 만드는 것으로 시작했습니다. 이를 위해 주어진 값들에 대해서 그래프 형식으로 바꾸는 작업부터 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">R</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">time</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// R x C 의 그래프에서 time을 가져옴</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>
<span class="c1">// 그래프 각각의 값을 나누어줌</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 방문한 곳을 처리하기 위한 객체</span>
</code></pre></div></div>

<p>위 코드를 통해 아래와 같은 형식의 그래프를 가져올 수 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
</code></pre></div></div>

<p>그 후, 각 초마다의 상황을 처리해야했는데, 이는 아래와 같은 규칙성을 가지고 있었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">처음</span> <span class="nx">주어진</span> <span class="nx">상황</span>
<span class="mi">1</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">처음</span> <span class="nx">주어진</span> <span class="nx">상황</span>
<span class="mi">2</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">모든</span> <span class="nx">위치에</span> <span class="nx">폭탄</span>
<span class="mi">3</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">처음과</span> <span class="nx">뒤바뀐</span> <span class="nx">상황</span>
<span class="mi">4</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">모든</span> <span class="nx">위치에</span> <span class="nx">폭탄</span>
<span class="mi">5</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">처음</span> <span class="nx">주어진</span> <span class="nx">상황</span>
<span class="mi">6</span><span class="nx">초</span> <span class="p">:</span> <span class="nx">모든</span> <span class="nx">위치에</span> <span class="nx">폭탄</span>
<span class="p">...</span>
</code></pre></div></div>

<p>즉, 시간이 주어진 상황에서, 4로 나눌 때, 아래와 같은 결과가 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">나머지</span> <span class="mi">1</span> <span class="o">=</span> <span class="nx">첫</span> <span class="nx">상황</span>
<span class="nx">나머지</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">나머지</span> <span class="mi">4</span> <span class="o">=</span> <span class="nx">모든</span> <span class="nx">위치에</span> <span class="nx">폭탄</span>
<span class="nx">나머지</span> <span class="mi">3</span> <span class="o">=</span> <span class="nx">첫</span> <span class="nx">상황과</span> <span class="nx">반대</span>
</code></pre></div></div>

<p>이렇게 상황을 설정한 뒤에는 ‘첫 상황과 반대’인 경우에 대해 처리를 해주어야 했습니다. 이 부분에 대한 처리는 그래프를 순회하며 폭탄(”0”)을 만날 때마다 그 주위의 값들을 터짐(”.”)으로 바꿔주도록 설정했습니다. 그리고 만약, 그 주위에 다른 폭탄이 있는 경우에는 이후에 그 폭탄이 터지는 것으로 처리했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">remain</span> <span class="o">=</span> <span class="nx">time</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 처음과 같은 상태 유지</span>
    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">remain</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 모두 폭탄이 위치한 것으로 설정</span>
    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="nx">C</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">remain</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 처음 폭탄과 반대 상황 설정</span>
    <span class="nx">graph</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="c1">// 처음 위치에 폭탄이 터지고, 이후 주변 폭탄도 터지도록 설정</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">C</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">checkMark</span><span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// 폭탄이 아닌 곳을 지날 시, 폭탄으로 바뀌도록 설정</span>
          <span class="kd">const</span> <span class="nx">mark</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">lineIndex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">boxIndex</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">])</span> <span class="p">{</span>
            <span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">});</span>

    <span class="k">return</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그리고, 폭탄에 도착할 시, 폭탄이 터지는 상황에 대한 함수는 따로 구분해서 생성해주었습니다. 이 때, 폭탄이 터지는 상황은 현재 위치가 폭탄일 때, 주변 위치가 폭탄이 아닐 때로 설정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">checkMark</span> <span class="o">=</span> <span class="p">(</span><span class="nx">lineIndex</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">,</span> <span class="nx">isSelf</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">mark</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">lineIndex</span><span class="p">}</span><span class="s2">,</span><span class="p">${</span><span class="nx">boxIndex</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="c1">// 폭탄이 터질 위치</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isSelf</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 폭탄 자체의 위치가 아닌 상황에서 방문한 적 없는 주변 폭탄인 경우에는 넘어감</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">graph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이를 통해 예제의 상황에 대해서는 제대로 결과가 호출되는 것을 볼 수 있었습니다. 하지만, 백준을 통해 채점을 했을 때 틀렸다는 결과가 나와서 문제점을 파악하는 데에 시간을 꽤 소요됐습니다.</p>

<h3 id="2-두-번째-방식--직접-반복하기-성공">2. 두 번째 방식 : 직접 반복하기 (성공)</h3>

<p>이전에 규칙을 찾아 적용하는 방식을 할 경우, 규칙이 무조건 반복되지 않을 수도 있다는 문제가 있다는 것을 발견했습니다. 그래서, 이를 해결하기 위해서는 직접 폭탄이 터지는 상황을 반복하는 것이 안전하다고 판단해, 직접 진행하는 것으로 방법을 변경했습니다.</p>

<p>문제를 풀기 위해 진행한 순서는 아래와 같습니다.</p>

<ol>
  <li>1초만 진행된 상황에 대해 처리하기</li>
  <li>짝수초 만큼 진행된 상황에 대해 처리하기</li>
  <li>1,2번 이외의 상황 처리하기</li>
</ol>

<p>가장 먼저 진행한 것은 첫 번째 방식과 동일하게 그래프를 만들어주는 것이었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">R</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">N</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">time</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">N</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">));</span>

<span class="p">[</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">],</span>
<span class="p">];</span>
<span class="c1">// 생성된 그래프 배열</span>
</code></pre></div></div>

<p>그리고 폭탄이 터지는 상황에서 사용하기 위한 폭탄으로만 가득찬 배열을 만드는 함수를 생성했습니다. 이 함수의 경우, 앞서 말한 바와 같이 짝수초 만큼 지나간 상황에서는 폭탄으로만 가득한 배열이 나오기 때문에 그 상황에서도 활용이 가능합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getNewGraph</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
  <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">R</span><span class="p">))].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nb">Array</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">C</span><span class="p">))].</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">));</span>
</code></pre></div></div>

<p>그리고 1, 2번의 상황을 처리하기 위한 함수를 먼저 생성했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 1초만 지나간 경우 원래의 그래프를 보여줌</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">time</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// 짝수초만큼 지나간 경우 폭탄으로 가득한 그래프를 보여줌</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">time</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">getNewGraph</span><span class="p">()</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">))</span>
      <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221108/1.png" alt="" width="100%" height="" /> 
</figure>

<p>이후 폭탄이 터진 뒤의 상황을 보여주는 그래프를 생성해야 했습니다. 이를 해결하기 위해 생각한 것은 우선 폭탄으로 가득찬 그래프를 먼저 만든 뒤, 이전 그래프에서 폭탄이 위치한 곳과 상하좌우를 폭탄이 터지도록 하여 다음에 터져야할 폭탄들이 보이는 그래프가 나오도록 설정을 해주었습니다.</p>

<p>그리고 2초가 더 지나간 상황에서는 새롭게 만들어진 그래프에서 폭탄이 터지는 상황을 만들도록 하여 앞서 진행한 것과 같은 방식으로 진행하도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getResult</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="kd">let</span> <span class="nx">curTime</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">time</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// 시간이 이미 2초 지나간 뒤의 상황부터 시작하기 때문에 2를 뺌</span>
  <span class="kd">let</span> <span class="nx">curGraph</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">;</span>
  <span class="c1">// 폭탄의 위치를 나타내는 그래프</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">curTime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 2초씩 지나간 뒤, 0초 이하일 경우 멈춤</span>
    <span class="nx">curTime</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// 2초가 지나간 뒤의 상황을 보여줄 것이므로 뺌</span>
    <span class="kd">const</span> <span class="nx">newGraph</span> <span class="o">=</span> <span class="nx">getNewGraph</span><span class="p">();</span>
    <span class="c1">// 새롭게 만들어질 폭탄으로 가득찬 그래프</span>
    <span class="nx">curGraph</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">line</span><span class="p">,</span> <span class="nx">lineIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">line</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">box</span><span class="p">,</span> <span class="nx">boxIndex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 폭탄 위치를 나타내는 그래프에서 좌표를 빼내어 폭탄과 그 상하좌우가 터지도록 설정</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">box</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">C</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span><span class="p">][</span><span class="nx">boxIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">newGraph</span><span class="p">[</span><span class="nx">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">boxIndex</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">.</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">});</span>
    <span class="nx">curGraph</span> <span class="o">=</span> <span class="nx">newGraph</span><span class="p">;</span>
    <span class="c1">// 새롭게 만들어진 폭탄 위치 그래프로 설정</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">curGraph</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">line</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">)).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221108/2.png" alt="" width="100%" height="" /> 
</figure>

<p>이런 식으로 폭탄이 터지는 위치에 대한 값을 지속적으로 확인해 처리해주는 방식으로 문제를 해결할 수 있었습니다.</p>

<hr />

<p>🔎 현재 사용한 방식은 그래프 순회를 하는 방식을 적극적으로 사용하지는 않은 것이라 다른 방법에 대한 고민이 더 필요하기는 합니다!</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QEUSTION LINK 1. 첫 풀이 방식 : 규칙 사용하기 (실패) 문제에서 일종의 규칙을 찾은 뒤, 이후 문제가 되는 부분에 대해서만 처리를 해주고자 했습니다. 가장 처음에 한 것은 상황을 구분 짓는 것이었는데, 해당 문제의 경우 총 세 가지 경우의 수가 반복되고 있었습니다. 처음에 주어진 폭탄의 상황 모든 위치에 폭탄이 들어간 상황 처음 위치와 반대로 폭탄이 설치된 상황 이 상황들 중 3번에 대한 처리만 하면 될 것이라는 생각으로, 처음에 주어진 폭탄의 상황을 먼저 만드는 것으로 시작했습니다. 이를 위해 주어진 값들에 대해서 그래프 형식으로 바꾸는 작업부터 해주었습니다. const [R, C, time] = input[0].split(" "); // R x C 의 그래프에서 time을 가져옴 const graph = input.splice(1).map((line) =&gt; line.split("")); // 그래프 각각의 값을 나누어줌 const visited = {}; // 방문한 곳을 처리하기 위한 객체 위 코드를 통해 아래와 같은 형식의 그래프를 가져올 수 있었습니다. const graph = [ [".", ".", ".", ".", ".", ".", "."], [".", ".", ".", "O", ".", ".", "."], [".", ".", ".", ".", "O", ".", "."], [".", ".", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ]; 그 후, 각 초마다의 상황을 처리해야했는데, 이는 아래와 같은 규칙성을 가지고 있었습니다. 0초 : 처음 주어진 상황 1초 : 처음 주어진 상황 2초 : 모든 위치에 폭탄 3초 : 처음과 뒤바뀐 상황 4초 : 모든 위치에 폭탄 5초 : 처음 주어진 상황 6초 : 모든 위치에 폭탄 ... 즉, 시간이 주어진 상황에서, 4로 나눌 때, 아래와 같은 결과가 됩니다. 나머지 1 = 첫 상황 나머지 2, 나머지 4 = 모든 위치에 폭탄 나머지 3 = 첫 상황과 반대 이렇게 상황을 설정한 뒤에는 ‘첫 상황과 반대’인 경우에 대해 처리를 해주어야 했습니다. 이 부분에 대한 처리는 그래프를 순회하며 폭탄(”0”)을 만날 때마다 그 주위의 값들을 터짐(”.”)으로 바꿔주도록 설정했습니다. 그리고 만약, 그 주위에 다른 폭탄이 있는 경우에는 이후에 그 폭탄이 터지는 것으로 처리했습니다. const getResult = () =&gt; { const remain = time % 4; if (remain === 1) { // 처음과 같은 상태 유지 return graph.map((line) =&gt; line.join("")).join("\n"); } if (remain === 0 || remain === 2) { // 모두 폭탄이 위치한 것으로 설정 return graph.map(() =&gt; "O".repeat(C)).join("\n"); } if (remain === 3) { // 처음 폭탄과 반대 상황 설정 graph.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { if (box === "O") { checkMark(lineIndex, boxIndex, true); // 처음 위치에 폭탄이 터지고, 이후 주변 폭탄도 터지도록 설정 if (lineIndex - 1 &gt;= 0) checkMark(lineIndex - 1, boxIndex); if (boxIndex - 1 &gt;= 0) checkMark(lineIndex, boxIndex - 1); if (boxIndex + 1 &lt;= C - 1) checkMark(lineIndex, boxIndex + 1); if (lineIndex + 1 &lt;= R - 1) checkMark(lineIndex + 1, boxIndex); } if (box === ".") { // 폭탄이 아닌 곳을 지날 시, 폭탄으로 바뀌도록 설정 const mark = `${lineIndex},${boxIndex}`; if (!visited[mark]) { visited[mark] = true; graph[lineIndex][boxIndex] = "O"; } } }); }); return graph.map((line) =&gt; line.join("")).join("\n"); } }; 그리고, 폭탄에 도착할 시, 폭탄이 터지는 상황에 대한 함수는 따로 구분해서 생성해주었습니다. 이 때, 폭탄이 터지는 상황은 현재 위치가 폭탄일 때, 주변 위치가 폭탄이 아닐 때로 설정했습니다. const checkMark = (lineIndex, boxIndex, isSelf = false) =&gt; { const mark = `${lineIndex},${boxIndex}`; // 폭탄이 터질 위치 if (graph[lineIndex][boxIndex] === "O" &amp;&amp; !visited[mark] &amp;&amp; !isSelf) return; // 폭탄 자체의 위치가 아닌 상황에서 방문한 적 없는 주변 폭탄인 경우에는 넘어감 visited[mark] = true; graph[lineIndex][boxIndex] = "."; }; 이를 통해 예제의 상황에 대해서는 제대로 결과가 호출되는 것을 볼 수 있었습니다. 하지만, 백준을 통해 채점을 했을 때 틀렸다는 결과가 나와서 문제점을 파악하는 데에 시간을 꽤 소요됐습니다. 2. 두 번째 방식 : 직접 반복하기 (성공) 이전에 규칙을 찾아 적용하는 방식을 할 경우, 규칙이 무조건 반복되지 않을 수도 있다는 문제가 있다는 것을 발견했습니다. 그래서, 이를 해결하기 위해서는 직접 폭탄이 터지는 상황을 반복하는 것이 안전하다고 판단해, 직접 진행하는 것으로 방법을 변경했습니다. 문제를 풀기 위해 진행한 순서는 아래와 같습니다. 1초만 진행된 상황에 대해 처리하기 짝수초 만큼 진행된 상황에 대해 처리하기 1,2번 이외의 상황 처리하기 가장 먼저 진행한 것은 첫 번째 방식과 동일하게 그래프를 만들어주는 것이었습니다. const [R, C, N] = input[0].split(" "); const time = Number(N); const graph = input.slice(1).map((line) =&gt; line.split("")); [ [".", ".", ".", ".", ".", ".", "."], [".", ".", ".", "O", ".", ".", "."], [".", ".", ".", ".", "O", ".", "."], [".", ".", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ["O", "O", ".", ".", ".", ".", "."], ]; // 생성된 그래프 배열 그리고 폭탄이 터지는 상황에서 사용하기 위한 폭탄으로만 가득찬 배열을 만드는 함수를 생성했습니다. 이 함수의 경우, 앞서 말한 바와 같이 짝수초 만큼 지나간 상황에서는 폭탄으로만 가득한 배열이 나오기 때문에 그 상황에서도 활용이 가능합니다. const getNewGraph = () =&gt; [...Array(Number(R))].map(() =&gt; [...Array(Number(C))].map(() =&gt; "O")); 그리고 1, 2번의 상황을 처리하기 위한 함수를 먼저 생성했습니다. const getResult = () =&gt; { // 1초만 지나간 경우 원래의 그래프를 보여줌 if (time === 1) { return input.slice(1).join("\n"); } // 짝수초만큼 지나간 경우 폭탄으로 가득한 그래프를 보여줌 if (!(time % 2)) { return getNewGraph() .map((line) =&gt; line.join("")) .join("\n"); } ... }; 이후 폭탄이 터진 뒤의 상황을 보여주는 그래프를 생성해야 했습니다. 이를 해결하기 위해 생각한 것은 우선 폭탄으로 가득찬 그래프를 먼저 만든 뒤, 이전 그래프에서 폭탄이 위치한 곳과 상하좌우를 폭탄이 터지도록 하여 다음에 터져야할 폭탄들이 보이는 그래프가 나오도록 설정을 해주었습니다. 그리고 2초가 더 지나간 상황에서는 새롭게 만들어진 그래프에서 폭탄이 터지는 상황을 만들도록 하여 앞서 진행한 것과 같은 방식으로 진행하도록 했습니다. const getResult = () =&gt; { ... let curTime = Number(time) - 2; // 시간이 이미 2초 지나간 뒤의 상황부터 시작하기 때문에 2를 뺌 let curGraph = graph; // 폭탄의 위치를 나타내는 그래프 while (curTime &gt; 0) { // 2초씩 지나간 뒤, 0초 이하일 경우 멈춤 curTime -= 2; // 2초가 지나간 뒤의 상황을 보여줄 것이므로 뺌 const newGraph = getNewGraph(); // 새롭게 만들어질 폭탄으로 가득찬 그래프 curGraph.forEach((line, lineIndex) =&gt; { line.forEach((box, boxIndex) =&gt; { // 폭탄 위치를 나타내는 그래프에서 좌표를 빼내어 폭탄과 그 상하좌우가 터지도록 설정 if (box !== "O") return; newGraph[lineIndex][boxIndex] = "."; if (lineIndex - 1 &gt;= 0) newGraph[lineIndex - 1][boxIndex] = "."; if (boxIndex - 1 &gt;= 0) newGraph[lineIndex][boxIndex - 1] = "."; if (boxIndex + 1 &lt;= C - 1) newGraph[lineIndex][boxIndex + 1] = "."; if (lineIndex + 1 &lt;= R - 1) newGraph[lineIndex + 1][boxIndex] = "."; }); }); curGraph = newGraph; // 새롭게 만들어진 폭탄 위치 그래프로 설정 } return curGraph.map((line) =&gt; line.join("")).join("\n"); }; 이런 식으로 폭탄이 터지는 위치에 대한 값을 지속적으로 확인해 처리해주는 방식으로 문제를 해결할 수 있었습니다. 🔎 현재 사용한 방식은 그래프 순회를 하는 방식을 적극적으로 사용하지는 않은 것이라 다른 방법에 대한 고민이 더 필요하기는 합니다!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>