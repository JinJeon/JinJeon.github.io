<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-GB"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-GB" /><updated>2022-11-04T18:13:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JINJEONIMUM</title><subtitle></subtitle><author><name>JinJeon</name></author><entry><title type="html">textarea 줄바꿈 시 자동 스크롤</title><link href="http://localhost:4000/react/2022/10/26/textarea-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%8A%A4%ED%81%AC%EB%A1%A4/" rel="alternate" type="text/html" title="textarea 줄바꿈 시 자동 스크롤" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/26/textarea%20%EC%A4%84%EB%B0%94%EA%BF%88%20%EC%8B%9C%20%EC%9E%90%EB%8F%99%20%EC%8A%A4%ED%81%AC%EB%A1%A4</id><content type="html" xml:base="http://localhost:4000/react/2022/10/26/textarea-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%8A%A4%ED%81%AC%EB%A1%A4/"><![CDATA[<h2 id="textarea-태그-내-줄바꿈-시-문제점">textarea 태그 내 줄바꿈 시 문제점</h2>

<p><code class="language-plaintext highlighter-rouge">textarea</code> 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 <code class="language-plaintext highlighter-rouge">input</code> 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. <code class="language-plaintext highlighter-rouge">input</code> 태그는 한 줄로만 이어져 줄바꿈이 없었지만, <code class="language-plaintext highlighter-rouge">textarea</code>는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/1.png" alt="" width="75%" height="" /> 
</figure>

<p>이러한 문제를 해결하기 위한 방법으로 처음에는 <code class="language-plaintext highlighter-rouge">line-height</code>를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다.</p>

<h2 id="스크롤을-최하단으로-내리기">스크롤을 최하단으로 내리기</h2>

<p>이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// textarea 태그를 받아오기 위한 ref</span>

<span class="kd">const</span> <span class="nx">handleScrollTextarea</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// scroll이 발생하는 상황 시</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollHeight</span><span class="p">;</span>
	<span class="c1">// 스크롤의 위치를 textarea의 최하단으로 옮김</span>
<span class="p">};</span>

<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
  <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">textareaRef</span><span class="si">}</span>
	<span class="err">...</span>
  <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
	<span class="c1">// 스크롤 발생 시 함수 적용</span>
  <span class="na">placeholder</span><span class="p">=</span><span class="s">'메시지를 입력하세요.'</span>
<span class="p">/&gt;</span>
</code></pre></div></div>

<p>하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/2.gif" alt="" width="75%" height="" /> 
</figure>

<h2 id="특정-상황에서만-스크롤을-강제로-내리기">특정 상황에서만 스크롤을 강제로 내리기</h2>

<p>위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">scrollWithTypingRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="c1">// 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref</span>
<span class="kd">const</span> <span class="nx">typingTimeoutRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">NodeJS</span><span class="p">.</span><span class="nx">Timeout</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref</span>

<span class="cm">/** handler for type key */</span>
<span class="kd">const</span> <span class="nx">handleChangeChatValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">inputType</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">nativeEvent</span> <span class="k">as</span> <span class="kr">any</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">inputType</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">insertLineBreak</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span><span class="p">);</span>
	<span class="c1">// 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce)</span>
  <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
	<span class="c1">// 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정</span>
  <span class="nx">typingTimeoutRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">false</span><span class="p">),</span> <span class="mi">500</span><span class="p">);</span>
	<span class="c1">// 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정</span>
<span class="p">};</span>

<span class="cm">/** handler for type 'Enter' key */</span>
<span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span><span class="p">,</span> <span class="nx">keyCode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>
  <span class="c1">// 'keyCode' is deprecated but error occurs when just use 'key' in korean</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">Enter</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">keyCode</span> <span class="o">!==</span> <span class="mi">13</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="c1">// Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
		<span class="c1">// 줄바꿈 추가를 통해 스크롤을 발생시킴</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/** handler for auto scroll during typing */</span>
<span class="kd">const</span> <span class="nx">handleScrollTextarea</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">||</span> <span class="o">!</span><span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">scrollHeight</span><span class="p">;</span>
  <span class="nx">scrollWithTypingRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
	<span class="c1">// 스크롤이 발생했으므로, 다시 false로 설정</span>
<span class="p">};</span>

<span class="k">return</span> <span class="p">(</span>
	<span class="p">...</span>
	<span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">ChatTextarea</span>
    <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">textareaRef</span><span class="p">}</span>
    <span class="nx">rows</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="nx">spellCheck</span><span class="o">=</span><span class="p">{</span><span class="kc">false</span><span class="p">}</span>
    <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">chatValue</span><span class="p">}</span>
    <span class="nx">onKeyDown</span><span class="o">=</span><span class="p">{</span><span class="nx">handleKeyDownChat</span><span class="p">}</span>
    <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChangeChatValue</span><span class="p">}</span>
    <span class="nx">onScroll</span><span class="o">=</span><span class="p">{</span><span class="nx">handleScrollTextarea</span><span class="p">}</span>
    <span class="nx">placeholder</span><span class="o">=</span><span class="dl">'</span><span class="s1">메시지를 입력하세요.</span><span class="dl">'</span>
  <span class="o">/&gt;</span>
	<span class="p">...</span>
<span class="p">)</span>
</code></pre></div></div>

<p>위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다.</p>

<ol>
  <li>‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생</li>
  <li>줄바꿈 이전에 실행된 입력으로 인해 <code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = true;</code> 설정</li>
  <li><code class="language-plaintext highlighter-rouge">onScroll</code>에서 <code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = true;</code>여부 확인</li>
  <li><code class="language-plaintext highlighter-rouge">true</code>일 시 자동 스크롤 발생</li>
  <li><code class="language-plaintext highlighter-rouge">scrollWithTypingRef.current = false;</code>로 설정</li>
</ol>

<h2 id="결과">결과</h2>

<p>위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/3.gif" alt="" width="75%" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[textarea 태그 내 줄바꿈 시 문제점 textarea 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 input 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. input 태그는 한 줄로만 이어져 줄바꿈이 없었지만, textarea는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다. 이러한 문제를 해결하기 위한 방법으로 처음에는 line-height를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다. 스크롤을 최하단으로 내리기 이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); // textarea 태그를 받아오기 위한 ref const handleScrollTextarea = () =&gt; { // scroll이 발생하는 상황 시 if (!textareaRef.current) return; textareaRef.current.scrollTop = textareaRef.current.scrollHeight; // 스크롤의 위치를 textarea의 최하단으로 옮김 }; &lt;S.ChatTextarea ref={textareaRef} ... onScroll={handleScrollTextarea} // 스크롤 발생 시 함수 적용 placeholder='메시지를 입력하세요.' /&gt; 하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다. 특정 상황에서만 스크롤을 강제로 내리기 위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); const scrollWithTypingRef = useRef(false); // 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref const typingTimeoutRef = useRef&lt;NodeJS.Timeout&gt;(); // 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref /** handler for type key */ const handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { inputType } = event.nativeEvent as any; if (inputType === 'insertLineBreak') return; setChatValue(event.target.value); if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current); // 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce) scrollWithTypingRef.current = true; // 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정 typingTimeoutRef.current = setTimeout(() =&gt; (scrollWithTypingRef.current = false), 500); // 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정 }; /** handler for type 'Enter' key */ const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey, keyCode } = event; // 'keyCode' is deprecated but error occurs when just use 'key' in korean if (key !== 'Enter' || keyCode !== 13) return; if (!shiftKey) { sendCurChat(); } else { scrollWithTypingRef.current = true; // Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정 setChatValue(chatValue + '\n'); // 줄바꿈 추가를 통해 스크롤을 발생시킴 } }; /** handler for auto scroll during typing */ const handleScrollTextarea = () =&gt; { if (!textareaRef.current || !scrollWithTypingRef.current) return; textareaRef.current.scrollTop = textareaRef.current.scrollHeight; scrollWithTypingRef.current = false; // 스크롤이 발생했으므로, 다시 false로 설정 }; return ( ... &lt;S.ChatTextarea ref={textareaRef} rows={1} spellCheck={false} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} placeholder='메시지를 입력하세요.' /&gt; ... ) 위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다. ‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생 줄바꿈 이전에 실행된 입력으로 인해 scrollWithTypingRef.current = true; 설정 onScroll에서 scrollWithTypingRef.current = true;여부 확인 true일 시 자동 스크롤 발생 scrollWithTypingRef.current = false;로 설정 결과 위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">textarea 높이 조절하기</title><link href="http://localhost:4000/react/2022/10/26/textarea-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="textarea 높이 조절하기" /><published>2022-10-26T00:00:00+09:00</published><updated>2022-10-26T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/26/textarea%20%EB%86%92%EC%9D%B4%20%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/2022/10/26/textarea-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0/"><![CDATA[<h3 id="줄바꿈이-발생할-때-채팅-높이를-늘리기">줄바꿈이 발생할 때 채팅 높이를 늘리기</h3>

<p>textarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/4.png" alt="" width="" height="" /> 
</figure>

<p>줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">setAutoSize</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">{</span> <span class="na">scrollHeight</span><span class="p">:</span> <span class="nx">curHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">;</span>
  <span class="c1">// 현재의 scroll 높이를 구함</span>

  <span class="c1">// maximum height is 83px when textarea has 3 line</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curHeight</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// 83보다 크고 110보다 작은 값으로 설정</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">curHeight</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
  <span class="c1">// 실제 textarea 높이를 스크롤 높이만큼 넓힘</span>
<span class="p">};</span>
</code></pre></div></div>

<p>하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/5.gif" alt="" width="50%" height="" /> 
</figure>

<h3 id="그림자-태그를-만들어-해결하기">그림자 태그를 만들어 해결하기</h3>

<p>이를 해결하기 위한 방법을 찾아보던 도중, <a href="https://stackoverflow.com/questions/57965268/possible-to-have-a-dynamically-height-adjusted-textarea-without-constant-reflows">링크</a>를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다.<br />
실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다.<br />
현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/6.png" alt="" width="" height="" /> 
</figure>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">ChatTextarea</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">textarea</span><span class="o">&lt;</span><span class="p">{</span> <span class="nx">isShadow</span><span class="p">?:</span> <span class="nx">boolean</span> <span class="p">}</span><span class="o">&gt;</span><span class="s2">`
  </span><span class="p">${({</span> <span class="na">theme</span><span class="p">:</span> <span class="p">{</span> <span class="nx">colors</span><span class="p">,</span> <span class="nx">fonts</span> <span class="p">},</span> <span class="nx">isShadow</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">css</span><span class="s2">`
    </span><span class="p">${</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">main</span><span class="p">}</span><span class="s2">
    </span><span class="p">${</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">largeRegular</span><span class="p">}</span><span class="s2">

		...

    </span><span class="p">${</span><span class="nx">isShadow</span> <span class="o">&amp;&amp;</span>
    <span class="c1">// 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정</span>
    <span class="nx">css</span><span class="s2">`
      height: 0px;
      opacity: 0;
    `</span><span class="p">}</span><span class="s2">
  `</span><span class="p">}</span><span class="s2">
`</span><span class="p">;</span>
</code></pre></div></div>

<p>우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, <code class="language-plaintext highlighter-rouge">width</code>는 그대로 두고, <code class="language-plaintext highlighter-rouge">height</code> 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">textareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">shadowTextareaRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="p">...</span>

<span class="cm">/** get height with shadow textarea */</span>
<span class="kd">const</span> <span class="nx">setAutoSize</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">||</span> <span class="o">!</span><span class="nx">shadowTextareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="p">{</span> <span class="na">scrollHeight</span><span class="p">:</span> <span class="nx">shadowHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">shadowTextareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
	<span class="c1">// 그림자의 scroll height를 이용해 높이를 구함</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="na">height</span><span class="p">:</span> <span class="nx">curHeight</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">;</span>

  <span class="c1">// maximum height is 83px when textarea has 3 line</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">curHeight</span> <span class="o">===</span> <span class="s2">`</span><span class="p">${</span><span class="nx">shadowHeight</span><span class="p">}</span><span class="s2">px`</span> <span class="o">||</span> <span class="nx">shadowHeight</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="c1">// 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용</span>
  <span class="nx">textareaRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">shadowHeight</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setAutoSize</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">chatValue</span><span class="p">]);</span>

<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextareaWrapper</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
    <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">textareaRef</span><span class="si">}</span>
    <span class="na">rows</span><span class="p">=</span><span class="si">{</span><span class="mi">1</span><span class="si">}</span>
    <span class="na">spellCheck</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">chatValue</span><span class="si">}</span>
    <span class="na">onKeyDown</span><span class="p">=</span><span class="si">{</span><span class="nx">handleKeyDownChat</span><span class="si">}</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeChatValue</span><span class="si">}</span>
    <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
    <span class="na">placeholder</span><span class="p">=</span><span class="s">'메시지를 입력하세요.'</span>
  <span class="p">/&gt;</span>
	// 그림자 태그를 만들어 뒤에 숨어있도록 설정
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextarea</span>
    <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">shadowTextareaRef</span><span class="si">}</span>
    <span class="na">isShadow</span><span class="p">=</span><span class="si">{</span><span class="kc">true</span><span class="si">}</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">chatValue</span><span class="si">}</span>
    <span class="na">onKeyDown</span><span class="p">=</span><span class="si">{</span><span class="nx">handleKeyDownChat</span><span class="si">}</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeChatValue</span><span class="si">}</span>
    <span class="na">onScroll</span><span class="p">=</span><span class="si">{</span><span class="nx">handleScrollTextarea</span><span class="si">}</span>
    <span class="na">readOnly</span>
    <span class="na">tabIndex</span><span class="p">=</span><span class="si">{</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span>
  <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">ChatTextareaWrapper</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/7.gif" alt="" width="50%" height="" /> 
</figure>

<p>하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다.</p>

<h3 id="채팅창의-높이가-올라갈-때-채팅-내용도-올려주기">채팅창의 높이가 올라갈 때 채팅 내용도 올려주기</h3>

<p>이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, <code class="language-plaintext highlighter-rouge">position: fixed</code>로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 <code class="language-plaintext highlighter-rouge">fixed</code>가 아닌 일반적인 <code class="language-plaintext highlighter-rouge">position</code> 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다.</p>

<p>이 부분에서 저는 <code class="language-plaintext highlighter-rouge">fixed</code>를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">position: fixed</code>로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 <code class="language-plaintext highlighter-rouge">onHeightChange</code>라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">blockHeight</span><span class="p">,</span> <span class="nx">setBlockHeight</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">scrollToBottom</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">lastBlockRef</span><span class="p">.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">scrollIntoView</span><span class="p">({</span> <span class="na">block</span><span class="p">:</span> <span class="dl">'</span><span class="s1">end</span><span class="dl">'</span> <span class="p">});</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kd">const</span> <span class="nx">changeBlockHeight</span> <span class="o">=</span> <span class="p">(</span><span class="nx">height</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setBlockHeight</span><span class="p">(</span><span class="nx">height</span><span class="p">);</span>
  <span class="nx">scrollToBottom</span><span class="p">();</span>
	<span class="c1">// 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">return</span> <span class="p">(</span>
  <span class="p">&lt;&gt;</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">chatroomLogs</span><span class="si">}</span>
      <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">LastBottomBlock</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">scrollToBottomRef</span><span class="si">}</span> <span class="na">blockHeight</span><span class="p">=</span><span class="si">{</span><span class="nx">blockHeight</span><span class="si">}</span> <span class="p">/&gt;</span>
			// 채팅창 뒤 빈 영역을 채워주는 블록
    <span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">ChatroomBar</span> <span class="na">chatroomId</span><span class="p">=</span><span class="si">{</span><span class="nb">Number</span><span class="p">(</span><span class="nx">chatroomId</span><span class="p">)</span><span class="si">}</span> <span class="na">onHeightChange</span><span class="p">=</span><span class="si">{</span><span class="nx">changeBlockHeight</span><span class="si">}</span> <span class="p">/&gt;</span>
		// 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정
  <span class="p">&lt;/&gt;</span>
<span class="p">);</span>
</code></pre></div></div>

<p>위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221026/8.gif" alt="" width="50%" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[줄바꿈이 발생할 때 채팅 높이를 늘리기 textarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다. 줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다. const setAutoSize = () =&gt; { if (!textareaRef.current) return; const { scrollHeight: curHeight } = textareaRef.current.style; // 현재의 scroll 높이를 구함 // maximum height is 83px when textarea has 3 line if (curHeight &gt;= 90) return; // 83보다 크고 110보다 작은 값으로 설정 textareaRef.current.style.height = `${curHeight}px`; // 실제 textarea 높이를 스크롤 높이만큼 넓힘 }; 하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다. 그림자 태그를 만들어 해결하기 이를 해결하기 위한 방법을 찾아보던 도중, 링크를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다. 실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다. 현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다. export const ChatTextarea = styled.textarea&lt;{ isShadow?: boolean }&gt;` ${({ theme: { colors, fonts }, isShadow = false }) =&gt; css` ${fonts.main} ${fonts.largeRegular} ... ${isShadow &amp;&amp; // 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정 css` height: 0px; opacity: 0; `} `} `; 우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, width는 그대로 두고, height 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다. const textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); const shadowTextareaRef = useRef&lt;HTMLTextAreaElement&gt;(null); ... /** get height with shadow textarea */ const setAutoSize = () =&gt; { if (!textareaRef.current || !shadowTextareaRef.current) return; const { scrollHeight: shadowHeight } = shadowTextareaRef.current; // 그림자의 scroll height를 이용해 높이를 구함 const { height: curHeight } = textareaRef.current.style; // maximum height is 83px when textarea has 3 line if (curHeight === `${shadowHeight}px` || shadowHeight &gt;= 90) return; // 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용 textareaRef.current.style.height = `${shadowHeight}px`; }; ... useEffect(() =&gt; { setAutoSize(); }, [chatValue]); &lt;S.ChatTextareaWrapper&gt; &lt;S.ChatTextarea ref={textareaRef} rows={1} spellCheck={false} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} placeholder='메시지를 입력하세요.' /&gt; // 그림자 태그를 만들어 뒤에 숨어있도록 설정 &lt;S.ChatTextarea ref={shadowTextareaRef} isShadow={true} value={chatValue} onKeyDown={handleKeyDownChat} onChange={handleChangeChatValue} onScroll={handleScrollTextarea} readOnly tabIndex={-1} /&gt; &lt;/S.ChatTextareaWrapper&gt; 이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다. 하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다. 채팅창의 높이가 올라갈 때 채팅 내용도 올려주기 이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, position: fixed로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 fixed가 아닌 일반적인 position 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다. 이 부분에서 저는 fixed를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다. position: fixed로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 onHeightChange라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다. const [blockHeight, setBlockHeight] = useState(0); ... const scrollToBottom = () =&gt; { lastBlockRef.current?.scrollIntoView({ block: 'end' }); }; ... const changeBlockHeight = (height: number) =&gt; { setBlockHeight(height); scrollToBottom(); // 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정 }; ... return ( &lt;&gt; &lt;S.Wrapper&gt; {chatroomLogs} &lt;S.LastBottomBlock ref={scrollToBottomRef} blockHeight={blockHeight} /&gt; // 채팅창 뒤 빈 영역을 채워주는 블록 &lt;/S.Wrapper&gt; &lt;ChatroomBar chatroomId={Number(chatroomId)} onHeightChange={changeBlockHeight} /&gt; // 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정 &lt;/&gt; ); 위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">스크롤 시 header에 그림자 보여주기</title><link href="http://localhost:4000/javascript/2022/10/25/%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%8B%9C-header%EC%97%90-%EA%B7%B8%EB%A6%BC%EC%9E%90-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0/" rel="alternate" type="text/html" title="스크롤 시 header에 그림자 보여주기" /><published>2022-10-25T00:00:00+09:00</published><updated>2022-10-25T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/10/25/%EC%8A%A4%ED%81%AC%EB%A1%A4%20%EC%8B%9C%20header%EC%97%90%20%EA%B7%B8%EB%A6%BC%EC%9E%90%20%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/javascript/2022/10/25/%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%8B%9C-header%EC%97%90-%EA%B7%B8%EB%A6%BC%EC%9E%90-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0/"><![CDATA[<h2 id="스크롤-여부를-확인하는-방법">스크롤 여부를 확인하는 방법</h2>

<p>처음에는 <code class="language-plaintext highlighter-rouge">new IntersactionObserver</code>를 적용해 헤더의 바로 다음 요소가 가려지기 시작하면 스크롤이 되었다는 상태값을 바꿔주는 형식을 적용하고자 했었습니다. 하지만, 스크롤이 되는 순간부터 <code class="language-plaintext highlighter-rouge">window.scrollY</code>값이 바뀐다는 것을 알게 되었고, 굳이 더 복잡한 방식을 적용할 필요가 없다고 생각해 <code class="language-plaintext highlighter-rouge">window.scrollY</code>를 이용해 처리를 하도록 했습니다.</p>

<p>그리고 스크롤이 되는 상황에 대해서 화면이 인지하고 상태를 바꿔야하기 때문에, <code class="language-plaintext highlighter-rouge">window.onscroll</code>에 함수를 적용해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">useIsTopState</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isTop</span><span class="p">,</span> <span class="nx">setIsTop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="c1">// 페이지의 최상단에 있는지를 나타내는 state</span>

  <span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setIsTop</span><span class="p">(</span><span class="o">!</span><span class="nb">window</span><span class="p">.</span><span class="nx">scrollY</span><span class="p">);</span>
    <span class="c1">// 스크롤되는 화면의 최상단에 있을 시 scrollY = 0 이므로 isTop이 true가 됨</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">isTop</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="상태를-받은-header의-스타일-변경하기">상태를 받은 header의 스타일 변경하기</h2>

<p>isTop 상태를 받은 header가 <code class="language-plaintext highlighter-rouge">true</code>일 때에만 그림자를 보여주지 않도록 설정을 해, 스크롤이 되는 상황에서 지속적으로 그림자를 보여주도록 설정했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Chatrooms</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="p">...</span>
  <span class="kd">const</span> <span class="nx">isTop</span> <span class="o">=</span> <span class="nx">useIsTopState</span><span class="p">();</span>
	<span class="c1">// isTop 상태를 받아옴</span>
	<span class="p">...</span>
	<span class="o">&lt;</span><span class="nx">S</span><span class="p">.</span><span class="nx">Wrapper</span><span class="o">&gt;</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">HeaderWrapper</span> <span class="na">isTop</span><span class="p">=</span><span class="si">{</span><span class="nx">isTop</span><span class="si">}</span><span class="p">&gt;</span>
    // 사용하고자 하는 header에 적용
      <span class="p">&lt;</span><span class="nc">TopFixedWarning</span> <span class="na">text</span><span class="p">=</span><span class="s">'채팅 연결 끊김'</span> <span class="na">otherStyle</span><span class="p">=</span><span class="si">{</span><span class="nx">S</span><span class="p">.</span><span class="nx">TopFixedWarningStyle</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Header</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsConnected</span><span class="p">(</span><span class="o">!</span><span class="nx">isConnected</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
	...
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">HeaderWrapper</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">isTop</span><span class="p">:</span> <span class="nx">boolean</span> <span class="p">}</span><span class="o">&gt;</span><span class="s2">`
  </span><span class="p">${({</span> <span class="na">theme</span><span class="p">:</span> <span class="p">{</span> <span class="nx">colors</span><span class="p">,</span> <span class="nx">defaultWidth</span><span class="p">,</span> <span class="nx">defaultPadding</span> <span class="p">},</span> <span class="nx">isTop</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">css</span><span class="s2">`
    </span><span class="p">${</span><span class="nx">defaultWidth</span><span class="p">}</span><span class="s2">;
		...
    transition: all 0.3s;
    // 그림자가 부드럽게 사라지고 나타나기 위해 설정

    </span><span class="p">${</span><span class="o">!</span><span class="nx">isTop</span> <span class="o">&amp;&amp;</span>
    <span class="nx">css</span><span class="s2">`
      box-shadow: 2px 4px 6px rgba(0, 0, 0, 0.08);
      // 최상단에 있을 때에만 그림자가 안 보이도록 설정
    `</span><span class="p">}</span><span class="s2">
</span></code></pre></div></div>

<p>위 코드들을 적용해줌으로써, 스크롤 상황에 대한 그림자 표현을 할 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/1.png" alt="" width="75%" height="" /> 
</figure>

<h2 id="windowonscroll-값을-초기화해야-하는지">window.onscroll 값을 초기화해야 하는지</h2>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">},</span> <span class="p">[]);</span>
</code></pre></div></div>

<p>기존에는 위와 같이 화면을 나가는 경우 <code class="language-plaintext highlighter-rouge">window,onscroll</code>을 초기화하도록 설정을 해주었습니다. 초기화를 하지 않는 경우, 이 함수가 사용되지 않는 곳에서도 지속적으로 함수가 작동해 불필요한 연산이 될 것이라는 예상 때문이었습니다. 하지만, 아래와 같이 <code class="language-plaintext highlighter-rouge">useEffect</code>가 없어도 화면 전환 시 <code class="language-plaintext highlighter-rouge">onScroll</code>의 함수는 없어진다는 것을 확인할 수 있었습니다. (<code class="language-plaintext highlighter-rouge">console.log()</code>로 확인)</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/7.gif" alt="" width="75%" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="JAVASCRIPT" /><summary type="html"><![CDATA[스크롤 여부를 확인하는 방법 처음에는 new IntersactionObserver를 적용해 헤더의 바로 다음 요소가 가려지기 시작하면 스크롤이 되었다는 상태값을 바꿔주는 형식을 적용하고자 했었습니다. 하지만, 스크롤이 되는 순간부터 window.scrollY값이 바뀐다는 것을 알게 되었고, 굳이 더 복잡한 방식을 적용할 필요가 없다고 생각해 window.scrollY를 이용해 처리를 하도록 했습니다. 그리고 스크롤이 되는 상황에 대해서 화면이 인지하고 상태를 바꿔야하기 때문에, window.onscroll에 함수를 적용해주었습니다. const useIsTopState = () =&gt; { const [isTop, setIsTop] = useState(true); // 페이지의 최상단에 있는지를 나타내는 state window.onscroll = () =&gt; { setIsTop(!window.scrollY); // 스크롤되는 화면의 최상단에 있을 시 scrollY = 0 이므로 isTop이 true가 됨 }; return isTop; }; 상태를 받은 header의 스타일 변경하기 isTop 상태를 받은 header가 true일 때에만 그림자를 보여주지 않도록 설정을 해, 스크롤이 되는 상황에서 지속적으로 그림자를 보여주도록 설정했습니다. const Chatrooms = () =&gt; { ... const isTop = useIsTopState(); // isTop 상태를 받아옴 ... &lt;S.Wrapper&gt; &lt;S.HeaderWrapper isTop={isTop}&gt; // 사용하고자 하는 header에 적용 &lt;TopFixedWarning text='채팅 연결 끊김' otherStyle={S.TopFixedWarningStyle} /&gt; &lt;S.Header onClick={() =&gt; setIsConnected(!isConnected)}&gt; ... export const HeaderWrapper = styled.div&lt;{ isTop: boolean }&gt;` ${({ theme: { colors, defaultWidth, defaultPadding }, isTop }) =&gt; css` ${defaultWidth}; ... transition: all 0.3s; // 그림자가 부드럽게 사라지고 나타나기 위해 설정 ${!isTop &amp;&amp; css` box-shadow: 2px 4px 6px rgba(0, 0, 0, 0.08); // 최상단에 있을 때에만 그림자가 안 보이도록 설정 `} 위 코드들을 적용해줌으로써, 스크롤 상황에 대한 그림자 표현을 할 수 있었습니다. window.onscroll 값을 초기화해야 하는지 useEffect(() =&gt; { return () =&gt; { window.onscroll = null; }; }, []); 기존에는 위와 같이 화면을 나가는 경우 window,onscroll을 초기화하도록 설정을 해주었습니다. 초기화를 하지 않는 경우, 이 함수가 사용되지 않는 곳에서도 지속적으로 함수가 작동해 불필요한 연산이 될 것이라는 예상 때문이었습니다. 하지만, 아래와 같이 useEffect가 없어도 화면 전환 시 onScroll의 함수는 없어진다는 것을 확인할 수 있었습니다. (console.log()로 확인)]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">textarea 태그 Enter 처리 문제</title><link href="http://localhost:4000/react/2022/10/25/textarea-%EC%97%94%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C/" rel="alternate" type="text/html" title="textarea 태그 Enter 처리 문제" /><published>2022-10-25T00:00:00+09:00</published><updated>2022-10-25T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/25/textarea%20%EC%97%94%ED%84%B0%20%EC%B2%98%EB%A6%AC%20%EB%AC%B8%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/react/2022/10/25/textarea-%EC%97%94%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C/"><![CDATA[<h2 id="input-태그를-textarea-태그로-바꾸기">input 태그를 textarea 태그로 바꾸기</h2>

<p>기존에 <code class="language-plaintext highlighter-rouge">input</code> 태그로 되어있던 채팅 입력창을 <code class="language-plaintext highlighter-rouge">textarea</code> 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. <code class="language-plaintext highlighter-rouge">input</code> 태그의 경우 Enter 키를 입력 시 바로 <code class="language-plaintext highlighter-rouge">submit</code> 이벤트가 발생하게 되는 것에 반해, <code class="language-plaintext highlighter-rouge">textarea</code>는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다.</p>

<h2 id="onkeydown-이벤트-적용">onKeyDown 이벤트 적용</h2>

<p>Enter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 <code class="language-plaintext highlighter-rouge">onKeyDown</code>이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">Enter</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// Enter 키 여부 확인</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Shift 키 여부 확인</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
    <span class="c1">// 한 줄 띄운 값으로 기존 채팅값을 변경</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 <code class="language-plaintext highlighter-rouge">onChange</code> 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleChangeChatValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">ChangeEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">inputType</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">nativeEvent</span> <span class="k">as</span> <span class="nx">any</span><span class="p">;</span>
  <span class="c1">//</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">inputType</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">insertLineBreak</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘<code class="language-plaintext highlighter-rouge">onChange</code> 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 <code class="language-plaintext highlighter-rouge">nativeEvent</code> 객체 내에 존재하는 <code class="language-plaintext highlighter-rouge">inputType</code>을 찾아 Enter를 누를 시 보여주게 되는 ‘<code class="language-plaintext highlighter-rouge">insertLineBreak</code>’을 사용했습니다.<br />
(이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 <code class="language-plaintext highlighter-rouge">any</code>로 처리했습니다…)</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/1.png" alt="" width="100%" height="" /> 
</figure>

<p>위 과정을 통해서 Enter키를 누른 상황에는 <code class="language-plaintext highlighter-rouge">onKeyDown</code>, 누르지 않은 상황은 <code class="language-plaintext highlighter-rouge">onChange</code>에서 처리를 하는 방식을 사용했습니다.</p>

<h2 id="enter-중복-처리-문제">Enter 중복 처리 문제</h2>

<p>하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/2.gif" alt="" width="50%" height="" /> 
</figure>

<p>이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 <code class="language-plaintext highlighter-rouge">onKeyDown</code> 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/3.png" alt="" width="" height="" /> 
</figure>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/4.png" alt="" width="" height="" /> 
</figure>

<p>영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 <code class="language-plaintext highlighter-rouge">keyCode</code>를 사용하는 것이었는데, <code class="language-plaintext highlighter-rouge">keyCode</code>를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 <code class="language-plaintext highlighter-rouge">keyCode</code> 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleKeyDownChat</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">:</span> <span class="nx">KeyboardEvent</span><span class="o">&lt;</span><span class="nx">HTMLTextAreaElement</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">shiftKey</span><span class="p">,</span> <span class="nx">keyCode</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span><span class="p">;</span>
  <span class="c1">// 'keyCode' is deprecated but error occurs when just use 'key' in korean</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">Enter</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">keyCode</span> <span class="o">!==</span> <span class="mi">13</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shiftKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sendCurChat</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">setChatValue</span><span class="p">(</span><span class="nx">chatValue</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="띄워쓰기-스타일-적용하기">띄워쓰기 스타일 적용하기</h3>

<figure class="figure  figure--center">
  <img class="image" src="/image/221025/5.png" alt="" width="50%" height="" /> 
</figure>

<p>띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘<code class="language-plaintext highlighter-rouge">\n</code>’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">white-space</span><span class="o">:</span> <span class="nt">pre-wrap</span><span class="o">;</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[input 태그를 textarea 태그로 바꾸기 기존에 input 태그로 되어있던 채팅 입력창을 textarea 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. input 태그의 경우 Enter 키를 입력 시 바로 submit 이벤트가 발생하게 되는 것에 반해, textarea는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다. onKeyDown 이벤트 적용 Enter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 onKeyDown이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다. const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey } = event; if (key !== "Enter") return; // Enter 키 여부 확인 if (!shiftKey) { // Shift 키 여부 확인 sendCurChat(); } else { setChatValue(chatValue + "\n"); // 한 줄 띄운 값으로 기존 채팅값을 변경 } }; 그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 onChange 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다. const handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { inputType } = event.nativeEvent as any; // if (inputType === 'insertLineBreak') return; setChatValue(event.target.value); }; 이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘onChange 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 nativeEvent 객체 내에 존재하는 inputType을 찾아 Enter를 누를 시 보여주게 되는 ‘insertLineBreak’을 사용했습니다. (이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 any로 처리했습니다…) 위 과정을 통해서 Enter키를 누른 상황에는 onKeyDown, 누르지 않은 상황은 onChange에서 처리를 하는 방식을 사용했습니다. Enter 중복 처리 문제 하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다. 이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 onKeyDown 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다. 영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 keyCode를 사용하는 것이었는데, keyCode를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 keyCode 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다. const handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; { const { key, shiftKey, keyCode } = event; // 'keyCode' is deprecated but error occurs when just use 'key' in korean if (key !== "Enter" || keyCode !== 13) return; if (!shiftKey) { sendCurChat(); } else { setChatValue(chatValue + "\n"); } }; 띄워쓰기 스타일 적용하기 띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘\n’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다. white-space: pre-wrap;]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">PORT ∙ DNS ∙ URI</title><link href="http://localhost:4000/http/2022/10/24/PORT-DNS-URI/" rel="alternate" type="text/html" title="PORT ∙ DNS ∙ URI" /><published>2022-10-24T00:00:00+09:00</published><updated>2022-10-24T00:00:00+09:00</updated><id>http://localhost:4000/http/2022/10/24/PORT%20%E2%88%99%20DNS%20%E2%88%99%20URI</id><content type="html" xml:base="http://localhost:4000/http/2022/10/24/PORT-DNS-URI/"><![CDATA[<h2 id="port">PORT</h2>

<p>PORT란 IP 내 프로세스 구분을 위해 사용하는 번호입니다. 보통 한 번에 둘 이상의 애플리케이션을 연결해야하는 상황에서 사용합니다.<br />
통신을 주고 받으면서 패킷이 오는 경우, 해당 패킷이 어느 곳에서 오는 패킷인지를 구분해야하는 문제가 발생합니다. 이 상황에서 <strong>데이터를 전송할 목적지 서버를 찾는 것이 IP, 서버 내에서 구분된 애플리케이션을 찾는 것이 PORT라고 볼 수 있습니다.</strong></p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221024/Untitled-13.png" alt="" width="50%" height="" /> 
</figure>

<h3 id="port의-특징">PORT의 특징</h3>

<ol>
  <li>같은 IP 내 프로세스 구분
    <ul>
      <li>아래 예시와 같이, 80포트로 클라이언트가 메세지를 보내고, 서버에서는 10010번 포트로 응답을 보내게 되면, 포트를 뒤에 붙여서 같이 보내게 됩니다.</li>
      <li>이 상황에서 IP는 아파트, PORT는 몇 동 ∙ 몇 호라고 생각할 수 있습니다.</li>
    </ul>
  </li>
</ol>

<figure class="figure  figure--center">
  <img class="image" src="/image/221024/Untitled-14.png" alt="" width="" height="" /> 
</figure>

<ol>
  <li>0 - 65535가 할당 가능</li>
  <li>1023까지는 잘 알려져서 일반적으로 사용하지 않음
    <ul>
      <li>FTP : 20,21</li>
      <li>TELNET : 23</li>
      <li>HTTP : 80</li>
      <li>HTTPS : 443</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="dns">DNS</h2>

<p>DNS는 Domain Name System의 줄임말로, 호스트 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행하기 위해 개발되었습니다.<br />
일종의 전화번호부와 같은 역할을 수행하며, IP가 숫자로만 이루어져 기억하기 어려운 것과 달리 특정 이름을 갖고 있어 기억을 하기에 용이합니다.<br />
접근을 원하는 경우 도메인 명으로 DNS 서버에 먼저 접근한 뒤, 해당 IP를 받아올 수 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221024/Untitled-15.png" alt="" width="" height="" /> 
</figure>

<hr />

<h2 id="uri">URI</h2>

<p>URI는 Uniform Resource Identifier의 줄임말로, 특정 리소스를 식별하는 역할을 수행합니다.</p>

<h3 id="uri-url-urn의-차이">URI, URL, URN의 차이</h3>

<p>URI 내에 URL(로케이터 : locator), URN(이름 : name) 두 가지가 존재합니다.<br />
URL은 리소스가 있는 위치를 지정하고, URN은 리소스에 자체적인 이름을 부여하는데, 이로 인해 URN 이름만으로 실제 리소스를 받는 방법이 보편화 되지 않아 URL을 주로 사용하게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221024/Untitled-16.png" alt="" width="" height="" /> 
</figure>

<h3 id="url의-특징">URL의 특징</h3>

<ul>
  <li>전체 문법 : scheme://[userInfo@]host:[:port]/[/path][?query][#fragment]</li>
  <li>scheme
    <ul>
      <li>주로 프로토콜이 사용되며 자원 접근 규칙으로서, http, https 등이 존재합니다.</li>
      <li>http는 80, https는 443 포트를 주로 사용하며 이들은 생략이 가능합니다.
(https는 http에 보안이 추가된 형태)</li>
    </ul>
  </li>
  <li>userInfo : URL에 사용자 정보를 포함해서 인증할 때 사용하나, 거의 사용되지 않습니다.</li>
  <li>host : 도메인명, IP 주소를 직접 넣어서 사용합니다.</li>
  <li>port : 접속 포트로, 일반적으로 웹 브라우저에서 생략이 가능합니다.</li>
  <li>path : 리소스 경로를 나타내며 계층적 구조로 이루어지며, ‘<code class="language-plaintext highlighter-rouge">profile/1223</code>’ 과 같은 형태를 띕니다.</li>
  <li>query : key=value의 형태로 이루어지며, ?로 시작하고 &amp;으로 추가가 가능합니다. query parameter, query string(모두 문자로 넘어가기 때문에) 등으로 불립니다.</li>
  <li>fragment : html 내부 북마크 등에 사용합니다. 서버로 전송되지는 않습니다.</li>
</ul>

<hr />

<h2 id="uri-접속-흐름">URI 접속 흐름</h2>

<figure class="figure  figure--center">
  <img class="image" src="/image/221024/Untitled-17.png" alt="" width="" height="" /> 
</figure>

<ol>
  <li>DNS 조회, PORT 조회</li>
  <li>HTTP 요청 메시지 생성</li>
  <li>Socket Library에서 handshake 과정을 통해 서버와 연결</li>
  <li>데이터 전송</li>
  <li>서버가 HTTP 응답 메시지 생성</li>
  <li>응답 패킷이 클라이언트에 도착</li>
  <li>클라이언트에서 해당 내용으로 렌더링</li>
</ol>]]></content><author><name>JinJeon</name></author><category term="HTTP" /><summary type="html"><![CDATA[PORT PORT란 IP 내 프로세스 구분을 위해 사용하는 번호입니다. 보통 한 번에 둘 이상의 애플리케이션을 연결해야하는 상황에서 사용합니다. 통신을 주고 받으면서 패킷이 오는 경우, 해당 패킷이 어느 곳에서 오는 패킷인지를 구분해야하는 문제가 발생합니다. 이 상황에서 데이터를 전송할 목적지 서버를 찾는 것이 IP, 서버 내에서 구분된 애플리케이션을 찾는 것이 PORT라고 볼 수 있습니다. PORT의 특징 같은 IP 내 프로세스 구분 아래 예시와 같이, 80포트로 클라이언트가 메세지를 보내고, 서버에서는 10010번 포트로 응답을 보내게 되면, 포트를 뒤에 붙여서 같이 보내게 됩니다. 이 상황에서 IP는 아파트, PORT는 몇 동 ∙ 몇 호라고 생각할 수 있습니다. 0 - 65535가 할당 가능 1023까지는 잘 알려져서 일반적으로 사용하지 않음 FTP : 20,21 TELNET : 23 HTTP : 80 HTTPS : 443 DNS DNS는 Domain Name System의 줄임말로, 호스트 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행하기 위해 개발되었습니다. 일종의 전화번호부와 같은 역할을 수행하며, IP가 숫자로만 이루어져 기억하기 어려운 것과 달리 특정 이름을 갖고 있어 기억을 하기에 용이합니다. 접근을 원하는 경우 도메인 명으로 DNS 서버에 먼저 접근한 뒤, 해당 IP를 받아올 수 있습니다. URI URI는 Uniform Resource Identifier의 줄임말로, 특정 리소스를 식별하는 역할을 수행합니다. URI, URL, URN의 차이 URI 내에 URL(로케이터 : locator), URN(이름 : name) 두 가지가 존재합니다. URL은 리소스가 있는 위치를 지정하고, URN은 리소스에 자체적인 이름을 부여하는데, 이로 인해 URN 이름만으로 실제 리소스를 받는 방법이 보편화 되지 않아 URL을 주로 사용하게 됩니다. URL의 특징 전체 문법 : scheme://[userInfo@]host:[:port]/[/path][?query][#fragment] scheme 주로 프로토콜이 사용되며 자원 접근 규칙으로서, http, https 등이 존재합니다. http는 80, https는 443 포트를 주로 사용하며 이들은 생략이 가능합니다. (https는 http에 보안이 추가된 형태) userInfo : URL에 사용자 정보를 포함해서 인증할 때 사용하나, 거의 사용되지 않습니다. host : 도메인명, IP 주소를 직접 넣어서 사용합니다. port : 접속 포트로, 일반적으로 웹 브라우저에서 생략이 가능합니다. path : 리소스 경로를 나타내며 계층적 구조로 이루어지며, ‘profile/1223’ 과 같은 형태를 띕니다. query : key=value의 형태로 이루어지며, ?로 시작하고 &amp;으로 추가가 가능합니다. query parameter, query string(모두 문자로 넘어가기 때문에) 등으로 불립니다. fragment : html 내부 북마크 등에 사용합니다. 서버로 전송되지는 않습니다. URI 접속 흐름 DNS 조회, PORT 조회 HTTP 요청 메시지 생성 Socket Library에서 handshake 과정을 통해 서버와 연결 데이터 전송 서버가 HTTP 응답 메시지 생성 응답 패킷이 클라이언트에 도착 클라이언트에서 해당 내용으로 렌더링]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">IP, TCP ∙ UDP</title><link href="http://localhost:4000/http/2022/10/23/IP_TCP_UDP/" rel="alternate" type="text/html" title="IP, TCP ∙ UDP" /><published>2022-10-23T00:00:00+09:00</published><updated>2022-10-23T00:00:00+09:00</updated><id>http://localhost:4000/http/2022/10/23/IP_TCP_UDP</id><content type="html" xml:base="http://localhost:4000/http/2022/10/23/IP_TCP_UDP/"><![CDATA[<h2 id="ipinternet-protocol">IP(Internet Protocol)</h2>

<p>IP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다.</p>

<p>클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 <strong>‘패킷’</strong>이라는 단위를 사용합니다.</p>

<p><strong>클라이언트 주소, 서버 주소, 보낼 내용</strong> 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221023/Untitled-8.png" alt="" width="" height="" /> 
</figure>

<h3 id="문제점">문제점</h3>

<ol>
  <li><strong>비연결성</strong> : 패킷 대상이 없거나 불능이어도 보내게 됩니다.</li>
  <li><strong>비신뢰성</strong> : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다.
    <ul>
      <li>중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다.</li>
      <li>1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다.</li>
    </ul>
  </li>
  <li><strong>프로그램 구분</strong> : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다.</li>
</ol>

<hr />

<h2 id="tcpudp">TCP/UDP</h2>

<p>인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다.</p>

<ol>
  <li>애플리케이션 계층 - HTTP, FTP</li>
  <li>전송 계층 - TDP, UDP (IP 보완)</li>
  <li>인터넷 계층 - IP</li>
  <li>네트워크 인터페이스 계층 - LAN 드라이버 등</li>
</ol>

<h3 id="순서">순서</h3>

<figure class="figure  figure--center">
  <img class="image" src="/image/221023/Untitled-9.png" alt="" width="" height="" /> 
</figure>

<ol>
  <li>일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달</li>
  <li>OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함</li>
  <li>이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄</li>
  <li>서버로 전송</li>
</ol>

<h3 id="ip-tcp-패킷-정보">IP, TCP 패킷 정보</h3>

<p>패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다.</p>

<p>TCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221023/Untitled-10.png" alt="" width="" height="" /> 
</figure>

<h3 id="tcp의-특징">TCP의 특징</h3>

<ol>
  <li>TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다.</li>
  <li>먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake)</li>
  <li>데이터가 상대에게 제대로 보내졌는지를 확인하는 <strong>데이터 전달 보증</strong>이 이루어집니다.</li>
  <li>데이터가 보낸 순서대로 도착하도록 하는 <strong>순서 보증</strong>의 역할을 합니다.</li>
  <li>위와 같은 기능들을 갖고 있어 <strong>신뢰가능</strong>한 프로토콜입니다.</li>
</ol>

<h3 id="tcp-3-way-handshake">TCP 3 way handshake</h3>

<p>클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다.</p>

<ol>
  <li>클라이언트가 서버에게 요청</li>
  <li>서버가 요청을 수락하고 다시 클라이언트에게 요청</li>
  <li>클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송)</li>
  <li>데이터 전송</li>
</ol>

<figure class="figure  figure--center">
  <img class="image" src="/image/221023/Untitled-11.png" alt="" width="" height="" /> 
</figure>

<p>TCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 <strong>클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미</strong>합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다.</p>

<h3 id="장점">장점</h3>

<ul>
  <li>전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다.</li>
  <li>순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.)</li>
</ul>

<figure class="figure  figure--center">
  <img class="image" src="/image/221023/Untitled-12.png" alt="" width="" height="" /> 
</figure>

<hr />

<h3 id="udp">UDP</h3>

<p>사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다.</p>

<h3 id="udp의-특징">UDP의 특징</h3>

<ul>
  <li>하얀 도화지에 비유되며 기능이 거의 없습니다.</li>
  <li>연결 지향성을 띄며 3-way handshake가 없습니다.</li>
  <li>데이터 전달 보증이나 순서 보증이 없습니다.</li>
  <li>IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, <strong>각 패킷의 용도를 구분하기 위해 PORT를 사용</strong>하며. <strong>체크섬은 메세지가 제대로 된 것인지 확인하는 용도</strong>로 사용됩니다.</li>
  <li>UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다.</li>
  <li>주목받는 이유로 아래와 같은 사항들이 있습니다.
    <ol>
      <li>TCP의 단점인 3 way handshake로 인한 시간</li>
      <li>여러 데이터들로 인한 데이터 양 증가 → 속도 감소</li>
      <li>TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움</li>
      <li>무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음</li>
    </ol>
  </li>
  <li>UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.</li>
</ul>]]></content><author><name>JinJeon</name></author><category term="HTTP" /><summary type="html"><![CDATA[IP(Internet Protocol) IP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다. 클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 ‘패킷’이라는 단위를 사용합니다. 클라이언트 주소, 서버 주소, 보낼 내용 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다. 문제점 비연결성 : 패킷 대상이 없거나 불능이어도 보내게 됩니다. 비신뢰성 : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다. 중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다. 1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다. 프로그램 구분 : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다. TCP/UDP 인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다. 애플리케이션 계층 - HTTP, FTP 전송 계층 - TDP, UDP (IP 보완) 인터넷 계층 - IP 네트워크 인터페이스 계층 - LAN 드라이버 등 순서 일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달 OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함 이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄 서버로 전송 IP, TCP 패킷 정보 패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다. TCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다. TCP의 특징 TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다. 먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake) 데이터가 상대에게 제대로 보내졌는지를 확인하는 데이터 전달 보증이 이루어집니다. 데이터가 보낸 순서대로 도착하도록 하는 순서 보증의 역할을 합니다. 위와 같은 기능들을 갖고 있어 신뢰가능한 프로토콜입니다. TCP 3 way handshake 클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다. 클라이언트가 서버에게 요청 서버가 요청을 수락하고 다시 클라이언트에게 요청 클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송) 데이터 전송 TCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다. 장점 전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다. 순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.) UDP 사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다. UDP의 특징 하얀 도화지에 비유되며 기능이 거의 없습니다. 연결 지향성을 띄며 3-way handshake가 없습니다. 데이터 전달 보증이나 순서 보증이 없습니다. IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, 각 패킷의 용도를 구분하기 위해 PORT를 사용하며. 체크섬은 메세지가 제대로 된 것인지 확인하는 용도로 사용됩니다. UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다. 주목받는 이유로 아래와 같은 사항들이 있습니다. TCP의 단점인 3 way handshake로 인한 시간 여러 데이터들로 인한 데이터 양 증가 → 속도 감소 TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움 무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음 UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">stomp(socket) 연결 실패 시 알림</title><link href="http://localhost:4000/react/2022/10/22/stomp(socket)-%EC%97%B0%EA%B2%B0-%EC%8B%A4%ED%8C%A8/" rel="alternate" type="text/html" title="stomp(socket) 연결 실패 시 알림" /><published>2022-10-22T00:00:00+09:00</published><updated>2022-10-22T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/22/stomp(socket)%20%EC%97%B0%EA%B2%B0%20%EC%8B%A4%ED%8C%A8</id><content type="html" xml:base="http://localhost:4000/react/2022/10/22/stomp(socket)-%EC%97%B0%EA%B2%B0-%EC%8B%A4%ED%8C%A8/"><![CDATA[<p>현재 socket과 관련된 작업을 하면서 socket이 연결됐을 때에 대한 처리는 모두 완료가 되었으나, socket이 처음부터 연결되지 않은 상황에 대해서는 작업이 이루어지지 않았습니다. 이로 인해 사용자는 채팅, 알림 등 socket이 연결되지지 않은 상황임을 인지하지 못하고 계속 서비스를 이용하게 되어 문제가 발생합니다. 그래서 socket이 처음부터 연결되지 않거나, 중간에 끊긴 상황에 대한 알림을 줄 수 있어야 합니다.</p>

<h3 id="socket의-연결-여부를-확인하는-방법">socket의 연결 여부를 확인하는 방법</h3>

<p>우선적으로 socket이 연결 여부를 확인하는 값이 필요했습니다. 그래서 socket에 직접적인 socket 연결 여부를 확인하는 값을 가져오고자 했었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
</code></pre></div></div>

<p>위 코드를 입력한 후, 해당 값을 console을 통해 확인해보면, 아래와 같이 connected라는 값이 있고, 이 값을 통해서 연결 여부를 확인해줄 수 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221022/1.png" alt="" width="" height="" /> 
</figure>

<p>하지만, socket의 첫 연결은 무조건적으로 <code class="language-plaintext highlighter-rouge">false</code>에서 시작하기 때문에, 위 <code class="language-plaintext highlighter-rouge">connected</code>가 바뀌는 것을 따로 기다린 후 원하는 결과를 만드는 것보다, 연결이 된 후에 실행할 수 있는 콜백함수를 넘기는 것이 더 낫다는 판단을 했습니다. 그리고 socket이 연결되었음을 확인할 수 있는 상태(atom)를 하나 갖는 것도 필요하다고 판단했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 소켓 연결 여부를 갖고 있는 atom</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">socketConnectState</span> <span class="o">=</span> <span class="nx">atom</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span><span class="p">({</span>
  <span class="na">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">socketConnect</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">default</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
<span class="p">...</span>

<span class="kd">type</span> <span class="nx">ConnectStompParamsType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">noticeParams</span><span class="p">:</span> <span class="nx">subscribeNoticeParamsType</span><span class="p">;</span>
  <span class="nl">chatParams</span><span class="p">:</span> <span class="nx">subscribeChatParamsType</span><span class="p">;</span>
  <span class="nl">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
  <span class="nl">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">connectStomp</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">noticeParams</span><span class="p">,</span>
  <span class="nx">chatParams</span><span class="p">,</span>
  <span class="nx">onConnect</span><span class="p">,</span>
  <span class="nx">onError</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">ConnectStompParamsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
  <span class="k">try</span> <span class="p">{</span>
		<span class="c1">// stompClient로 성공적으로 연결될 경우 첫번째 콜백, 에러가 나올 시 두번째 콜백이 실행됨</span>
    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span>
      <span class="nx">headers</span><span class="p">,</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">onConnect</span><span class="p">();</span>
        <span class="nx">subscribeNotice</span><span class="p">(</span><span class="nx">noticeParams</span><span class="p">);</span>
        <span class="nx">subscribeChat</span><span class="p">(</span><span class="nx">chatParams</span><span class="p">);</span>
      <span class="p">},</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">onError</span><span class="p">();</span>
      <span class="p">},</span>
    <span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">setSocketConnect</span> <span class="o">=</span> <span class="nx">useSetRecoilState</span><span class="p">(</span><span class="nx">socketConnectState</span><span class="p">);</span>
<span class="c1">// 소켓 연결여부를 확인하는 atom을 불러옴</span>
<span class="p">...</span>
<span class="nx">connectStomp</span><span class="p">({</span>
	<span class="c1">// 연결 성공, 실패 여부에 따라 atom의 값이 바뀌도록 설정</span>
  <span class="na">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
  <span class="na">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
  <span class="na">noticeParams</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">entryIds</span><span class="p">,</span>
    <span class="nx">keywordIds</span><span class="p">,</span>
    <span class="na">onSubscribeEntries</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
    <span class="na">onSubscribeKeywords</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="na">chatParams</span><span class="p">:</span> <span class="p">{</span> <span class="nx">chatroomIds</span><span class="p">,</span> <span class="nx">onReceiveChat</span> <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위와 같은 방식을 통해 소켓의 연결 성공, 실패에 따른 atom 값의 설정이 가능해졌습니다. 하지만, 여기서 발생한 또 다른 문제점은 정상적으로 연결이 되는 상황에 대해서도 처음에는 <code class="language-plaintext highlighter-rouge">false</code> 값을 갖고, 이후 연결이 된 상황에서 <code class="language-plaintext highlighter-rouge">true</code>값을 갖는다는 점입니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221022/2.gif" alt="" width="" height="" /> 
</figure>

<p><code class="language-plaintext highlighter-rouge">true</code>값을 가짐으로 인해, 연결 유무를 갖고 보일지에 대한 유무를 갖고 있는 컴포넌트는 처음에 보였다가 사라지는 형태로 유지됩니다.</p>

<h3 id="연결-상태의-초기값을-true로-할-때의-문제점">연결 상태의 초기값을 ‘true’로 할 때의 문제점</h3>

<p>이를 해결하기 위한 방법으로, 처음에 <code class="language-plaintext highlighter-rouge">true</code>로 설정된 뒤, 연결이 잘못된 상황이 발생할 때에만 <code class="language-plaintext highlighter-rouge">false</code>가 나오는 것을 고려했습니다. 하지만, 이 방법으로 진행할 시, 이후 이 연결 여부를 갖고 즉각적인 행동을 하게 되는 다른 컴포넌트가 존재할 때 문제가 발생하기 때문에, <code class="language-plaintext highlighter-rouge">true</code>를 초기값으로 설정하는 것을 자제했습니다.</p>

<p>그래서 이후 결정한 방법은 사용하는 컴포넌트 내에서 시간 제한을 두는 방법을 쓰게 됐습니다.</p>

<h3 id="자체적인-시간-제한을-두어-연결-여부-확인하기">자체적인 시간 제한을 두어 연결 여부 확인하기</h3>

<p>현재 연결 여부를 사용하는 컴포넌트 <code class="language-plaintext highlighter-rouge">TopFixedWarning</code>에서 자체적인 연결 여부 관련 상태를 둠으로써 문제를 해결할 수 있었습니다. 거기에, 이 컴포넌트에서만 따로 시간 제한을 두어 일정 시간이 지난 상황에서도 연결이 제대로 되지 않은 경우 연결이 되지 않았다는 상태로 바뀌도록 설정했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">waitingCheckTime</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="c1">// ms</span>

<span class="kd">const</span> <span class="nx">TopFixedWarinng</span> <span class="o">=</span> <span class="p">({</span>
  <span class="nx">text</span><span class="p">,</span>
  <span class="nx">isShowed</span><span class="p">,</span>
  <span class="nx">otherStyle</span><span class="p">,</span>
<span class="p">}:</span> <span class="nx">TopFixedWarningPropsType</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">socketConnect</span> <span class="o">=</span> <span class="nx">useRecoilValue</span><span class="p">(</span><span class="nx">socketConnectState</span><span class="p">);</span>
  <span class="c1">// 앱 전체적으로 사용하는 소켓 연결 여부 상태를 가져옴</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">isConnected</span><span class="p">,</span> <span class="nx">setIsConnected</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="c1">// 현재 컴포넌트에서만 사용하는 연결여부 확인 상태</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">timeOver</span><span class="p">,</span> <span class="nx">setTimeOver</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="c1">// 시간 초과 여부를 확인하는 상태</span>

  <span class="kd">const</span> <span class="nx">handleClickEvent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="c1">// 앱에서의 소켓 연결 상태에 변화가 있을 시, 동시에 시간이 이미 초과한 상황에서 자체적인 소켓 연결 여부를 지정할 수 있게 함</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">timeOver</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">setIsConnected</span><span class="p">(</span><span class="nx">socketConnect</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">socketConnect</span><span class="p">]);</span>

  <span class="c1">// time out을 설정해, 일정 시간이 지나간 경우 timeover 상태를 true로 바꾸고 소켓 연결 여부를 현재 컴포넌트에 알림</span>
  <span class="nx">useTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeOver</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="nx">setIsConnected</span><span class="p">(</span><span class="nx">socketConnect</span><span class="p">);</span>
  <span class="p">},</span> <span class="nx">waitingCheckTime</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span>
      <span class="na">isShowed</span><span class="p">=</span><span class="si">{</span><span class="nx">isShowed</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isConnected</span><span class="si">}</span> <span class="c1">// 자체적으로 받은 props와 자체적인 연결 여부 상태를 통해 보여줄 지에 대한 여부를 지정함</span>
      <span class="na">otherStyle</span><span class="p">=</span><span class="si">{</span><span class="nx">otherStyle</span><span class="si">}</span>
      <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">handleClickEvent</span><span class="si">}</span>
    <span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"Warning"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">1.25</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">TextWrapper</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">text</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">TextWrapper</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">Wrapper</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>컴포넌트 내에 자체적인 연결 상태를 지정해준 이유는 소켓 연결 시간이 사용자의 예상 시간보다 긴 경우, 사용자가 소켓과 관련된 기능이 동작하지 않는다는 것을 예상하지 못한 채 계속 활동을 이어갈 수 있기 때문에, 자체적인 연결 상태 지정(<code class="language-plaintext highlighter-rouge">isConnected</code>)과 시간 초과 여부(<code class="language-plaintext highlighter-rouge">timeover</code>)를 두어 특정 시간(여기서는 5초)이 지날 시 소켓의 상태를 즉각 반영하도록 설정했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221022/3.gif" alt="" width="" height="" /> 
</figure>

<p>위와 같이 특정 시간(5초)가 지나가면 소켓이 연결되지 않을 시 문제가 있음을 알려줄 수 있게 됩니다.</p>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[현재 socket과 관련된 작업을 하면서 socket이 연결됐을 때에 대한 처리는 모두 완료가 되었으나, socket이 처음부터 연결되지 않은 상황에 대해서는 작업이 이루어지지 않았습니다. 이로 인해 사용자는 채팅, 알림 등 socket이 연결되지지 않은 상황임을 인지하지 못하고 계속 서비스를 이용하게 되어 문제가 발생합니다. 그래서 socket이 처음부터 연결되지 않거나, 중간에 끊긴 상황에 대한 알림을 줄 수 있어야 합니다. socket의 연결 여부를 확인하는 방법 우선적으로 socket이 연결 여부를 확인하는 값이 필요했습니다. 그래서 socket에 직접적인 socket 연결 여부를 확인하는 값을 가져오고자 했었습니다. export const stompClient = StompJs.over(sock); 위 코드를 입력한 후, 해당 값을 console을 통해 확인해보면, 아래와 같이 connected라는 값이 있고, 이 값을 통해서 연결 여부를 확인해줄 수 있습니다. 하지만, socket의 첫 연결은 무조건적으로 false에서 시작하기 때문에, 위 connected가 바뀌는 것을 따로 기다린 후 원하는 결과를 만드는 것보다, 연결이 된 후에 실행할 수 있는 콜백함수를 넘기는 것이 더 낫다는 판단을 했습니다. 그리고 socket이 연결되었음을 확인할 수 있는 상태(atom)를 하나 갖는 것도 필요하다고 판단했습니다. // 소켓 연결 여부를 갖고 있는 atom export const socketConnectState = atom&lt;boolean&gt;({ key: "socketConnect", default: false, }); export const stompClient = StompJs.over(sock); ... type ConnectStompParamsType = { noticeParams: subscribeNoticeParamsType; chatParams: subscribeChatParamsType; onConnect: () =&gt; void; onError: () =&gt; void; }; export const connectStomp = ({ noticeParams, chatParams, onConnect, onError, }: ConnectStompParamsType) =&gt; { const headers = getAuthHeaders(); try { // stompClient로 성공적으로 연결될 경우 첫번째 콜백, 에러가 나올 시 두번째 콜백이 실행됨 stompClient.connect( headers, () =&gt; { onConnect(); subscribeNotice(noticeParams); subscribeChat(chatParams); }, () =&gt; { onError(); }, ); } catch (error) { console.log(error); } }; const setSocketConnect = useSetRecoilState(socketConnectState); // 소켓 연결여부를 확인하는 atom을 불러옴 ... connectStomp({ // 연결 성공, 실패 여부에 따라 atom의 값이 바뀌도록 설정 onError: () =&gt; setSocketConnect(false), onConnect: () =&gt; setSocketConnect(true), noticeParams: { entryIds, keywordIds, onSubscribeEntries: onSubscribeNotice, onSubscribeKeywords: onSubscribeNotice, }, chatParams: { chatroomIds, onReceiveChat }, }); 위와 같은 방식을 통해 소켓의 연결 성공, 실패에 따른 atom 값의 설정이 가능해졌습니다. 하지만, 여기서 발생한 또 다른 문제점은 정상적으로 연결이 되는 상황에 대해서도 처음에는 false 값을 갖고, 이후 연결이 된 상황에서 true값을 갖는다는 점입니다. true값을 가짐으로 인해, 연결 유무를 갖고 보일지에 대한 유무를 갖고 있는 컴포넌트는 처음에 보였다가 사라지는 형태로 유지됩니다. 연결 상태의 초기값을 ‘true’로 할 때의 문제점 이를 해결하기 위한 방법으로, 처음에 true로 설정된 뒤, 연결이 잘못된 상황이 발생할 때에만 false가 나오는 것을 고려했습니다. 하지만, 이 방법으로 진행할 시, 이후 이 연결 여부를 갖고 즉각적인 행동을 하게 되는 다른 컴포넌트가 존재할 때 문제가 발생하기 때문에, true를 초기값으로 설정하는 것을 자제했습니다. 그래서 이후 결정한 방법은 사용하는 컴포넌트 내에서 시간 제한을 두는 방법을 쓰게 됐습니다. 자체적인 시간 제한을 두어 연결 여부 확인하기 현재 연결 여부를 사용하는 컴포넌트 TopFixedWarning에서 자체적인 연결 여부 관련 상태를 둠으로써 문제를 해결할 수 있었습니다. 거기에, 이 컴포넌트에서만 따로 시간 제한을 두어 일정 시간이 지난 상황에서도 연결이 제대로 되지 않은 경우 연결이 되지 않았다는 상태로 바뀌도록 설정했습니다. const waitingCheckTime = 5000; // ms const TopFixedWarinng = ({ text, isShowed, otherStyle, }: TopFixedWarningPropsType) =&gt; { const socketConnect = useRecoilValue(socketConnectState); // 앱 전체적으로 사용하는 소켓 연결 여부 상태를 가져옴 const [isConnected, setIsConnected] = useState(true); // 현재 컴포넌트에서만 사용하는 연결여부 확인 상태 const [timeOver, setTimeOver] = useState(false); // 시간 초과 여부를 확인하는 상태 const handleClickEvent = () =&gt; { window.location.reload(); }; // 앱에서의 소켓 연결 상태에 변화가 있을 시, 동시에 시간이 이미 초과한 상황에서 자체적인 소켓 연결 여부를 지정할 수 있게 함 useEffect(() =&gt; { if (!timeOver) return; setIsConnected(socketConnect); }, [socketConnect]); // time out을 설정해, 일정 시간이 지나간 경우 timeover 상태를 true로 바꾸고 소켓 연결 여부를 현재 컴포넌트에 알림 useTimeout(() =&gt; { setTimeOver(true); setIsConnected(socketConnect); }, waitingCheckTime); return ( &lt;S.Wrapper isShowed={isShowed || !isConnected} // 자체적으로 받은 props와 자체적인 연결 여부 상태를 통해 보여줄 지에 대한 여부를 지정함 otherStyle={otherStyle} onClick={handleClickEvent} &gt; &lt;Icon iconName="Warning" iconSize={1.25} /&gt; &lt;S.TextWrapper&gt;{text}&lt;/S.TextWrapper&gt; &lt;/S.Wrapper&gt; ); }; 컴포넌트 내에 자체적인 연결 상태를 지정해준 이유는 소켓 연결 시간이 사용자의 예상 시간보다 긴 경우, 사용자가 소켓과 관련된 기능이 동작하지 않는다는 것을 예상하지 못한 채 계속 활동을 이어갈 수 있기 때문에, 자체적인 연결 상태 지정(isConnected)과 시간 초과 여부(timeover)를 두어 특정 시간(여기서는 5초)이 지날 시 소켓의 상태를 즉각 반영하도록 설정했습니다. 위와 같이 특정 시간(5초)가 지나가면 소켓이 연결되지 않을 시 문제가 있음을 알려줄 수 있게 됩니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">stomp(socket) 연결 해제하기</title><link href="http://localhost:4000/react/2022/10/21/stomp(socket)-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="stomp(socket) 연결 해제하기" /><published>2022-10-21T00:00:00+09:00</published><updated>2022-10-21T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/21/stomp(socket)%20%EC%97%B0%EA%B2%B0%20%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/react/2022/10/21/stomp(socket)-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0/"><![CDATA[<p>현재 소켓을 통해 채팅 연결을 지속하고 있었습니다. 이러한 상황에서 특정 채팅방을 나가는 경우, 해당 채팅방에 대한 알림은 더 이상 받을 필요가 없기 때문에 소켓을 유지한 상태에서 특정 소켓만 해제하는 작업이 필요했습니다.</p>

<h3 id="같은-id가-반복되는-문제">같은 id가 반복되는 문제</h3>

<p>소켓 연결 해제를 하기에 앞서, 연결 해제를 위해서는 <code class="language-plaintext highlighter-rouge">id</code>값이 필요한데, 소켓 연결 시 현재 같은 <code class="language-plaintext highlighter-rouge">id</code> 값으로만 연결을 해주는 상황입니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221021/1.png" alt="" width="" height="" /> 
</figure>

<p>구독하는 상황에서 이는 <code class="language-plaintext highlighter-rouge">headers</code>를 직접 넣어주는 경우 해결이 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">subscribeToStomp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">subscribeURL</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">TOPIC</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">CHATROOM_MEMBERS</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">subscribeURL</span><span class="p">,</span> <span class="nx">onReceive</span><span class="p">,</span> <span class="nx">headers</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221021/2.png" alt="" width="" height="" /> 
</figure>

<p>처음에는 <code class="language-plaintext highlighter-rouge">stompClient.unsubscribe</code>를 사용하기 위해 필요한 <code class="language-plaintext highlighter-rouge">id</code>값을 빼내는 데에 필요하다고 판단해 이와 같은 상황을 먼저 만들었으나, 구독을 하는 동시에 생성되는 값에서 <code class="language-plaintext highlighter-rouge">id</code>,<code class="language-plaintext highlighter-rouge">unsubscribe()</code>가 존재한다는 것을 발견했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221021/3.png" alt="" width="" height="" /> 
</figure>

<p>현재 의문점으로 갖고 있는 것은, 같은 <code class="language-plaintext highlighter-rouge">id</code>를 갖고 있는 상황에서도, 저 <code class="language-plaintext highlighter-rouge">unsubscribe()</code> 함수를 쓰는 상황에서는 각각을 분리해 구독을 끊는 것인지, 아니면 같은 <code class="language-plaintext highlighter-rouge">id</code>를 갖고 있는 것들에 대해 모두 구독을 끊는 것인지 입니다. 이에 대한 제대로 된 문서를 찾기 어려워 직접 적용을 해보게 됐습니다.</p>

<hr />

<h3 id="sub-0-id들로만-이루어진-곳에-구독을-끊을-시">‘sub-0’ id들로만 이루어진 곳에 구독을 끊을 시</h3>

<figure class="figure  figure--center">
  <img class="image" src="/image/221021/4.png" alt="" width="" height="" /> 
</figure>

<p>‘sub-0’ id로만 이루어진 소켓에 연결을 끊는 작업을 진행할 시, 이후 들어오는 메세지에 대해 위 사진과 같은 결과를 알려주게 됩니다. ‘sub-0’라는 id를 통해 들어온 또 다른 메세지가 있으며, 이 메세지에 대해 핸들링이 이루어지지 않았음을 알려주게 되어, 원하는 기능을 위해서는 정확하게 id값이 분리되어야 한다는 것을 알 수 있었습니다.</p>

<p>앞서 나와있던 <code class="language-plaintext highlighter-rouge">unsubscribe()</code> 함수 역시 결국 해당 <code class="language-plaintext highlighter-rouge">id</code>값에 대해서 구독 해제를 하는 것이라 판단했고, <code class="language-plaintext highlighter-rouge">id</code>를 저장해 필요한 <code class="language-plaintext highlighter-rouge">id</code>를 꺼내 쓰기로 결정했습니다.</p>

<hr />

<h3 id="id를-직접적으로-넣어주어-구독-끊기">id를 직접적으로 넣어주어 구독 끊기</h3>

<p>위의 방법이 안 된다는 것을 알고난 뒤, 소켓의 연결을 끊기 위해 사용할 방법들을 찾아봤습니다. 현재 연결된 stomp(소켓)내에서 연결이 이루어지는 경우(<code class="language-plaintext highlighter-rouge">stompClient.subscribe</code>)에 리턴하게 되는 <code class="language-plaintext highlighter-rouge">id</code>값들을 가지고 있어야하는데, 이 값들을 담아두고, 필요할 때 바로 꺼내서 사용하기 위해 JS의 <code class="language-plaintext highlighter-rouge">Map</code>을 사용해 이 값들을 정리해주게 됐습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">chatMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">number</span><span class="p">,</span> <span class="nx">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// id에 맞는 stompId값을 바로 빼내게 위해 map을 사용</span>

<span class="kd">const</span> <span class="nx">subscribeToStomp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">subscribeURL</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">TOPIC</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">CHATROOM_MEMBERS</span><span class="p">}</span><span class="s2">/</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="nx">getAuthHeaders</span><span class="p">();</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">stompId</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">subscribeURL</span><span class="p">,</span> <span class="nx">onReceiveChat</span><span class="p">,</span> <span class="nx">headers</span><span class="p">);</span>
	<span class="c1">// 구독이 완료될 시 나오는 stomp id값을 꺼냄</span>
  <span class="nx">chatMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">stompId</span><span class="p">);</span>
	<span class="c1">// 채팅방의 id값에 stomp id값을 대입시켜서 저장함</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위와 같은 방법을 통해 채팅방의 <code class="language-plaintext highlighter-rouge">id</code>를 알고 있으면 stomp에 연결된 stomp id를 빼낼 수 있게 되고, 그 stomp id를 통해 stomp 연결을 해제할 수 있게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handleClickSelectOkBtn</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 채팅을 나갈 때 사용하는 함수</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">deletedId</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">chatRoomMemberId</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">deletedId</span><span class="p">;</span>
  <span class="c1">// 필요한 id값들을 받아옴</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">deleteChatroomData</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 서버에서 채팅을 나갔다는 응답이 올 경우</span>
    <span class="kd">const</span> <span class="nx">stompId</span> <span class="o">=</span> <span class="nx">chatMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">chatRoomMemberId</span><span class="p">);</span>
    <span class="c1">// 해당 stompId를 받아옴</span>
    <span class="nx">unsubscribeStomp</span><span class="p">(</span><span class="nx">stompId</span><span class="p">);</span>
    <span class="c1">// id를 통해 구독 해제</span>
    <span class="nx">setChatroomsTrigger</span><span class="p">((</span><span class="nx">trigger</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">trigger</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nx">setDeletedId</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">setIsSelectModal</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221021/5.png" alt="" width="" height="" /> 
</figure>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[현재 소켓을 통해 채팅 연결을 지속하고 있었습니다. 이러한 상황에서 특정 채팅방을 나가는 경우, 해당 채팅방에 대한 알림은 더 이상 받을 필요가 없기 때문에 소켓을 유지한 상태에서 특정 소켓만 해제하는 작업이 필요했습니다. 같은 id가 반복되는 문제 소켓 연결 해제를 하기에 앞서, 연결 해제를 위해서는 id값이 필요한데, 소켓 연결 시 현재 같은 id 값으로만 연결을 해주는 상황입니다. 구독하는 상황에서 이는 headers를 직접 넣어주는 경우 해결이 됩니다. const subscribeToStomp = (id: string | number) =&gt; { const headers = getAuthHeaders(); const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`; stompClient.subscribe(subscribeURL, onReceive, headers); }; 처음에는 stompClient.unsubscribe를 사용하기 위해 필요한 id값을 빼내는 데에 필요하다고 판단해 이와 같은 상황을 먼저 만들었으나, 구독을 하는 동시에 생성되는 값에서 id,unsubscribe()가 존재한다는 것을 발견했습니다. 현재 의문점으로 갖고 있는 것은, 같은 id를 갖고 있는 상황에서도, 저 unsubscribe() 함수를 쓰는 상황에서는 각각을 분리해 구독을 끊는 것인지, 아니면 같은 id를 갖고 있는 것들에 대해 모두 구독을 끊는 것인지 입니다. 이에 대한 제대로 된 문서를 찾기 어려워 직접 적용을 해보게 됐습니다. ‘sub-0’ id들로만 이루어진 곳에 구독을 끊을 시 ‘sub-0’ id로만 이루어진 소켓에 연결을 끊는 작업을 진행할 시, 이후 들어오는 메세지에 대해 위 사진과 같은 결과를 알려주게 됩니다. ‘sub-0’라는 id를 통해 들어온 또 다른 메세지가 있으며, 이 메세지에 대해 핸들링이 이루어지지 않았음을 알려주게 되어, 원하는 기능을 위해서는 정확하게 id값이 분리되어야 한다는 것을 알 수 있었습니다. 앞서 나와있던 unsubscribe() 함수 역시 결국 해당 id값에 대해서 구독 해제를 하는 것이라 판단했고, id를 저장해 필요한 id를 꺼내 쓰기로 결정했습니다. id를 직접적으로 넣어주어 구독 끊기 위의 방법이 안 된다는 것을 알고난 뒤, 소켓의 연결을 끊기 위해 사용할 방법들을 찾아봤습니다. 현재 연결된 stomp(소켓)내에서 연결이 이루어지는 경우(stompClient.subscribe)에 리턴하게 되는 id값들을 가지고 있어야하는데, 이 값들을 담아두고, 필요할 때 바로 꺼내서 사용하기 위해 JS의 Map을 사용해 이 값들을 정리해주게 됐습니다. export const chatMap = new Map&lt;number, string&gt;(); // id에 맞는 stompId값을 바로 빼내게 위해 map을 사용 const subscribeToStomp = (id: number) =&gt; { const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`; const headers = getAuthHeaders(); const { id: stompId } = stompClient.subscribe(subscribeURL, onReceiveChat, headers); // 구독이 완료될 시 나오는 stomp id값을 꺼냄 chatMap.set(id, stompId); // 채팅방의 id값에 stomp id값을 대입시켜서 저장함 }; 위와 같은 방법을 통해 채팅방의 id를 알고 있으면 stomp에 연결된 stomp id를 빼낼 수 있게 되고, 그 stomp id를 통해 stomp 연결을 해제할 수 있게 됩니다. const handleClickSelectOkBtn = async () =&gt; { // 채팅을 나갈 때 사용하는 함수 if (!deletedId) return; const { id, chatRoomMemberId } = deletedId; // 필요한 id값들을 받아옴 const response = await deleteChatroomData(id); if (response.status === 200) { // 서버에서 채팅을 나갔다는 응답이 올 경우 const stompId = chatMap.get(chatRoomMemberId); // 해당 stompId를 받아옴 unsubscribeStomp(stompId); // id를 통해 구독 해제 setChatroomsTrigger((trigger) =&gt; trigger + 1); setDeletedId(null); } setIsSelectModal(false); };]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">REACT DATEPICKER</title><link href="http://localhost:4000/react/2022/10/11/react_datepicker/" rel="alternate" type="text/html" title="REACT DATEPICKER" /><published>2022-10-11T00:00:00+09:00</published><updated>2022-10-11T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/10/11/react_datepicker</id><content type="html" xml:base="http://localhost:4000/react/2022/10/11/react_datepicker/"><![CDATA[<p>날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">DateInputForm</span> <span class="na">type</span><span class="p">=</span><span class="s">'date'</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentDateTime</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDateTime</span><span class="si">}</span> <span class="p">/&gt;</span>
<span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">DateInputForm</span> <span class="na">type</span><span class="p">=</span><span class="s">'time'</span> <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentTime</span><span class="si">}</span> <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeTime</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/first.gif" alt="" width="35%" height="" /> 
</figure>

<p>하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다.<br />
(링크 : <a href="https://reactdatepicker.com/">React Datepicker crafted by HackerOne</a>)</p>

<p>설치는 아래 코드들로 진행했습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install react-datepicker --save
npm install @types/react-datepicker
</code></pre></div></div>

<hr />

<h3 id="날짜-설정">날짜 설정</h3>

<p>사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">"</span><span class="s2">react-datepicker/dist/react-datepicker.css</span><span class="dl">"</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">ReactDatePicker</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react-datepicker</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">StyledDatePicker</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">(</span><span class="nx">ReactDatePicker</span><span class="p">)</span><span class="s2">`
  border: none;
  background-color: transparent;
  padding: 0;
`</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledDatePicker</span>
  <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
  <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDate</span><span class="si">}</span>
  <span class="na">dateFormat</span><span class="p">=</span><span class="s">"yyyy.MM.dd"</span>
<span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/date default.png" alt="" width="50%" height="" /> 
</figure>

<p>이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nx">react</span><span class="o">-</span><span class="nx">datepicker</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="nx">__day</span> <span class="p">{</span>
	  <span class="nx">$</span><span class="p">{</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">xSmall</span><span class="p">};</span>
	  <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey4</span><span class="p">};</span>
	  <span class="nl">width</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">100</span><span class="o">%</span> <span class="sr">/ 10</span><span class="se">)</span><span class="err">;
</span>	  <span class="nx">aspect</span><span class="o">-</span><span class="nx">ratio</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="nx">line</span><span class="o">-</span><span class="nx">height</span><span class="p">:</span> <span class="nx">initial</span><span class="p">;</span>
	  <span class="nl">display</span><span class="p">:</span> <span class="nx">inline</span><span class="o">-</span><span class="nx">flex</span><span class="p">;</span>
	  <span class="nx">align</span><span class="o">-</span><span class="nx">items</span><span class="p">:</span> <span class="nx">center</span><span class="p">;</span>
	  <span class="nx">justify</span><span class="o">-</span><span class="nx">content</span><span class="p">:</span> <span class="nx">center</span><span class="p">;</span>
	  <span class="nl">margin</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>

	  <span class="p">:</span><span class="nx">hover</span> <span class="p">{</span>
	    <span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="p">:</span> <span class="mi">10</span><span class="nx">rem</span><span class="p">;</span>
	  <span class="p">}</span>

	  <span class="o">&amp;-</span><span class="nx">name</span> <span class="p">{</span>
	    <span class="nx">$</span><span class="p">{</span><span class="nx">fonts</span><span class="p">.</span><span class="nx">xSmall</span><span class="p">};</span>

		<span class="p">...</span>

	  <span class="o">&amp;--</span><span class="nx">disabled</span> <span class="p">{</span>
	    <span class="nx">text</span><span class="o">-</span><span class="nx">decoration</span><span class="p">:</span> <span class="nx">line</span><span class="o">-</span><span class="nx">through</span><span class="p">;</span>
	    <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey3</span><span class="p">};</span>
	  <span class="p">}</span>
	<span class="p">}</span>


</code></pre></div></div>

<p>날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(<code class="language-plaintext highlighter-rouge">react-datepicker__current-month</code>)와 같은 선상에 있으면서 <code class="language-plaintext highlighter-rouge">position: absolute</code>로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 <code class="language-plaintext highlighter-rouge">top</code>으로 직접 받아 처리하도록 우선 구성했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&amp;</span><span class="nx">__current</span> <span class="p">{</span>
  <span class="o">&amp;-</span><span class="nx">month</span> <span class="p">{</span>
    <span class="nx">text</span><span class="o">-</span><span class="nx">align</span><span class="p">:</span> <span class="nx">left</span><span class="p">;</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">left</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">100</span><span class="o">%</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">80</span> <span class="o">-</span> <span class="mi">5</span><span class="nx">px</span><span class="p">);</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">bottom</span><span class="p">:</span> <span class="mf">0.5</span><span class="nx">rem</span><span class="p">;</span>
    <span class="nx">padding</span><span class="o">-</span><span class="nx">top</span><span class="p">:</span> <span class="mf">0.75</span><span class="nx">rem</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">&amp;</span><span class="nx">__navigation</span> <span class="p">{</span>
	  <span class="o">&amp;--</span><span class="nx">previous</span> <span class="p">{</span>
	    <span class="nl">top</span><span class="p">:</span> <span class="mi">5</span><span class="nx">px</span><span class="p">;</span>
	    <span class="nl">left</span><span class="p">:</span> <span class="nx">unset</span><span class="p">;</span>
	    <span class="nl">right</span><span class="p">:</span> <span class="nx">calc</span><span class="p">(</span><span class="mi">32</span><span class="nx">px</span><span class="p">);</span>
	  <span class="p">}</span>
	  <span class="o">&amp;--</span><span class="nx">next</span> <span class="p">{</span>
	    <span class="nl">top</span><span class="p">:</span> <span class="mi">5</span><span class="nx">px</span><span class="p">;</span>
	    <span class="nl">right</span><span class="p">:</span> <span class="mi">0</span><span class="nx">px</span><span class="p">;</span>
	  <span class="p">}</span>
	  <span class="o">&amp;-</span><span class="nx">icon</span> <span class="p">{</span>
	    <span class="p">::</span><span class="nx">before</span> <span class="p">{</span>
	      <span class="nl">border</span><span class="p">:</span> <span class="nx">none</span><span class="p">;</span>
	    <span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>datepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledDatePicker</span>
  <span class="na">selected</span><span class="p">=</span><span class="si">{</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">appointmentDateTime</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 선택된 날짜를 지정</span>
  <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsDateFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handelChangeDate</span><span class="si">}</span>
  <span class="c1">// 기존 input과 동일</span>
  <span class="na">dateFormat</span><span class="p">=</span><span class="s">"yyyy.MM.dd"</span>
  <span class="c1">// input에 보이는 날짜 형식 설정</span>
  <span class="na">minDate</span><span class="p">=</span><span class="si">{</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()</span><span class="si">}</span>
  <span class="c1">// 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨</span>
  <span class="na">showPopperArrow</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
  <span class="c1">// 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정</span>
  <span class="na">formatWeekDay</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">nameOfDay</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">nameOfDay</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span>
  <span class="c1">// 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경</span>
  <span class="na">nextMonthButtonLabel</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronRight"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.75</span><span class="si">}</span> <span class="p">/&gt;</span><span class="si">}</span>
  <span class="c1">// 다음 달 보기 버튼 표현방식 변경</span>
  <span class="na">previousMonthButtonLabel</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronLeft"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.75</span><span class="si">}</span> <span class="p">/&gt;</span><span class="si">}</span>
  <span class="c1">// 이전 달 보기 버튼 표현방식 변경</span>
<span class="p">/&gt;</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/date finish.gif" alt="" width="50%" height="" /> 
</figure>

<h3 id="시간-설정">시간 설정</h3>

<p>시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다.</p>

<div style="display: flex">
  <figure class="figure  figure--center">
  <img class="image" src="/image/221011/time design.png" alt="" width="65%" height="" /> 
</figure>

  <figure class="figure  figure--center">
  <img class="image" src="/image/221011/time default.png" alt="" width="100%" height="" /> 
</figure>

</div>

<p>왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다.</p>

<p>시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">StyledTimePicker</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">(</span><span class="nx">ReactDatePicker</span><span class="p">)</span><span class="s2">`
  width: 100%;
  border: none;
  background-color: transparent;
  padding: 0;

  :focus {
    outline: none;
  }
`</span><span class="p">;</span>

<span class="p">...</span>

<span class="o">&amp;</span><span class="nx">__header</span> <span class="p">{</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">&amp;--</span><span class="nx">time</span> <span class="p">{</span>
    <span class="nx">background</span><span class="o">-</span><span class="nx">color</span><span class="p">:</span> <span class="nx">transparent</span><span class="p">;</span>
    <span class="nx">border</span><span class="o">-</span><span class="nx">bottom</span><span class="p">:</span> <span class="nx">none</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">&amp;-</span><span class="nx">time__header</span> <span class="p">{</span>
  <span class="nx">$</span><span class="p">{</span><span class="nx">flexCenter</span><span class="p">};</span>

  <span class="nx">justify</span><span class="o">-</span><span class="nx">content</span><span class="p">:</span> <span class="nx">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">word</span><span class="o">-</span><span class="nx">spacing</span><span class="p">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="mi">0</span> <span class="nx">auto</span><span class="p">;</span>
  <span class="nx">white</span><span class="o">-</span><span class="nx">space</span><span class="p">:</span> <span class="nx">pre</span><span class="p">;</span>
  <span class="nx">font</span><span class="o">-</span><span class="nx">size</span><span class="p">:</span> <span class="mi">8</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">font</span><span class="o">-</span><span class="nx">weight</span><span class="p">:</span> <span class="mi">400</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="mi">25</span><span class="nx">px</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">colors</span><span class="p">.</span><span class="nx">grey4</span><span class="p">};</span>
<span class="p">}</span>

<span class="p">...</span>
</code></pre></div></div>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">TimeInputWrapper</span> <span class="na">isTimeFocused</span><span class="p">=</span><span class="si">{</span><span class="nx">isTimeFocused</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">S</span><span class="p">.</span><span class="nc">StyledTimePicker</span>
    <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">handleChangeTimeTest</span><span class="si">}</span>
    <span class="c1">// 기존 input과 동일</span>
    <span class="na">timeIntervals</span><span class="p">=</span><span class="si">{</span><span class="nx">timeIntervals</span><span class="si">}</span>
    <span class="c1">// 시간 설정의 간격을 조절함</span>
    <span class="na">showTimeSelect</span>
    <span class="na">showTimeSelectOnly</span>
    <span class="c1">// 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함</span>
    <span class="na">selected</span><span class="p">=</span><span class="si">{</span><span class="nx">currentTimeDateType</span><span class="si">}</span>
    <span class="c1">// 선택된 시간에 selected 클래스를 지정함</span>
    <span class="na">showPopperArrow</span><span class="p">=</span><span class="si">{</span><span class="kc">false</span><span class="si">}</span>
    <span class="na">timeFormat</span><span class="p">=</span><span class="s">"HH mm aa"</span>
    <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">appointmentTime</span><span class="si">}</span>
    <span class="na">timeCaption</span><span class="p">=</span><span class="s">"HOUR MINUTE"</span>
    <span class="na">onFocus</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsTimeFocused</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="si">}</span>
    <span class="na">onBlur</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setIsTimeFocused</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="si">}</span>
  <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nc">Icon</span> <span class="na">iconName</span><span class="p">=</span><span class="s">"ChevronDown"</span> <span class="na">iconSize</span><span class="p">=</span><span class="si">{</span><span class="mf">0.9</span><span class="si">}</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">S</span><span class="p">.</span><span class="nc">TimeInputWrapper</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다.</p>

<p>단, 시간 설정을 할 때에는 <code class="language-plaintext highlighter-rouge">showTimeSelect</code>, <code class="language-plaintext highlighter-rouge">showTimeSelectOnly</code> 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다.</p>

<p>시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221011/time finish.gif" alt="" width="45%" height="" /> 
</figure>

<h3 id="특이-사항">특이 사항</h3>

<p>스타일 관련 작업들을 진행하면서, <code class="language-plaintext highlighter-rouge">!important</code>를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. <code class="language-plaintext highlighter-rouge">!important</code>를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.</p>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다. &lt;S.DateInputForm type='date' value={appointmentDateTime} onChange={handelChangeDateTime} /&gt; &lt;S.DateInputForm type='time' value={appointmentTime} onChange={handelChangeTime} /&gt; 하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다. (링크 : React Datepicker crafted by HackerOne) 설치는 아래 코드들로 진행했습니다. npm install react-datepicker --save npm install @types/react-datepicker 날짜 설정 사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다. import "react-datepicker/dist/react-datepicker.css"; import ReactDatePicker from "react-datepicker"; export const StyledDatePicker = styled(ReactDatePicker)` border: none; background-color: transparent; padding: 0; `; &lt;S.StyledDatePicker onFocus={() =&gt; setIsDateFocused(true)} onBlur={() =&gt; setIsDateFocused(false)} onChange={handelChangeDate} dateFormat="yyyy.MM.dd" /&gt; 이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다. .react-datepicker { &amp;__day { ${fonts.xSmall}; color: ${colors.grey4}; width: calc(100% / 10); aspect-ratio: 1; line-height: initial; display: inline-flex; align-items: center; justify-content: center; margin: 0; :hover { border-radius: 10rem; } &amp;-name { ${fonts.xSmall}; ... &amp;--disabled { text-decoration: line-through; color: ${colors.grey3}; } } 날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(react-datepicker__current-month)와 같은 선상에 있으면서 position: absolute로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 top으로 직접 받아 처리하도록 우선 구성했습니다. &amp;__current { &amp;-month { text-align: left; padding-left: calc(100% * 7 / 80 - 5px); padding-bottom: 0.5rem; padding-top: 0.75rem; } } &amp;__navigation { &amp;--previous { top: 5px; left: unset; right: calc(32px); } &amp;--next { top: 5px; right: 0px; } &amp;-icon { ::before { border: none; } } } } datepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다. &lt;S.StyledDatePicker selected={new Date(appointmentDateTime)} // 선택된 날짜를 지정 onFocus={() =&gt; setIsDateFocused(true)} // 기존 input과 동일 onBlur={() =&gt; setIsDateFocused(false)} // 기존 input과 동일 onChange={handelChangeDate} // 기존 input과 동일 dateFormat="yyyy.MM.dd" // input에 보이는 날짜 형식 설정 minDate={new Date()} // 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨 showPopperArrow={false} // 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정 formatWeekDay={(nameOfDay) =&gt; nameOfDay.substring(0, 1)} // 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경 nextMonthButtonLabel={&lt;Icon iconName="ChevronRight" iconSize={0.75} /&gt;} // 다음 달 보기 버튼 표현방식 변경 previousMonthButtonLabel={&lt;Icon iconName="ChevronLeft" iconSize={0.75} /&gt;} // 이전 달 보기 버튼 표현방식 변경 /&gt; 시간 설정 시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다. 왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다. 시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다. export const StyledTimePicker = styled(ReactDatePicker)` width: 100%; border: none; background-color: transparent; padding: 0; :focus { outline: none; } `; ... &amp;__header { padding: 0; &amp;--time { background-color: transparent; border-bottom: none; } } &amp;-time__header { ${flexCenter}; justify-content: left; width: 100px; word-spacing: 10px; margin: 0 auto; white-space: pre; font-size: 8px; font-weight: 400; height: 25px; color: ${colors.grey4}; } ... &lt;S.TimeInputWrapper isTimeFocused={isTimeFocused}&gt; &lt;S.StyledTimePicker onChange={handleChangeTimeTest} // 기존 input과 동일 timeIntervals={timeIntervals} // 시간 설정의 간격을 조절함 showTimeSelect showTimeSelectOnly // 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함 selected={currentTimeDateType} // 선택된 시간에 selected 클래스를 지정함 showPopperArrow={false} timeFormat="HH mm aa" value={appointmentTime} timeCaption="HOUR MINUTE" onFocus={() =&gt; setIsTimeFocused(true)} onBlur={() =&gt; setIsTimeFocused(false)} /&gt; &lt;Icon iconName="ChevronDown" iconSize={0.9} /&gt; &lt;/S.TimeInputWrapper&gt; 날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다. 단, 시간 설정을 할 때에는 showTimeSelect, showTimeSelectOnly 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다. 시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다. 특이 사항 스타일 관련 작업들을 진행하면서, !important를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. !important를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">깊이 우선 그래프 순회</title><link href="http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C-copy/" rel="alternate" type="text/html" title="깊이 우선 그래프 순회" /><published>2022-10-10T00:00:00+09:00</published><updated>2022-10-10T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C%20copy</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C-copy/"><![CDATA[<p>트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다.</p>

<p>여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다.</p>

<ul>
  <li>위키피디아의 링크 내 이동 시 최단 거리 찾기</li>
  <li>페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능</li>
  <li>GPS 네비게이션</li>
  <li>미로 문제 풀기</li>
</ul>

<h3 id="dfs-순회">DFS 순회?</h3>

<p>그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다.</p>

<p>핵심은 각 노드마다 있는 가지 중 <strong>방문하지 않은 곳을 방문하는</strong> 형식으로 이루어집니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="na">A</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">B</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">C</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">D</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">B</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">E</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">C</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">F</span><span class="dl">'</span> <span class="p">],</span>
  <span class="na">F</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">D</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">E</span><span class="dl">'</span> <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221010/graph.png" alt="" width="35%" height="" /> 
</figure>

<h3 id="재귀형-dfs-순회">재귀형 DFS 순회</h3>

<p>재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">depthFirstRecursive</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과를 담을 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문한 곳을 나타내는 객체</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">graph</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 해당 함수가 사용되는 전체 그래프</span>
  <span class="kd">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">point</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="c1">// 값이 없을경우에 대한 예외 처리</span>
    <span class="nx">visited</span><span class="p">[</span><span class="nx">point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="c1">// dfs가 사용되었으므로 방문했음을 표기</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">point</span><span class="p">);</span>
    <span class="c1">// 결과에 해당 포인트에 대한 결과 입력</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">point</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextPoint</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 해당 포인트와 연결된 다음 포인트에 대해서 처리</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextPoint</span><span class="p">])</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">nextPoint</span><span class="p">);</span>
      <span class="c1">// 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리</span>
    <span class="p">});</span>
  <span class="p">};</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span>
	<span class="c1">// 시작 지점에서 처리 시작</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">depthFirstRecursive</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">));</span>
<span class="c1">// [ 'A', 'B', 'D', 'E', 'C', 'F' ]</span>
</code></pre></div></div>

<p>재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다.</p>

<p>여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다.</p>

<h3 id="반복형-dfs-순회">반복형 DFS 순회</h3>

<p><code class="language-plaintext highlighter-rouge">while</code>을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">depthFirstIterative</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과 배열</span>
  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="c1">// 방문 확인 배열</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">graph</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 현재 그래프</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nx">vertex</span><span class="p">];</span>
  <span class="c1">// 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴</span>

  <span class="kd">let</span> <span class="nx">curVertex</span><span class="p">;</span>
  <span class="nx">visited</span><span class="p">[</span><span class="nx">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="c1">// while문을 돌면서 현재의 위치를 나타내는 변수</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curVertex</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="c1">// DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요!</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curVertex</span><span class="p">);</span>
    <span class="c1">// 결과에 방문에 대한 결과값 처리</span>
    <span class="nx">graph</span><span class="p">[</span><span class="nx">curVertex</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">nextVertex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 현재 위치의 다음 위치들에 대해서 방문 여부 확인</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
      <span class="c1">// 방문하지 않았을 시 stack에 추가</span>
      <span class="nx">visited</span><span class="p">[</span><span class="nx">nextVertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에,</span>
      <span class="c1">// stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nextVertex</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221010/graph order.png" alt="" width="35%" height="" /> 
</figure>

<p>반복을 사용하는 경우 <code class="language-plaintext highlighter-rouge">while</code>문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다.</p>

<p><code class="language-plaintext highlighter-rouge">while</code>을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다.</p>

<p>그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다. 여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다. 위키피디아의 링크 내 이동 시 최단 거리 찾기 페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능 GPS 네비게이션 미로 문제 풀기 DFS 순회? 그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다. 핵심은 각 노드마다 있는 가지 중 방문하지 않은 곳을 방문하는 형식으로 이루어집니다. { A: [ 'B', 'C' ], B: [ 'A', 'D' ], C: [ 'A', 'E' ], D: [ 'B', 'E', 'F' ], E: [ 'C', 'D', 'F' ], F: [ 'D', 'E' ] } 재귀형 DFS 순회 재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다. depthFirstRecursive(vertex) { const result = []; // 결과를 담을 배열 const visited = {}; // 방문한 곳을 나타내는 객체 const { graph } = this; // 해당 함수가 사용되는 전체 그래프 const dfs = (point) =&gt; { if (!point) return null; // 값이 없을경우에 대한 예외 처리 visited[point] = true; // dfs가 사용되었으므로 방문했음을 표기 result.push(point); // 결과에 해당 포인트에 대한 결과 입력 graph[point].forEach((nextPoint) =&gt; { // 해당 포인트와 연결된 다음 포인트에 대해서 처리 if (!visited[nextPoint]) dfs(nextPoint); // 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리 }); }; dfs(vertex); // 시작 지점에서 처리 시작 return result; } console.log(g.depthFirstRecursive("A")); // [ 'A', 'B', 'D', 'E', 'C', 'F' ] 재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다. 여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다. 반복형 DFS 순회 while을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다. depthFirstIterative(vertex) { const result = []; // 결과 배열 const visited = {}; // 방문 확인 배열 const { graph } = this; // 현재 그래프 const stack = [vertex]; // 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴 let curVertex; visited[vertex] = true; // while문을 돌면서 현재의 위치를 나타내는 변수 while (stack.length) { curVertex = stack.pop(); // DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요! result.push(curVertex); // 결과에 방문에 대한 결과값 처리 graph[curVertex].forEach((nextVertex) =&gt; { // 현재 위치의 다음 위치들에 대해서 방문 여부 확인 if (visited[nextVertex]) return; // 방문하지 않았을 시 stack에 추가 visited[nextVertex] = true; // 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에, // stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음 stack.push(nextVertex); }); } return result; } 반복을 사용하는 경우 while문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다. while을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다. 그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>