<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-12-05T20:39:45+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JINJEONIMUM</title><subtitle></subtitle><author><name>JinJeon</name></author><entry><title type="html">백준 22871번</title><link href="http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80-22871%EB%B2%88/" rel="alternate" type="text/html" title="백준 22871번" /><published>2022-12-05T00:00:00+09:00</published><updated>2022-12-05T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80%2022871%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80-22871%EB%B2%88/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/22871">QUESTION LINK</a></strong></p>

<p>‘다이나믹 프로그래밍’으로 풀어야하는 문제였습니다. 해당 문제의 경우, 한 칸씩 이동을 할 때마다 해당 칸까지 갔던 거리의 최소값들을 구해주는 식으로 진행을 해야 문제를 풀 수 있었습니다. 그림으로 보면 아래와 같습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221205/0.png" alt="" width="100%" height="" /> 
</figure>

<p>위 그림을 통해서 보면, 2번과 3번을 지나면서도 각각에 대한 최소값들을 만들고 넘어오는 것을 볼 수 있습니다. 여기서 4번을 예시로 들면 4번에 오는 최단거리의 값을 만들 때에는 ‘1번 → 2번 → 4번’, ‘1번 → 3번 → 4번’으로 오는 방법이 존재하게 되는데, 여기서 2번을 지나갈 때와 3번을 지나갈 때 각각 미리 그 곳을 종점으로 하는 최소값을 기록한 다음에 넘어오면, 4번에서도 같은 방식으로 4번까지 오는 최소값을 구할 수 있게 되는 것입니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221205/1.png" alt="" width="100%" height="" /> 
</figure>

<p>즉, 주어진 값들에 대한 배열을 돌면서 각 <code class="language-plaintext highlighter-rouge">index</code>까지 도달하기 위한 최소값들을 구하고 이를 일종의 배열에 담고 있으면, 그 배열의 마지막 값이 곧 ‘종점으로 가기 위해 최소로 요구되는 힘’이 됩니다. 코드로 나타내면 아래와 같습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">_</span><span class="p">,</span> <span class="nx">valuesString</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fs</span>
  <span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">trim</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">values</span> <span class="o">=</span> <span class="nx">valuesString</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>
<span class="c1">// 들어온 값들을 숫자로 정리한 배열</span>
<span class="kd">const</span> <span class="nx">distances</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 각 인덱스까지 오는 데에 필요한 최소 힘을 담는 배열</span>

<span class="nx">values</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 배열의 각 index들을 돌면서 해당 index까지 도달하기 위한 최소 힘을 구함</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">index</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="c1">// index가 0인 경우에는 혼자 있으므로 관련없음</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 출발지를 0부터 index - 1까지로 하여, 0, i, index의 경로로 오기 위한 최소힘을 구함</span>
    <span class="kd">const</span> <span class="nx">curPower</span> <span class="o">=</span> <span class="p">(</span><span class="nx">index</span> <span class="o">-</span> <span class="nx">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">value</span> <span class="o">-</span> <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]));</span>
    <span class="c1">// 순회하는 배열에서의 종점과 for문을 통해 돌고 있는 i 사이의 필요힘</span>
    <span class="kd">const</span> <span class="nx">power</span> <span class="o">=</span> <span class="nx">distances</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">?</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">curPower</span><span class="p">,</span> <span class="nx">distances</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">:</span> <span class="nx">curPower</span><span class="p">;</span>
    <span class="c1">// i까지 오는 데에 대한 최소값이 없을 시는 현재 구한 값이 최소 힘이며,</span>
    <span class="c1">// 아닐 시 이미 구한 최소 힘과 비교하여 더 큰 값을 현재 필요힘으로 설정</span>
    <span class="nx">distances</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">distances</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
      <span class="p">?</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">power</span><span class="p">,</span> <span class="nx">distances</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
      <span class="p">:</span> <span class="nx">power</span><span class="p">;</span>
    <span class="c1">// 이전에 설정된 index의 최소 힘과 비교하여 더 작은 값이 있을 시</span>
    <span class="c1">// 그 값이 index에 도달하기 위한 최소 힘 값이 됨</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">distances</span><span class="p">[</span><span class="nx">distances</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div>

<p>문제 자체에 대한 이해는 어렵지 않았으나, 이를 구현하는 과정을 생각하는 데에 시간이 오래 걸렸습니다. 무엇보다, <code class="language-plaintext highlighter-rouge">distances</code>라는 배열을 구상하고 이 배열을 통해서 지속적으로 값을 비교해나가며 최소값을 찾아가는 과정이 어려웠습니다. 이와 같은 문제를 마주쳤을 때, 이 코드의 <code class="language-plaintext highlighter-rouge">distances</code>와 같은 형태의 배열을 만들고, 비교해가는 과정이 이루어져야함을 알 수 있었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK ‘다이나믹 프로그래밍’으로 풀어야하는 문제였습니다. 해당 문제의 경우, 한 칸씩 이동을 할 때마다 해당 칸까지 갔던 거리의 최소값들을 구해주는 식으로 진행을 해야 문제를 풀 수 있었습니다. 그림으로 보면 아래와 같습니다. 위 그림을 통해서 보면, 2번과 3번을 지나면서도 각각에 대한 최소값들을 만들고 넘어오는 것을 볼 수 있습니다. 여기서 4번을 예시로 들면 4번에 오는 최단거리의 값을 만들 때에는 ‘1번 → 2번 → 4번’, ‘1번 → 3번 → 4번’으로 오는 방법이 존재하게 되는데, 여기서 2번을 지나갈 때와 3번을 지나갈 때 각각 미리 그 곳을 종점으로 하는 최소값을 기록한 다음에 넘어오면, 4번에서도 같은 방식으로 4번까지 오는 최소값을 구할 수 있게 되는 것입니다. 즉, 주어진 값들에 대한 배열을 돌면서 각 index까지 도달하기 위한 최소값들을 구하고 이를 일종의 배열에 담고 있으면, 그 배열의 마지막 값이 곧 ‘종점으로 가기 위해 최소로 요구되는 힘’이 됩니다. 코드로 나타내면 아래와 같습니다. const [_, valuesString] = fs .readFileSync(filePath) .toString() .trim() .split("\n"); const values = valuesString.split(" ").map(Number); // 들어온 값들을 숫자로 정리한 배열 const distances = []; // 각 인덱스까지 오는 데에 필요한 최소 힘을 담는 배열 values.forEach((value, index) =&gt; { // 배열의 각 index들을 돌면서 해당 index까지 도달하기 위한 최소 힘을 구함 if (!index) return; // index가 0인 경우에는 혼자 있으므로 관련없음 for (let i = 0; i &lt; index; i += 1) { // 출발지를 0부터 index - 1까지로 하여, 0, i, index의 경로로 오기 위한 최소힘을 구함 const curPower = (index - i) * (1 + Math.abs(value - values[i])); // 순회하는 배열에서의 종점과 for문을 통해 돌고 있는 i 사이의 필요힘 const power = distances[i] ? Math.max(curPower, distances[i]) : curPower; // i까지 오는 데에 대한 최소값이 없을 시는 현재 구한 값이 최소 힘이며, // 아닐 시 이미 구한 최소 힘과 비교하여 더 큰 값을 현재 필요힘으로 설정 distances[index] = distances[index] ? Math.min(power, distances[index]) : power; // 이전에 설정된 index의 최소 힘과 비교하여 더 작은 값이 있을 시 // 그 값이 index에 도달하기 위한 최소 힘 값이 됨 } }); console.log(distances[distances.length - 1]); 문제 자체에 대한 이해는 어렵지 않았으나, 이를 구현하는 과정을 생각하는 데에 시간이 오래 걸렸습니다. 무엇보다, distances라는 배열을 구상하고 이 배열을 통해서 지속적으로 값을 비교해나가며 최소값을 찾아가는 과정이 어려웠습니다. 이와 같은 문제를 마주쳤을 때, 이 코드의 distances와 같은 형태의 배열을 만들고, 비교해가는 과정이 이루어져야함을 알 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 1654번</title><link href="http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80-1654%EB%B2%88/" rel="alternate" type="text/html" title="백준 1654번" /><published>2022-12-05T00:00:00+09:00</published><updated>2022-12-05T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80%201654%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/12/05/%EB%B0%B1%EC%A4%80-1654%EB%B2%88/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/1654">QUESTION LINK</a></strong></p>

<p>주어진 전선들 중 요구하는 개수의 조각들이 나올 수 있도록 나누기를 반복해야하는 문제였습니다. 가장 먼저 고민했던 것은 ‘원하는 값을 구하기 위해서 주어진 값들에 대해 반복적인 나누기를 해야하는지’ 였는데 이 부분은 개수를 비교하기 위해서는 필수적으로 거쳐야하는 과정이라 어쩔 수 없다는 것을 파악했습니다.</p>

<p>다음으로 고민했던 것은 이분 탐색을 할 때, ‘어떻게 해야 만족되는 값들 중 가장 큰 값에 접근할 수 있는지’ 였습니다. 처음에는 최대값으로 현재 주어진 값들 중 가장 큰 값을 설정하고, <code class="language-plaintext highlighter-rouge">while</code>문을 통한 이분 탐색으로 만족되는 값을 구하고, 이후 하나씩 올라가며 최대값을 구하려고 하였으나, 이로 인해 <strong>시간 초과</strong>가 나왔습니다.</p>

<p>이후, 이분 탐색에 대해 알게 된 것이 원하는 결과가 나올 때까지 Upper Bound를 이용해서 값을 구해주면 된다는 것이었습니다. 여기서 Upper Bound는 특정 조건을 만족하는 값의 다음 값을 보여주게 되는 것인데, 이를 이용해서 원하는 값이 나오도록 할 수 있었습니다.</p>

<p>구현을 위해, 초기값으로는 최소값(<code class="language-plaintext highlighter-rouge">min</code>)과 최대값(<code class="language-plaintext highlighter-rouge">max</code>)을 설정하게 되는데, 여기서 길이를 구하는 문제이기 때문에 최소값은 1로 처음에 설정을 해주어야 합니다. 이렇게 진행하지 않을 시, 이후 이분 탐색에서 중간값을 구할 때 <strong>중간값이 0이 나올 수도 있다는 문제</strong>가 생겨, 이 부분에 대한 처리가 꼭 필요합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">counts</span><span class="p">,</span> <span class="p">...</span><span class="nx">linesString</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fs</span>
  <span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">trim</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">N</span><span class="p">]</span> <span class="o">=</span> <span class="nx">counts</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">linesString</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 최소값으로 0이 아닌 1로 설정</span>
<span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">lines</span><span class="p">);</span>
<span class="c1">// 최대값은 현재 주어진 값들 중 가장 큰 값</span>
</code></pre></div></div>

<p>이후, <code class="language-plaintext highlighter-rouge">while</code>문을 통한 반복을 하게 되는데, 여기서 조건 설정에 대한 어려움이 있었습니다. 앞서 말한 Upper Bound를 하기 위해서는 순회 시 <strong>구해진 값이 요구되는 값과 일치될 때 만족시킨 중간값(mid)보다 더 큰 값으로 최소값을 설정해</strong> 반복해야 Upper Bound를 통해 요구되는 값보다 하나 더 큰 값을 얻을 수 있게 됩니다.</p>

<p>하지만, 이렇게 진행을 하고 나서, 마지막에 while문을 종료시켜야 하는데 이 때 적용할 조건으로 기존에는 최소값이 최대값보다 작은 상황(<code class="language-plaintext highlighter-rouge">min &lt; max</code>)에 대해서만 진행하도록 했습니다. 이럴 경우 틀렸다는 결과가 나오게 되는데 이는 <strong>max값이 1이 될 수도 있다는 것</strong>을 고려하지 못하기 때문입니다. <code class="language-plaintext highlighter-rouge">max</code>가 1인 상황에서도 해당 순회가 한 번은 돌아가고 이에 따른 결과가 나와야 하기 때문에, <code class="language-plaintext highlighter-rouge">min ≤ max</code>로 조건을 설정해야 합니다.</p>

<p>그리고 이렇게 조건을 진행할 경우, 기존의 Upper Bound와 달리 한 번 더 <code class="language-plaintext highlighter-rouge">max</code>값에 대한 처리가 이루어지기 때문에 추가적인 -1 조치는 필요가 없어지게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="nx">min</span> <span class="o">&lt;=</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">min</span> <span class="o">+</span> <span class="nx">max</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">lines</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">prev</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">next</span> <span class="o">/</span> <span class="nx">mid</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 모든 같은 길이의 전선들의 합</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;=</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 값이 일치하더라도 최대까지 진행해 나가야 함</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">max</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 주어진 전선들 중 요구하는 개수의 조각들이 나올 수 있도록 나누기를 반복해야하는 문제였습니다. 가장 먼저 고민했던 것은 ‘원하는 값을 구하기 위해서 주어진 값들에 대해 반복적인 나누기를 해야하는지’ 였는데 이 부분은 개수를 비교하기 위해서는 필수적으로 거쳐야하는 과정이라 어쩔 수 없다는 것을 파악했습니다. 다음으로 고민했던 것은 이분 탐색을 할 때, ‘어떻게 해야 만족되는 값들 중 가장 큰 값에 접근할 수 있는지’ 였습니다. 처음에는 최대값으로 현재 주어진 값들 중 가장 큰 값을 설정하고, while문을 통한 이분 탐색으로 만족되는 값을 구하고, 이후 하나씩 올라가며 최대값을 구하려고 하였으나, 이로 인해 시간 초과가 나왔습니다. 이후, 이분 탐색에 대해 알게 된 것이 원하는 결과가 나올 때까지 Upper Bound를 이용해서 값을 구해주면 된다는 것이었습니다. 여기서 Upper Bound는 특정 조건을 만족하는 값의 다음 값을 보여주게 되는 것인데, 이를 이용해서 원하는 값이 나오도록 할 수 있었습니다. 구현을 위해, 초기값으로는 최소값(min)과 최대값(max)을 설정하게 되는데, 여기서 길이를 구하는 문제이기 때문에 최소값은 1로 처음에 설정을 해주어야 합니다. 이렇게 진행하지 않을 시, 이후 이분 탐색에서 중간값을 구할 때 중간값이 0이 나올 수도 있다는 문제가 생겨, 이 부분에 대한 처리가 꼭 필요합니다. const [counts, ...linesString] = fs .readFileSync(filePath) .toString() .trim() .split("\n"); const [K, N] = counts.split(" ").map(Number); const lines = linesString.map(Number); let min = 1; // 최소값으로 0이 아닌 1로 설정 let max = Math.max(...lines); // 최대값은 현재 주어진 값들 중 가장 큰 값 이후, while문을 통한 반복을 하게 되는데, 여기서 조건 설정에 대한 어려움이 있었습니다. 앞서 말한 Upper Bound를 하기 위해서는 순회 시 구해진 값이 요구되는 값과 일치될 때 만족시킨 중간값(mid)보다 더 큰 값으로 최소값을 설정해 반복해야 Upper Bound를 통해 요구되는 값보다 하나 더 큰 값을 얻을 수 있게 됩니다. 하지만, 이렇게 진행을 하고 나서, 마지막에 while문을 종료시켜야 하는데 이 때 적용할 조건으로 기존에는 최소값이 최대값보다 작은 상황(min &lt; max)에 대해서만 진행하도록 했습니다. 이럴 경우 틀렸다는 결과가 나오게 되는데 이는 max값이 1이 될 수도 있다는 것을 고려하지 못하기 때문입니다. max가 1인 상황에서도 해당 순회가 한 번은 돌아가고 이에 따른 결과가 나와야 하기 때문에, min ≤ max로 조건을 설정해야 합니다. 그리고 이렇게 조건을 진행할 경우, 기존의 Upper Bound와 달리 한 번 더 max값에 대한 처리가 이루어지기 때문에 추가적인 -1 조치는 필요가 없어지게 됩니다. while (min &lt;= max) { const mid = Math.floor((min + max) / 2); const count = lines.reduce((prev, next) =&gt; { return prev + Math.floor(next / mid); }, 0); // 모든 같은 길이의 전선들의 합 if (count &gt;= N) { // 값이 일치하더라도 최대까지 진행해 나가야 함 min = mid + 1; } else { max = mid - 1; } } console.log(max);]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">BINARY HEAP ∙ PRIORITY QUEUE</title><link href="http://localhost:4000/algorithm/2022/12/04/BINARY-HEAP-PRIORITY-QUEUE/" rel="alternate" type="text/html" title="BINARY HEAP ∙ PRIORITY QUEUE" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/12/04/BINARY%20HEAP%20%E2%88%99%20PRIORITY%20QUEUE</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/12/04/BINARY-HEAP-PRIORITY-QUEUE/"><![CDATA[<blockquote>
  <p>해당 내용은 UDEMY의 <a href="https://www.udemy.com/course/best-javascript-data-structures/">알고리즘 ∙ 자료구조 강의</a>를 수강 후 정리한 내용입니다.</p>
</blockquote>

<h3 id="이진-힙binary-heap">이진 힙(Binary Heap)</h3>

<p>두 개의 자식 노드를 가지며 부모 노드가 무조건 자식 노드보다 크거나(최대 이진 힙) 작은(최소 이진 힙) 구조를 의미합니다. 이진 검색 트리와 매우 비슷하나 몇 가지 다른 규칙들이 존재하는데, 최대 이진 힙의 경우, 부모 노드가 자식 노드보다 항상 큰 값을 가지고 최소 이진 힙에서는 이와 반대되어 존재합니다. 또한, 이진 힙은 언제나 <strong>최적의 용량을 가져, 가장 적은 용량</strong>을 채웁니다.</p>

<p>힙을 통해서 <strong>‘우선순위 큐’</strong>라는 것을 만들 수 있으며(항상 이진 힙이 사용), 그래프 순회에도 자주 사용됩니다.</p>

<h3 id="힙-정렬">힙 정렬</h3>

<p>앞서 말했듯, 힙 정렬은 이진 검색 트리와 다른 점으로 <strong>크기의 순서가 정해졌다는 것</strong>(큰 순서 ∙ 작은 순서)과 <strong>왼쪽이 무조건 먼저 들어온다</strong>는 것이 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221204/0.png" alt="" width="75%" height="" /> 
</figure>

<p>위 그림으로 보면 <code class="language-plaintext highlighter-rouge">index</code>가 n인 값의 왼쪽 자식은 <strong>2n+1</strong>, 오른쪽 자식은 <strong>2n+2</strong>의 인덱스에 저장된 것을 볼 수 있으며, 이를 통해서 부모의 위치를 기반으로 자식의 위치를 찾는 것을 할 수가 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">index</code> 11, 12의 경우, 각각 1을 빼고 2로 나눌 시 5, 5.5가 되는데 이를 <code class="language-plaintext highlighter-rouge">Math.floor()</code>로 표현할 시 5가 되고 이 값은 부모 요소의 <code class="language-plaintext highlighter-rouge">index</code>값이 됩니다.</p>

<h3 id="insert-메소드-만들기">Insert 메소드 만들기</h3>

<p>기본적으로 만들어지는 Binary Heap 클래스의 <code class="language-plaintext highlighter-rouge">constructor</code>는 <code class="language-plaintext highlighter-rouge">values=[]</code> 밖에 없으며, 나머지는 메소드를 통해서 이루어집니다.</p>

<p>이진 힙(최대값)을 만드는 과정에서, 이전 값보다 큰 값이 들어올 경우, <strong>bubble up</strong>을 해야 합니다.</p>

<ul>
  <li>부모와 자식 간의 값을 비교해서 자식이 더 큰 경우, 이 둘 사이의 index값을 바꿔줍니다.</li>
  <li>같은 형식을 반복해서 부모보다 올라가는 값이 작은 경우, 해당 형식을 중단합니다.</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MaxBinaryHeap</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">41</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">55</span><span class="p">];</span>
    <span class="c1">// 기본적으로 예시를 들어줄 값을 넣음</span>
  <span class="p">}</span>

  <span class="nx">insert</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">bubbleUp</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">bubbleUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// push되어 들어간 값이 마지막에 위치하므로 index를 위와 같이 설정</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="c1">// 현재 push되어 들어온 값</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// index가 현재 최대 이진 힙의 첫 자리보다 큰 경우 중단</span>
      <span class="kd">let</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
      <span class="c1">// 앞에서 나온 바와 같이, 현재 index의 부모 index는 1을 빼고 2로 나눈 값의 내림과 같음</span>
      <span class="kd">let</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">];</span>
      <span class="c1">// 부모 값을 구하고 비교</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span> <span class="o">&gt;=</span> <span class="nx">element</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="c1">// 부모 값이 더 작을 경우, 서로 위치를 바꿔주고 index값을 부모 값으로 만듬</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">parentIndex</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MaxBinaryHeap</span><span class="p">();</span>
<span class="nx">heap</span><span class="p">.</span><span class="nx">insert</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="extractmax-메소드-만들기">extractMax 메소드 만들기</h3>

<p>최대 이진 힙에서는 루트가 가장 큰 값을 갖게 되고, 이 값을 제거해주면 됩니다. 그리고 이 때 제거되고 비어있는 값을 그대로 내버려 둘 수는 없기 때문에, 이 부분을 가장 하단의 것과 교체하고 이를 내리는 작업이 필요합니다.이 과정을 버블 다운, 퍼콜레이트 다운, 시프트 다운, 싱크 다운 등의 단어들로 불립니다. 순서는 아래와 같습니다.</p>

<ol>
  <li>최대 값을 빼내고 해당 위치에 가장 마지막 인덱스의 값을 넣기</li>
  <li>루트에 위치한 값의 좌측 → 우측 순서로 보면서 루트값보다 큰 값이 있을 시 그 값과 교체</li>
  <li>교체하는 작업을 지속한 뒤, 좌측에 값이 없거나 양측의 값이 현재 값보다 작은 경우 교체 작업 중단</li>
  <li>좌 ∙ 우의 값 중 더 큰 값과 교체를 해야하므로, 좌측의 값 확인 후 우측의 값을 확인해 교체</li>
</ol>

<figure class="figure  figure--center">
  <img class="image" src="/image/221204/1.png" alt="" width="75%" height="" /> 
</figure>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">extractMax</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="c1">// 최대 값을 먼저 저장함</span>
  <span class="kd">const</span> <span class="nx">lastValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
  <span class="c1">// 마지막 값을 빼내어 갖고 있음</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 해당 정렬의 개수가 1개일 경우, pop을 하고 난 뒤에 다시 sinkDown으로 넣어주는 것을 방지</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lastValue</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sinkDown</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">max</span><span class="p">;</span>
  <span class="c1">// 최대값을 리턴함</span>
<span class="p">}</span>

<span class="nx">sinkDown</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">length</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="c1">// 계속 움직이면서 넣어주게 될 값</span>

  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 처음에는 index가 루트에서 출발하므로 0에서 시작</span>

  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">leftIndex</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">rightIndex</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="c1">// 현재 index와 바뀌게 될 index를 swap으로 설정</span>
    <span class="kd">let</span> <span class="nx">leftChild</span><span class="p">,</span> <span class="nx">rightChild</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">leftIndex</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 왼쪽 인덱스 값이 존재하고 해당 값이 기존 값보다 클 경우 swap에 저장</span>
      <span class="nx">leftChild</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">leftIndex</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">leftChild</span> <span class="o">&gt;</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">swap</span> <span class="o">=</span> <span class="nx">leftIndex</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">rightIndex</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 좌측보다 우측 값이 더 크고, 해당 값보다도 더 클 때 swap에 저장</span>
      <span class="nx">rightChild</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">rightIndex</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="o">!</span><span class="nx">swap</span> <span class="o">&amp;&amp;</span> <span class="nx">rightChild</span> <span class="o">&gt;</span> <span class="nx">element</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="nx">swap</span> <span class="o">&amp;&amp;</span> <span class="nx">rightChild</span> <span class="o">&gt;</span> <span class="nx">leftChild</span><span class="p">)</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">swap</span> <span class="o">=</span> <span class="nx">rightIndex</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">swap</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="c1">// swap에 없을 시 왼쪽 오른쪽 값보다 해당 값이 더 크다고 판단</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">swap</span><span class="p">];</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">swap</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="c1">// swap에 들어온 값과 서로 바꿔줌</span>
    <span class="nx">index</span> <span class="o">=</span> <span class="nx">swap</span><span class="p">;</span>
    <span class="c1">// 새로운 index로 바꾼 위치를 설정</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="우선-순위-큐queue">우선 순위 큐(Queue)</h3>

<p>각 요소가 그에 해당하는 우선순위를 가지는 데이터 구조입니다. 서로 다른 우선순위를 가지는 데이터나 정보를 관리할 필요가 있는 상황에서 활용할 수 있으며, 먼저 들어간 값이 존재한 상황에서도 이후에 들어온 값이 우선 순위를 갖고 있으면, 해당 값이 먼저 처리가 될 수 있도록 할 수 있습니다.</p>

<p>예시로 ‘유닉스’가 있는데, 여기서 프로세서 ID라고 할 수 있는 ‘나이스’가 우선순위의 역할을 합니다. 대부분은 입력된 순서대로 처리가 되지만, 간혹 다른 것들이 앞서서 실행되는 상황이 발생하기도 하며 이러한 상황에서 사용한다고 볼 수 있습니다.</p>

<p><strong>우선 순위 큐와 힙은 별개의 것으로 생각해야 하는데, 이는 그저 추상적인 개념에 불과하기 때문입니다.</strong></p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221204/2.png" alt="" width="75%" height="" /> 
</figure>

<p>예시로 위 사진을 보면, 우선순위가 가장 높은 1번을 찾아야하는데, 이 상황에서 별 다른 방법없이 직접 비교해가며 찾는 것을 할 경우, 1을 발견하고 나서 다른 것들이 1번보다 앞서는 지를 지속적으로 확인해야 한다는 문제점이 발생하게 됩니다. 이러한 상황에 우선 순위 큐를 활용할 수 있습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221204/3.png" alt="" width="75%" height="" /> 
</figure>

<p>위 예시 사진과 같이 우선 순위를 지정할 때, 이전에 있었던 요소들보다 더 우선순위가 높은 것이 들어오게 되면 이를 <strong>bubble up</strong> 시켜서 순위를 높이는 방식으로 문제를 처리할 수 있습니다. 이러한 방식의 처리는 <strong>O(logN)</strong>의 시간 복잡도가 나오고, 앞선 예시의 처리방식(시간복잡도가 <strong>O(N)</strong>)보다 훨씬 효율적으로 처리를 할 수 있습니다.</p>

<h3 id="우선-순위-큐-코드-작성">우선 순위 큐 코드 작성</h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">PriorityQueue</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="p">}</span>

  <span class="nx">enqueue</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">priority</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newNode</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">bubbleUp</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">bubbleUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
      <span class="kd">let</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">priority</span> <span class="o">&gt;=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">parentIndex</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">lastValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lastValue</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">sinkDown</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">max</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">sinkDown</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">length</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">leftIndex</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">rightIndex</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">swap</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">leftChild</span><span class="p">,</span> <span class="nx">rightChild</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">leftIndex</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">leftChild</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">leftIndex</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">leftChild</span><span class="p">.</span><span class="nx">priority</span> <span class="o">&gt;</span> <span class="nx">element</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">swap</span> <span class="o">=</span> <span class="nx">leftIndex</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">rightIndex</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rightChild</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">rightIndex</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span>
          <span class="p">(</span><span class="o">!</span><span class="nx">swap</span> <span class="o">&amp;&amp;</span> <span class="nx">rightChild</span><span class="p">.</span><span class="nx">priority</span> <span class="o">&gt;</span> <span class="nx">element</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">swap</span> <span class="o">&amp;&amp;</span> <span class="nx">rightChild</span><span class="p">.</span><span class="nx">priority</span> <span class="o">&gt;</span> <span class="nx">leftChild</span><span class="p">.</span><span class="nx">priority</span><span class="p">)</span>
        <span class="p">)</span> <span class="p">{</span>
          <span class="nx">swap</span> <span class="o">=</span> <span class="nx">rightIndex</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">swap</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">swap</span><span class="p">];</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">values</span><span class="p">[</span><span class="nx">swap</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="nx">swap</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">priority</span> <span class="o">=</span> <span class="nx">priority</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PriorityQueue</span><span class="p">();</span>

<span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">());</span>
</code></pre></div></div>

<p>위 코드를 보면, 이진 힙을 만들 때 사용했던 코드를 그대로 활용해서 만들 수 있습니다. 이 중에 달라진 것은 <code class="language-plaintext highlighter-rouge">Node</code>라는 클래스가 추가되고, 내부에 <code class="language-plaintext highlighter-rouge">value</code>(자체적인 값), <code class="language-plaintext highlighter-rouge">priority</code>(우선 순위)가 추가된다는 것입니다.</p>

<p>비교를 할 때 이진 힙에서는 값 자체로 비교를 했으나, 여기서는 추가적인 <code class="language-plaintext highlighter-rouge">Node</code> 클래스를 만들었기 때문에 내부에 있는 <code class="language-plaintext highlighter-rouge">priority</code>로 비교를 해주면 됩니다. 현재 위 코드는 최대 이진 힙으로 만들어진 것을 변형했지만, 여기서 부등호만 변경해주면 최소 이진 힙으로 만들 수 있으며, 이를 통해 <code class="language-plaintext highlighter-rouge">priority</code>가 작은 값이 가장 위에 위치하도록 설정할 수 있습니다.</p>

<p>현재 코드는 우선 순위로만 비교를 하지만, 실제 활용 시에는 우선 순위외에 다른 요소들이 들어올 수 있어, <code class="language-plaintext highlighter-rouge">Node</code> 클래스에 해당 요소를 추가하고 이를 <code class="language-plaintext highlighter-rouge">enqueue</code>나 <code class="language-plaintext highlighter-rouge">dequeue</code>에서 더 활용하면서 우선 순위를 지정해줄 수 있습니다.</p>

<p>우선 순위 큐는 위와 같은 과정을 통해서 삽입과 제거 모두 <strong>O(logN)</strong>의 시간 복잡도를 가집니다.</p>

<h3 id="이진-힙의-big-o">이진 힙의 BIG O</h3>

<p>이진 힙의 경우 <strong>O(logN)</strong>의 시간 복잡도를 가지는데, 이는 상당히 빠른 속도로 문제를 해결할 수 있다는 것을 알 수 있습니다. (logN이라는 것은 2를 밑으로 하는 log의 N배라는 것을 의미)</p>

<p>예를 들어, 노드가 5개의 층인 경우, 총 2의 5제곱의 노드들이 생성되게 되는데, 이러한 상황에서도 노드가 추가될 때에는 총 5의 시간 복잡도를 갖게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221204/4.png" alt="" width="75%" height="" /> 
</figure>

<p>최악의 상황이 위 사진과 같이 나올 수 있는데, 이런 경우에는 heap을 사용할 수가 없습니다. 왜냐하면 heap은 기본적으로 이러한 모양이 될 수가 없다는 것을 전제(무조건 왼쪽 ∙ 오른쪽 순서로 값을 채워나감)로 하기 때문</p>

<p>이진 힙에서 값을 찾아야 하는 경우에는 <strong>O(N)</strong>의 시간복잡도가 나오게 됩니다. 즉, <strong>이진 힙은 탐색보다는 삽입과 제거를 다루는 상황에 가장 최적화된 구조</strong>라는 것을 알 수 있습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[해당 내용은 UDEMY의 알고리즘 ∙ 자료구조 강의를 수강 후 정리한 내용입니다. 이진 힙(Binary Heap) 두 개의 자식 노드를 가지며 부모 노드가 무조건 자식 노드보다 크거나(최대 이진 힙) 작은(최소 이진 힙) 구조를 의미합니다. 이진 검색 트리와 매우 비슷하나 몇 가지 다른 규칙들이 존재하는데, 최대 이진 힙의 경우, 부모 노드가 자식 노드보다 항상 큰 값을 가지고 최소 이진 힙에서는 이와 반대되어 존재합니다. 또한, 이진 힙은 언제나 최적의 용량을 가져, 가장 적은 용량을 채웁니다. 힙을 통해서 ‘우선순위 큐’라는 것을 만들 수 있으며(항상 이진 힙이 사용), 그래프 순회에도 자주 사용됩니다. 힙 정렬 앞서 말했듯, 힙 정렬은 이진 검색 트리와 다른 점으로 크기의 순서가 정해졌다는 것(큰 순서 ∙ 작은 순서)과 왼쪽이 무조건 먼저 들어온다는 것이 있습니다. 위 그림으로 보면 index가 n인 값의 왼쪽 자식은 2n+1, 오른쪽 자식은 2n+2의 인덱스에 저장된 것을 볼 수 있으며, 이를 통해서 부모의 위치를 기반으로 자식의 위치를 찾는 것을 할 수가 있습니다. 예를 들어, index 11, 12의 경우, 각각 1을 빼고 2로 나눌 시 5, 5.5가 되는데 이를 Math.floor()로 표현할 시 5가 되고 이 값은 부모 요소의 index값이 됩니다. Insert 메소드 만들기 기본적으로 만들어지는 Binary Heap 클래스의 constructor는 values=[] 밖에 없으며, 나머지는 메소드를 통해서 이루어집니다. 이진 힙(최대값)을 만드는 과정에서, 이전 값보다 큰 값이 들어올 경우, bubble up을 해야 합니다. 부모와 자식 간의 값을 비교해서 자식이 더 큰 경우, 이 둘 사이의 index값을 바꿔줍니다. 같은 형식을 반복해서 부모보다 올라가는 값이 작은 경우, 해당 형식을 중단합니다. class MaxBinaryHeap { constructor() { this.values = [41, 39, 33, 18, 27, 12, 55]; // 기본적으로 예시를 들어줄 값을 넣음 } insert(element) { this.values.push(element); this.bubbleUp(); } bubbleUp() { let index = this.values.length - 1; // push되어 들어간 값이 마지막에 위치하므로 index를 위와 같이 설정 const element = this.values[index]; // 현재 push되어 들어온 값 while (index &gt; 0) { // index가 현재 최대 이진 힙의 첫 자리보다 큰 경우 중단 let parentIndex = Math.floor((index - 1) / 2); // 앞에서 나온 바와 같이, 현재 index의 부모 index는 1을 빼고 2로 나눈 값의 내림과 같음 let parent = this.values[parentIndex]; // 부모 값을 구하고 비교 if (parent &gt;= element) break; // 부모 값이 더 작을 경우, 서로 위치를 바꿔주고 index값을 부모 값으로 만듬 this.values[parentIndex] = element; this.values[index] = parent; index = parentIndex; } } } const heap = new MaxBinaryHeap(); heap.insert(); extractMax 메소드 만들기 최대 이진 힙에서는 루트가 가장 큰 값을 갖게 되고, 이 값을 제거해주면 됩니다. 그리고 이 때 제거되고 비어있는 값을 그대로 내버려 둘 수는 없기 때문에, 이 부분을 가장 하단의 것과 교체하고 이를 내리는 작업이 필요합니다.이 과정을 버블 다운, 퍼콜레이트 다운, 시프트 다운, 싱크 다운 등의 단어들로 불립니다. 순서는 아래와 같습니다. 최대 값을 빼내고 해당 위치에 가장 마지막 인덱스의 값을 넣기 루트에 위치한 값의 좌측 → 우측 순서로 보면서 루트값보다 큰 값이 있을 시 그 값과 교체 교체하는 작업을 지속한 뒤, 좌측에 값이 없거나 양측의 값이 현재 값보다 작은 경우 교체 작업 중단 좌 ∙ 우의 값 중 더 큰 값과 교체를 해야하므로, 좌측의 값 확인 후 우측의 값을 확인해 교체 extractMax() { const max = this.values[0]; // 최대 값을 먼저 저장함 const lastValue = this.values.pop(); // 마지막 값을 빼내어 갖고 있음 if (this.values.length) { // 해당 정렬의 개수가 1개일 경우, pop을 하고 난 뒤에 다시 sinkDown으로 넣어주는 것을 방지 this.values[0] = lastValue; this.sinkDown(); } return max; // 최대값을 리턴함 } sinkDown() { const { length } = this.values; const element = this.values[0]; // 계속 움직이면서 넣어주게 될 값 let index = 0; // 처음에는 index가 루트에서 출발하므로 0에서 시작 while (true) { const leftIndex = index * 2 + 1; const rightIndex = index * 2 + 2; let swap = null; // 현재 index와 바뀌게 될 index를 swap으로 설정 let leftChild, rightChild; if (leftIndex &lt; length) { // 왼쪽 인덱스 값이 존재하고 해당 값이 기존 값보다 클 경우 swap에 저장 leftChild = this.values[leftIndex]; if (leftChild &gt; element) { swap = leftIndex; } } if (rightIndex &lt; length) { // 좌측보다 우측 값이 더 크고, 해당 값보다도 더 클 때 swap에 저장 rightChild = this.values[rightIndex]; if ( (!swap &amp;&amp; rightChild &gt; element) || (swap &amp;&amp; rightChild &gt; leftChild) ) { swap = rightIndex; } } if (!swap) break; // swap에 없을 시 왼쪽 오른쪽 값보다 해당 값이 더 크다고 판단 this.values[index] = this.values[swap]; this.values[swap] = element; // swap에 들어온 값과 서로 바꿔줌 index = swap; // 새로운 index로 바꾼 위치를 설정 } } 우선 순위 큐(Queue) 각 요소가 그에 해당하는 우선순위를 가지는 데이터 구조입니다. 서로 다른 우선순위를 가지는 데이터나 정보를 관리할 필요가 있는 상황에서 활용할 수 있으며, 먼저 들어간 값이 존재한 상황에서도 이후에 들어온 값이 우선 순위를 갖고 있으면, 해당 값이 먼저 처리가 될 수 있도록 할 수 있습니다. 예시로 ‘유닉스’가 있는데, 여기서 프로세서 ID라고 할 수 있는 ‘나이스’가 우선순위의 역할을 합니다. 대부분은 입력된 순서대로 처리가 되지만, 간혹 다른 것들이 앞서서 실행되는 상황이 발생하기도 하며 이러한 상황에서 사용한다고 볼 수 있습니다. 우선 순위 큐와 힙은 별개의 것으로 생각해야 하는데, 이는 그저 추상적인 개념에 불과하기 때문입니다. 예시로 위 사진을 보면, 우선순위가 가장 높은 1번을 찾아야하는데, 이 상황에서 별 다른 방법없이 직접 비교해가며 찾는 것을 할 경우, 1을 발견하고 나서 다른 것들이 1번보다 앞서는 지를 지속적으로 확인해야 한다는 문제점이 발생하게 됩니다. 이러한 상황에 우선 순위 큐를 활용할 수 있습니다. 위 예시 사진과 같이 우선 순위를 지정할 때, 이전에 있었던 요소들보다 더 우선순위가 높은 것이 들어오게 되면 이를 bubble up 시켜서 순위를 높이는 방식으로 문제를 처리할 수 있습니다. 이러한 방식의 처리는 O(logN)의 시간 복잡도가 나오고, 앞선 예시의 처리방식(시간복잡도가 O(N))보다 훨씬 효율적으로 처리를 할 수 있습니다. 우선 순위 큐 코드 작성 class PriorityQueue { constructor() { this.values = []; } enqueue(value, priority) { const newNode = new Node(value, priority); this.values.push(newNode); this.bubbleUp(); } bubbleUp() { let index = this.values.length - 1; const element = this.values[index]; while (index &gt; 0) { let parentIndex = Math.floor((index - 1) / 2); let parent = this.values[parentIndex]; if (parent.priority &gt;= element.priority) break; this.values[parentIndex] = element; this.values[index] = parent; index = parentIndex; } } dequeue() { const max = this.values[0]; const lastValue = this.values.pop(); if (this.values.length) { this.values[0] = lastValue; this.sinkDown(); } return max; } sinkDown() { const { length } = this.values; const element = this.values[0]; let index = 0; while (true) { const leftIndex = index * 2 + 1; const rightIndex = index * 2 + 2; let swap = null; let leftChild, rightChild; if (leftIndex &lt; length) { leftChild = this.values[leftIndex]; if (leftChild.priority &gt; element.priority) { swap = leftIndex; } } if (rightIndex &lt; length) { rightChild = this.values[rightIndex]; if ( (!swap &amp;&amp; rightChild.priority &gt; element.priority) || (swap &amp;&amp; rightChild.priority &gt; leftChild.priority) ) { swap = rightIndex; } } if (!swap) break; this.values[index] = this.values[swap]; this.values[swap] = element; index = swap; } } } class Node { constructor(value, priority) { this.value = value; this.priority = priority; } } const queue = new PriorityQueue(); queue.enqueue("A", 1); queue.enqueue("B", 5); queue.enqueue("C", 2); console.log(queue.values); console.log(queue.dequeue()); 위 코드를 보면, 이진 힙을 만들 때 사용했던 코드를 그대로 활용해서 만들 수 있습니다. 이 중에 달라진 것은 Node라는 클래스가 추가되고, 내부에 value(자체적인 값), priority(우선 순위)가 추가된다는 것입니다. 비교를 할 때 이진 힙에서는 값 자체로 비교를 했으나, 여기서는 추가적인 Node 클래스를 만들었기 때문에 내부에 있는 priority로 비교를 해주면 됩니다. 현재 위 코드는 최대 이진 힙으로 만들어진 것을 변형했지만, 여기서 부등호만 변경해주면 최소 이진 힙으로 만들 수 있으며, 이를 통해 priority가 작은 값이 가장 위에 위치하도록 설정할 수 있습니다. 현재 코드는 우선 순위로만 비교를 하지만, 실제 활용 시에는 우선 순위외에 다른 요소들이 들어올 수 있어, Node 클래스에 해당 요소를 추가하고 이를 enqueue나 dequeue에서 더 활용하면서 우선 순위를 지정해줄 수 있습니다. 우선 순위 큐는 위와 같은 과정을 통해서 삽입과 제거 모두 O(logN)의 시간 복잡도를 가집니다. 이진 힙의 BIG O 이진 힙의 경우 O(logN)의 시간 복잡도를 가지는데, 이는 상당히 빠른 속도로 문제를 해결할 수 있다는 것을 알 수 있습니다. (logN이라는 것은 2를 밑으로 하는 log의 N배라는 것을 의미) 예를 들어, 노드가 5개의 층인 경우, 총 2의 5제곱의 노드들이 생성되게 되는데, 이러한 상황에서도 노드가 추가될 때에는 총 5의 시간 복잡도를 갖게 됩니다. 최악의 상황이 위 사진과 같이 나올 수 있는데, 이런 경우에는 heap을 사용할 수가 없습니다. 왜냐하면 heap은 기본적으로 이러한 모양이 될 수가 없다는 것을 전제(무조건 왼쪽 ∙ 오른쪽 순서로 값을 채워나감)로 하기 때문 이진 힙에서 값을 찾아야 하는 경우에는 O(N)의 시간복잡도가 나오게 됩니다. 즉, 이진 힙은 탐색보다는 삽입과 제거를 다루는 상황에 가장 최적화된 구조라는 것을 알 수 있습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 2470번</title><link href="http://localhost:4000/algorithm/2022/12/04/%EB%B0%B1%EC%A4%80-2470%EB%B2%88/" rel="alternate" type="text/html" title="백준 2470번" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/12/04/%EB%B0%B1%EC%A4%80%202470%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/12/04/%EB%B0%B1%EC%A4%80-2470%EB%B2%88/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/2470">QUESTION LINK</a></strong></p>

<p>주어진 숫자들 중 합이 0에 가깝도록 만들 수 있는 두 숫자를 찾는 문제였습니다. 투 포인터를 이용해서 풀어야하는 문제였고, 해당 문제를 풀기 위한 순서는 아래와 같습니다.</p>

<ol>
  <li>주어진 숫자들을 오름차순으로 정렬하기 (-98, -15, 0, 1, 22)</li>
  <li>정렬된 숫자들의 왼쪽, 오른쪽에 각각 포인터를 두기</li>
  <li>각 포인터에 해당하는 값들의 합을 구하고, 현재 갖고 있는 최소값과 비교하기</li>
  <li>구해진 합이 최소값보다 큰 경우, 해당 포인터의 값과 최소값 저장하기</li>
  <li>구해진 합이 0보다 큰 경우(우측 포인터 값이 좌측 포인터 값보다 큰 경우), 좌측 포인터를 한 칸 내리기</li>
  <li>구해진 합이 0보다 작은 경우(좌측 포인터 값이 우측 포인터 값보다 큰 경우), 우측 포인터를 한 칸 올리기</li>
  <li>우측 포인터와 좌측 포인터가 만나기 전까지 위 과정을 반복하기</li>
</ol>

<p>위의 과정을 코드로 표현하면 아래와 같은 형태가 나오게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">values</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">toString</span><span class="p">().</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">sortedValues</span> <span class="o">=</span> <span class="nx">values</span>
  <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nb">Number</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">);</span>
<span class="c1">// 주어진 값들을 숫자로 만들고, 그 숫자들을 오름차순으로 정렬함</span>

<span class="kd">let</span> <span class="nx">results</span><span class="p">;</span>
<span class="c1">// 결과를 담을 변수</span>
<span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 왼쪽 포인터의 index값으로, 처음에 0으로 시작함</span>
<span class="kd">let</span> <span class="nx">end</span> <span class="o">=</span> <span class="nx">sortedValues</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 오른쪽 포인터의 index값으로, 처음에 배열의 마지막부터 시작함</span>
<span class="kd">let</span> <span class="nx">min</span><span class="p">;</span>
<span class="c1">// 포인터의 합 중 최소값일 경우 해당 변수에 담음</span>
<span class="kd">let</span> <span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="c1">// true일 시 반복문 종료</span>

<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">isEnd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">sortedValues</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">+</span> <span class="nx">sortedValues</span><span class="p">[</span><span class="nx">end</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">min</span> <span class="o">||</span> <span class="nx">min</span> <span class="o">&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">sum</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// 현재의 합이 최소값보다 작은 경우, 최소값과 결과값을 변경함</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
    <span class="nx">results</span> <span class="o">=</span> <span class="p">[</span><span class="nx">sortedValues</span><span class="p">[</span><span class="nx">start</span><span class="p">],</span> <span class="nx">sortedValues</span><span class="p">[</span><span class="nx">end</span><span class="p">]];</span>
  <span class="p">}</span>
  <span class="c1">// 0보다 작을 시 왼쪽 포인터를 한 칸 올리고, 0보다 클 시 오른쪽 포인터를 한 칸 내림</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">start</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">end</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="nx">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>해당 문제는 투 포인터를 이용해서 풀 수 있는 대표적인 문제였습니다. 하지만, 처음에 문제를 풀 때 <strong>포인터를 이동하기 위한 조건(합이 0보다 크거나 작을 때 해당 포인터 이동)</strong>을 제대로 설정하지 못했고, 이로 인해 허비된 시간이 많았습니다. 투 포인터를 사용하며 기본적으로 이동시키기 위한 조건이 올바르게 설정되도록 유의해야 합니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 주어진 숫자들 중 합이 0에 가깝도록 만들 수 있는 두 숫자를 찾는 문제였습니다. 투 포인터를 이용해서 풀어야하는 문제였고, 해당 문제를 풀기 위한 순서는 아래와 같습니다. 주어진 숫자들을 오름차순으로 정렬하기 (-98, -15, 0, 1, 22) 정렬된 숫자들의 왼쪽, 오른쪽에 각각 포인터를 두기 각 포인터에 해당하는 값들의 합을 구하고, 현재 갖고 있는 최소값과 비교하기 구해진 합이 최소값보다 큰 경우, 해당 포인터의 값과 최소값 저장하기 구해진 합이 0보다 큰 경우(우측 포인터 값이 좌측 포인터 값보다 큰 경우), 좌측 포인터를 한 칸 내리기 구해진 합이 0보다 작은 경우(좌측 포인터 값이 우측 포인터 값보다 큰 경우), 우측 포인터를 한 칸 올리기 우측 포인터와 좌측 포인터가 만나기 전까지 위 과정을 반복하기 위의 과정을 코드로 표현하면 아래와 같은 형태가 나오게 됩니다. const [count, values] = fs.readFileSync(filePath).toString().trim().split("\n"); const sortedValues = values .split(" ") .map(Number) .sort((a, b) =&gt; a - b); // 주어진 값들을 숫자로 만들고, 그 숫자들을 오름차순으로 정렬함 let results; // 결과를 담을 변수 let start = 0; // 왼쪽 포인터의 index값으로, 처음에 0으로 시작함 let end = sortedValues.length - 1; // 오른쪽 포인터의 index값으로, 처음에 배열의 마지막부터 시작함 let min; // 포인터의 합 중 최소값일 경우 해당 변수에 담음 let isEnd = false; // true일 시 반복문 종료 while (!isEnd) { const sum = sortedValues[start] + sortedValues[end]; if (!min || min &gt; Math.abs(sum)) { // 현재의 합이 최소값보다 작은 경우, 최소값과 결과값을 변경함 min = Math.abs(sum); results = [sortedValues[start], sortedValues[end]]; } // 0보다 작을 시 왼쪽 포인터를 한 칸 올리고, 0보다 클 시 오른쪽 포인터를 한 칸 내림 if (sum &lt; 0) { start += 1; } else if (sum &gt; 0) { end -= 1; } else { isEnd = true; } if (start === end) isEnd = true; } const result = results.join(" "); console.log(result); 해당 문제는 투 포인터를 이용해서 풀 수 있는 대표적인 문제였습니다. 하지만, 처음에 문제를 풀 때 포인터를 이동하기 위한 조건(합이 0보다 크거나 작을 때 해당 포인터 이동)을 제대로 설정하지 못했고, 이로 인해 허비된 시간이 많았습니다. 투 포인터를 사용하며 기본적으로 이동시키기 위한 조건이 올바르게 설정되도록 유의해야 합니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">페이지 내 일부만 최신 상태로 변경하기</title><link href="http://localhost:4000/react/2022/12/01/%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%82%B4-%EC%9D%BC%EB%B6%80%EB%A7%8C-%EC%B5%9C%EC%8B%A0-%EC%83%81%ED%83%9C%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-copy/" rel="alternate" type="text/html" title="페이지 내 일부만 최신 상태로 변경하기" /><published>2022-12-01T00:00:00+09:00</published><updated>2022-12-01T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/12/01/%ED%8E%98%EC%9D%B4%EC%A7%80%20%EB%82%B4%20%EC%9D%BC%EB%B6%80%EB%A7%8C%20%EC%B5%9C%EC%8B%A0%20%EC%83%81%ED%83%9C%EB%A1%9C%20%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0%20copy</id><content type="html" xml:base="http://localhost:4000/react/2022/12/01/%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%82%B4-%EC%9D%BC%EB%B6%80%EB%A7%8C-%EC%B5%9C%EC%8B%A0-%EC%83%81%ED%83%9C%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0-copy/"><![CDATA[<h3 id="페이지-렌더링-시-처음부터-데이터를-사용하는-문제">페이지 렌더링 시 처음부터 데이터를 사용하는 문제</h3>

<p>진행 중인 프로젝트의 쉐어 상세 페이지 내에서, 현재 처음에 페이지 정보를 모두 받아와 보여주는 방식으로 구성이 되어 있습니다. 하지만, 이렇게 진행할 경우 사용자가 쉐어 신청 ∙ 취소를 할 때와 찜 하기 ∙ 취소를 할 때, 즉각적인 업데이트를 위해서는 페이지 정보를 모두 다시 받아와야 합니다. 이로 인해 버튼을 클릭할 때마다 페이지의 로딩이 이루어지고 다시 화면이 보이는 깜빡거림 문제가 발생하게 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221201/3.gif" alt="" width="50%" height="" /> 
</figure>

<p>이를 해결하기 위한 방법으로 두 가지가 존재합니다.</p>

<ol>
  <li>서버와 호환하지 않고, 클라이언트에서 버튼 클릭 상황에 대한 값을 갖고 사진과 인원수 조절하기</li>
  <li>버튼 클릭 후 서버와 통신이 이루어질 시 바로 해당 부분 업데이트하기</li>
</ol>

<p>기존에는 1번의 방법으로 시도해 일부 성공하였으나, 백엔드와의 회의 후, 버튼을 클릭한 뒤에는 가능한 최신의 상태를 받는 것이 좋을 것이라는 결론에 도달했습니다. 이를 위해 기존에 클라이언트에서만 호환이 되던 상태를 없애고 API를 통해 받은 값을 사용해야했는데, 기존에 사용 중인 쉐어 상세 데이터를 다시 호출하는 것은 앞서 진행한 바와 같이, 화면의 깜빡임이 지속됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221201/0.png" alt="" width="100%" height="" /> 
</figure>

<h3 id="api-재호출-및-일부분-사용">API 재호출 및 일부분 사용</h3>

<p>문제를 해결하기 위해서 서버로부터 새로운 API를 요구해 받는 것은 무리가 있어, <strong>기존 API를 통해 가져올 수 있었던 쉐어 상세 데이터 값 중 일부를 새롭게 설정하는 방법</strong>을 사용하기로 했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221201/1.png" alt="" width="100%" height="" /> 
</figure>

<p>현재 버튼을 클릭하여 수행하며 바뀌는 값들을 쉐어 상세 데이터로부터 따로 빼내어 가져오는 것을 먼저 진행했습니다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">type</span> <span class="nx">RecruitmentType</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nb">Pick</span><span class="o">&lt;</span>
      <span class="nx">ShareDetailType</span><span class="p">,</span>
      <span class="o">|</span> <span class="dl">"</span><span class="s2">recruitmentMemberThumbnailImageUrls</span><span class="dl">"</span>
      <span class="o">|</span> <span class="dl">"</span><span class="s2">currentRecruitment</span><span class="dl">"</span>
      <span class="o">|</span> <span class="dl">"</span><span class="s2">finalRecruitment</span><span class="dl">"</span>
      <span class="o">|</span> <span class="dl">"</span><span class="s2">wishCount</span><span class="dl">"</span>
    <span class="o">&gt;</span>
  <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">recruitmentTrigger</span> <span class="o">=</span> <span class="nx">atom</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">({</span>
  <span class="na">key</span><span class="p">:</span> <span class="s2">`recruitmentTrigger`</span><span class="p">,</span>
  <span class="na">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">});</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">recruitmentState</span> <span class="o">=</span> <span class="nx">selectorFamily</span><span class="o">&lt;</span><span class="nx">RecruitmentType</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">({</span>
  <span class="na">key</span><span class="p">:</span> <span class="s2">`GET/recruitmentState/</span><span class="p">${</span><span class="nx">getRandomKey</span><span class="p">()}</span><span class="s2">`</span><span class="p">,</span>
  <span class="na">get</span><span class="p">:</span>
    <span class="p">(</span><span class="na">id</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="k">async</span> <span class="p">({</span> <span class="kd">get</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">get</span><span class="p">(</span><span class="nx">shareDetailTrigger</span><span class="p">);</span>
      <span class="c1">// 쉐어 상세 데이터가 바뀔 경우 데이터를 다시 받아오기 위해 설정</span>
      <span class="kd">get</span><span class="p">(</span><span class="nx">recruitmentTrigger</span><span class="p">);</span>
      <span class="c1">// 현제 상태값을 한 번 다시 바꿔주기 위해 사용</span>
      <span class="kd">const</span> <span class="nx">shareDetailData</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getShareDetailData</span><span class="p">({</span> <span class="nx">id</span> <span class="p">});</span>
      <span class="c1">// API를 통해 쉐어 상세 데이터 값을 받아옴</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shareDetailData</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">shareDetailData</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="kd">const</span> <span class="p">{</span>
        <span class="nx">recruitmentMemberThumbnailImageUrls</span><span class="p">,</span>
        <span class="nx">currentRecruitment</span><span class="p">,</span>
        <span class="nx">finalRecruitment</span><span class="p">,</span>
        <span class="nx">wishCount</span><span class="p">,</span>
      <span class="p">}</span> <span class="o">=</span> <span class="nx">shareDetailData</span><span class="p">;</span>
      <span class="c1">// 데이터 중 필요한 것만 일부 빼내어 사용함</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">recruitmentMemberThumbnailImageUrls</span><span class="p">,</span>
        <span class="nx">currentRecruitment</span><span class="p">,</span>
        <span class="nx">finalRecruitment</span><span class="p">,</span>
        <span class="nx">wishCount</span><span class="p">,</span>
      <span class="p">};</span>
    <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위와 같이 설정을 해주고, 이를 실제로 사용해 줄 위치에 받아와 사용하면 됩니다. 이 때, 이 데이터들이 실제로 적용되기 전에 보여져야 할 값들을 지정해주어야 하며 이를 위해서 초기값을 만든 뒤, API를 통해 값을 받은 뒤에는 해당 값을 보여주도록 설정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 초기값을 설정하여 상태값에 넣어줌</span>
<span class="kd">const</span> <span class="nx">defaultRecruitmentInfo</span><span class="p">:</span> <span class="nx">RecruitmentType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">recruitmentMemberThumbnailImageUrls</span><span class="p">:</span> <span class="p">[</span><span class="nx">writerThumbnailImageUrl</span><span class="p">],</span>
  <span class="na">currentRecruitment</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">finalRecruitment</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">wishCount</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">curRecruitmentInfo</span><span class="p">,</span> <span class="nx">setCurRecruitmentInfo</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">defaultRecruitmentInfo</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">{</span> <span class="na">state</span><span class="p">:</span> <span class="nx">recruitmentInfoState</span><span class="p">,</span> <span class="na">contents</span><span class="p">:</span> <span class="nx">recruitmentInfo</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useRecoilValueLoadable</span><span class="p">(</span>
  <span class="nx">recruitmentState</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">),</span>
<span class="p">);</span>
<span class="c1">// 실제 사용될 값들을 설정</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">currentRecruitment</span><span class="p">,</span> <span class="nx">finalRecruitment</span><span class="p">,</span> <span class="nx">recruitmentMemberThumbnailImageUrls</span> <span class="p">}</span> <span class="o">=</span>
  <span class="nx">curRecruitmentInfo</span><span class="p">;</span>

<span class="p">...</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// API를 통해 호출된 값이 정상적으로 들어있을 경우 호출된 값을 보여줄 값으로서 설정</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">recruitmentInfoState</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">hasValue</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">recruitmentInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setCurRecruitmentInfo</span><span class="p">(</span><span class="nx">recruitmentInfo</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">recruitmentInfoState</span><span class="p">]);</span>
</code></pre></div></div>

<p>위와 같이 설정이 끝나면 마지막으로, 저 설정된 API들을 원하는 상황에도 새롭게 받아올 수 있도록 <code class="language-plaintext highlighter-rouge">trigger</code>들을 적용해주면 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">changeParticipating</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isRequestSuccess</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">request</span><span class="p">({</span> <span class="nx">id</span> <span class="p">});</span>
  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isRequestSuccess</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">setRecruitmentTrigger</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 정상적으로 요청이 진행되었을 경우, trigger를 실행시켜 서버로부터 최신의 상태값을 받아오도록 함</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">message</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">요청을 처리하지 못했습니다.</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221201/2.gif" alt="" width="50%" height="" /> 
</figure>

<h3 id="생각보다-어려웠던-이유">생각보다 어려웠던 이유</h3>

<p>이 부분을 수행하며 처음에 가장 어려움을 느낀 부분은 ‘이미 페이지의 가장 처음 부분에서 쓰이는 값들이 있는 경우, 어떻게 일부분만 수정을 하도록 할 것인지’였습니다. 이번에 수정하며 얻은 답은 <strong>‘새롭게 업데이트할 부분만 상태값을 다시 만들어준다’</strong>였지만, 가능하다면 이후에는 <strong>쉐어 상세 페이지의 모든 부분들이 깜빡임 없이 업데이트가 이루어질 수 있도록</strong> 수정할 필요가 있습니다.</p>]]></content><author><name>JinJeon</name></author><category term="REACT" /><summary type="html"><![CDATA[페이지 렌더링 시 처음부터 데이터를 사용하는 문제 진행 중인 프로젝트의 쉐어 상세 페이지 내에서, 현재 처음에 페이지 정보를 모두 받아와 보여주는 방식으로 구성이 되어 있습니다. 하지만, 이렇게 진행할 경우 사용자가 쉐어 신청 ∙ 취소를 할 때와 찜 하기 ∙ 취소를 할 때, 즉각적인 업데이트를 위해서는 페이지 정보를 모두 다시 받아와야 합니다. 이로 인해 버튼을 클릭할 때마다 페이지의 로딩이 이루어지고 다시 화면이 보이는 깜빡거림 문제가 발생하게 됩니다. 이를 해결하기 위한 방법으로 두 가지가 존재합니다. 서버와 호환하지 않고, 클라이언트에서 버튼 클릭 상황에 대한 값을 갖고 사진과 인원수 조절하기 버튼 클릭 후 서버와 통신이 이루어질 시 바로 해당 부분 업데이트하기 기존에는 1번의 방법으로 시도해 일부 성공하였으나, 백엔드와의 회의 후, 버튼을 클릭한 뒤에는 가능한 최신의 상태를 받는 것이 좋을 것이라는 결론에 도달했습니다. 이를 위해 기존에 클라이언트에서만 호환이 되던 상태를 없애고 API를 통해 받은 값을 사용해야했는데, 기존에 사용 중인 쉐어 상세 데이터를 다시 호출하는 것은 앞서 진행한 바와 같이, 화면의 깜빡임이 지속됩니다. API 재호출 및 일부분 사용 문제를 해결하기 위해서 서버로부터 새로운 API를 요구해 받는 것은 무리가 있어, 기존 API를 통해 가져올 수 있었던 쉐어 상세 데이터 값 중 일부를 새롭게 설정하는 방법을 사용하기로 했습니다. 현재 버튼을 클릭하여 수행하며 바뀌는 값들을 쉐어 상세 데이터로부터 따로 빼내어 가져오는 것을 먼저 진행했습니다. export type RecruitmentType = | Pick&lt; ShareDetailType, | "recruitmentMemberThumbnailImageUrls" | "currentRecruitment" | "finalRecruitment" | "wishCount" &gt; | undefined; export const recruitmentTrigger = atom&lt;number&gt;({ key: `recruitmentTrigger`, default: 0, }); export const recruitmentState = selectorFamily&lt;RecruitmentType, string&gt;({ key: `GET/recruitmentState/${getRandomKey()}`, get: (id: string) =&gt; async ({ get }) =&gt; { get(shareDetailTrigger); // 쉐어 상세 데이터가 바뀔 경우 데이터를 다시 받아오기 위해 설정 get(recruitmentTrigger); // 현제 상태값을 한 번 다시 바꿔주기 위해 사용 const shareDetailData = await getShareDetailData({ id }); // API를 통해 쉐어 상세 데이터 값을 받아옴 if (!shareDetailData || typeof shareDetailData === "string") return; const { recruitmentMemberThumbnailImageUrls, currentRecruitment, finalRecruitment, wishCount, } = shareDetailData; // 데이터 중 필요한 것만 일부 빼내어 사용함 return { recruitmentMemberThumbnailImageUrls, currentRecruitment, finalRecruitment, wishCount, }; }, }); 위와 같이 설정을 해주고, 이를 실제로 사용해 줄 위치에 받아와 사용하면 됩니다. 이 때, 이 데이터들이 실제로 적용되기 전에 보여져야 할 값들을 지정해주어야 하며 이를 위해서 초기값을 만든 뒤, API를 통해 값을 받은 뒤에는 해당 값을 보여주도록 설정했습니다. // 초기값을 설정하여 상태값에 넣어줌 const defaultRecruitmentInfo: RecruitmentType = { recruitmentMemberThumbnailImageUrls: [writerThumbnailImageUrl], currentRecruitment: 1, finalRecruitment: 1, wishCount: 0, }; const [curRecruitmentInfo, setCurRecruitmentInfo] = useState(defaultRecruitmentInfo); const { state: recruitmentInfoState, contents: recruitmentInfo } = useRecoilValueLoadable( recruitmentState(`${id}`), ); // 실제 사용될 값들을 설정 const { currentRecruitment, finalRecruitment, recruitmentMemberThumbnailImageUrls } = curRecruitmentInfo; ... useEffect(() =&gt; { // API를 통해 호출된 값이 정상적으로 들어있을 경우 호출된 값을 보여줄 값으로서 설정 if (recruitmentInfoState === 'hasValue' &amp;&amp; recruitmentInfo) { setCurRecruitmentInfo(recruitmentInfo); return; } }, [recruitmentInfoState]); 위와 같이 설정이 끝나면 마지막으로, 저 설정된 API들을 원하는 상황에도 새롭게 받아올 수 있도록 trigger들을 적용해주면 됩니다. const changeParticipating = async () =&gt; { const isRequestSuccess = await request({ id }); ... if (isRequestSuccess) { ... setRecruitmentTrigger((prev) =&gt; prev + 1); // 정상적으로 요청이 진행되었을 경우, trigger를 실행시켜 서버로부터 최신의 상태값을 받아오도록 함 } else { message = '요청을 처리하지 못했습니다.'; } ... }; 생각보다 어려웠던 이유 이 부분을 수행하며 처음에 가장 어려움을 느낀 부분은 ‘이미 페이지의 가장 처음 부분에서 쓰이는 값들이 있는 경우, 어떻게 일부분만 수정을 하도록 할 것인지’였습니다. 이번에 수정하며 얻은 답은 ‘새롭게 업데이트할 부분만 상태값을 다시 만들어준다’였지만, 가능하다면 이후에는 쉐어 상세 페이지의 모든 부분들이 깜빡임 없이 업데이트가 이루어질 수 있도록 수정할 필요가 있습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 5430번</title><link href="http://localhost:4000/algorithm/2022/11/26/5430/" rel="alternate" type="text/html" title="백준 5430번" /><published>2022-11-26T00:00:00+09:00</published><updated>2022-11-26T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/26/5430</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/26/5430/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/5430">QUESTION LINK</a></strong></p>

<p>배열의 앞 ∙ 뒤를 제거한 다음 마지막에 나오게 된 배열을 보여주면 되는 문제입니다. 처음에는 deque를 구현하고, 이를 사용해서 문제를 해결하고자 했습니다. 하지만, 배열의 앞 ∙ 뒤 만을 제거해주면 되므로, <strong>제거된 부분들이 어디인지만 확인하고, 마지막에 한 번에 제거해주면 된다</strong>는 사실을 알고 이를 구현하고자 했습니다.</p>

<p>그리고 이런 식으로 위치가 다 지정된 뒤에는 <code class="language-plaintext highlighter-rouge">isLeft</code> 값에 따라 마지막에 만들어진 배열을 <code class="language-plaintext highlighter-rouge">Array.reverse()</code>를 통해 뒤집을 지를 결정하면 됩니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221126/0.png" alt="" width="100%" height="" /> 
</figure>

<p>여기서 처음에 문제가 되었던 부분 중 하나는 배열이 문자열 형식으로 들어온다는 것이었는데, 이는 배열의 앞 ∙ 뒤가 <code class="language-plaintext highlighter-rouge">‘[’</code>, <code class="language-plaintext highlighter-rouge">‘]’</code>로 이루어졌다는 점을 통해, <code class="language-plaintext highlighter-rouge">String.substring()</code>으로 앞 ∙ 뒤를 제거하고 ‘,’를 통해서 배열을 직접 만들어주는 것으로 설정했습니다. 그리고 배열이 비어있는 경우는 변환 시 <code class="language-plaintext highlighter-rouge">['']</code>와 같은 형태가 되어, 이를 구분 짓는 방법도 추가해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">_</span><span class="p">,</span> <span class="p">...</span><span class="nx">commands</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fs</span>
  <span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">trim</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[];</span>

<span class="nx">commands</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">commandLine</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">arrayString</span> <span class="o">=</span> <span class="nx">commands</span><span class="p">[</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">command</span> <span class="o">=</span> <span class="nx">commandLine</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="nx">arrayString</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">arrayString</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">);</span>
  <span class="c1">// 배열 문자열의 앞 뒤를 자르고 ','로 구분된 배열을 만듬</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span><span class="p">)</span> <span class="nx">array</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
  <span class="c1">// 빈 배열의 문자열인 경우 실제로 배열이 비어있게 만듬</span>

  <span class="p">...</span>
</code></pre></div></div>

<p>그리고 위에서 하고자 했던 방법과 같이, 명령어에 따라 ‘R’인 경우는 뒤집혔다는 것을 나타내기 위해 <code class="language-plaintext highlighter-rouge">isLeft</code>값을 기존 값에서 바꾸고, ‘D’인 경우에는 <code class="language-plaintext highlighter-rouge">isLeft</code>의 상태에 따라 왼쪽 값을 늘리거나 또는 오른쪽 값을 줄입니다.</p>

<p>여기서 에러를 판단하는 상황이 중요했는데, 이는 <strong>왼쪽, 오른쪽이 삭제되면서 점점 만나고 왼쪽이 오른쪽보다 커질 때 더 이상 삭제할 것이 없다</strong>고 판단하는 것으로 처리했습니다.</p>

<p>그리고 여기서 한 가지 더 예외 처리를 해주어야 할 것은, <strong>에러가 발생하는 타이밍이 ‘D’를 입력했을 경우라서 배열이 비어있다고 무조건 에러를 보여주어선 안 됩니다.</strong></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>

  <span class="kd">let</span> <span class="nx">isLeft</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">isError</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="nx">command</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">word</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isError</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// 에러라면 더 이상 진행하지 않음</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">word</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">R</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// isLeft값만을 계속 바꿔주어 어느쪽에서 삭제를 해야하는 지 결정함</span>
      <span class="nx">isLeft</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isLeft</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// isLeft 값에 따라 삭제할 곳을 정함</span>
      <span class="nx">isLeft</span> <span class="p">?</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="nx">right</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&gt;</span> <span class="nx">right</span><span class="p">)</span> <span class="nx">isError</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 왼쪽이 오른쪽보다 커지는 경우 더 이상 삭제할 것이 없으므로 에러를 보여줌</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isError</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resultArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">curResult</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">);</span>
  <span class="c1">// 남아있는 배열들을 가져옴</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isLeft</span><span class="p">)</span> <span class="nx">curResult</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
  <span class="c1">// 거꾸로 된 상활일 경우 한 번 뒤집어줌</span>
  <span class="nx">resultArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curResult</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">resultArray</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">)</span> <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="s2">`[</span><span class="p">${</span><span class="nx">value</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">)}</span><span class="s2">]`</span><span class="p">;</span>
    <span class="c1">// 배열 문자열로 다시 만들어줌</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>이 문제의 경우, 예외 처리를 해주는 상황에서 계속 문제를 틀리게 됐습니다. 특히, 처음에 ‘D’를 입력했을 때 비어있는 경우 에러를 보여주어야 하는데, 배열이 비어있으면 무조건 에러를 보여주는 것으로 처리를 하는 바람에 문제가 되었습니다. 더불어, 빈 배열을 입력받는 경우, 이를 실제 배열로 바꾸면 <code class="language-plaintext highlighter-rouge">[’’]</code>의 형태가 되는데, 이를 그대로 처리하려다보니 문제가 되었습니다. 올바른 처리를 위해서는 처음에 설정을 할 때 확실하게 예외 처리를 하는 것이 중요하다는 걸 느꼈습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 배열의 앞 ∙ 뒤를 제거한 다음 마지막에 나오게 된 배열을 보여주면 되는 문제입니다. 처음에는 deque를 구현하고, 이를 사용해서 문제를 해결하고자 했습니다. 하지만, 배열의 앞 ∙ 뒤 만을 제거해주면 되므로, 제거된 부분들이 어디인지만 확인하고, 마지막에 한 번에 제거해주면 된다는 사실을 알고 이를 구현하고자 했습니다. 그리고 이런 식으로 위치가 다 지정된 뒤에는 isLeft 값에 따라 마지막에 만들어진 배열을 Array.reverse()를 통해 뒤집을 지를 결정하면 됩니다. 여기서 처음에 문제가 되었던 부분 중 하나는 배열이 문자열 형식으로 들어온다는 것이었는데, 이는 배열의 앞 ∙ 뒤가 ‘[’, ‘]’로 이루어졌다는 점을 통해, String.substring()으로 앞 ∙ 뒤를 제거하고 ‘,’를 통해서 배열을 직접 만들어주는 것으로 설정했습니다. 그리고 배열이 비어있는 경우는 변환 시 ['']와 같은 형태가 되어, 이를 구분 짓는 방법도 추가해주었습니다. const [_, ...commands] = fs .readFileSync(filePath) .toString() .trim() .split("\n"); const resultArray = []; commands.forEach((commandLine, index) =&gt; { if (index % 3 !== 0) return; const arrayString = commands[index + 2]; const command = commandLine.split(""); const array = arrayString.substring(1, arrayString.length - 1).split(","); // 배열 문자열의 앞 뒤를 자르고 ','로 구분된 배열을 만듬 if (!array[0].length) array.pop(); // 빈 배열의 문자열인 경우 실제로 배열이 비어있게 만듬 ... 그리고 위에서 하고자 했던 방법과 같이, 명령어에 따라 ‘R’인 경우는 뒤집혔다는 것을 나타내기 위해 isLeft값을 기존 값에서 바꾸고, ‘D’인 경우에는 isLeft의 상태에 따라 왼쪽 값을 늘리거나 또는 오른쪽 값을 줄입니다. 여기서 에러를 판단하는 상황이 중요했는데, 이는 왼쪽, 오른쪽이 삭제되면서 점점 만나고 왼쪽이 오른쪽보다 커질 때 더 이상 삭제할 것이 없다고 판단하는 것으로 처리했습니다. 그리고 여기서 한 가지 더 예외 처리를 해주어야 할 것은, 에러가 발생하는 타이밍이 ‘D’를 입력했을 경우라서 배열이 비어있다고 무조건 에러를 보여주어선 안 됩니다. ... let isLeft = true; let left = 0; let right = array.length; let isError = false; command.forEach((word) =&gt; { if (isError) return; // 에러라면 더 이상 진행하지 않음 if (word === "R") { // isLeft값만을 계속 바꿔주어 어느쪽에서 삭제를 해야하는 지 결정함 isLeft = !isLeft; } else { // isLeft 값에 따라 삭제할 곳을 정함 isLeft ? (left += 1) : (right -= 1); if (left &gt; right) isError = true; // 왼쪽이 오른쪽보다 커지는 경우 더 이상 삭제할 것이 없으므로 에러를 보여줌 } }); if (isError) { resultArray.push("error"); return; } const curResult = array.slice(left, right); // 남아있는 배열들을 가져옴 if (!isLeft) curResult.reverse(); // 거꾸로 된 상활일 경우 한 번 뒤집어줌 resultArray.push(curResult); }); const result = resultArray .map((value) =&gt; { if (value === "error") return value; return `[${value.join(",")}]`; // 배열 문자열로 다시 만들어줌 }) .join("\n"); console.log(result); 이 문제의 경우, 예외 처리를 해주는 상황에서 계속 문제를 틀리게 됐습니다. 특히, 처음에 ‘D’를 입력했을 때 비어있는 경우 에러를 보여주어야 하는데, 배열이 비어있으면 무조건 에러를 보여주는 것으로 처리를 하는 바람에 문제가 되었습니다. 더불어, 빈 배열을 입력받는 경우, 이를 실제 배열로 바꾸면 [’’]의 형태가 되는데, 이를 그대로 처리하려다보니 문제가 되었습니다. 올바른 처리를 위해서는 처음에 설정을 할 때 확실하게 예외 처리를 하는 것이 중요하다는 걸 느꼈습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 2504번</title><link href="http://localhost:4000/algorithm/2022/11/24/2504/" rel="alternate" type="text/html" title="백준 2504번" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/24/2504</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/24/2504/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/2504">QEUSTION LINK</a></strong></p>

<p>문제에서 주어진 괄호 각각의 형태에 따라 조건을 나누어 풀어야 하는 문제였습니다. stack 자료구조를 사용해서 풀어야 했는데, 처음에 풀 때에는 어떤 식으로 계산을 풀어나가야 할 지에 대해 의문이 들었습니다. 우선 다음과 같은 순서에 따라 문제를 풀고자 했습니다.</p>

<ul>
  <li>열린 괄호일 때 <code class="language-plaintext highlighter-rouge">stack</code>에 담아주기</li>
  <li>닫힌 괄호일 때 <code class="language-plaintext highlighter-rouge">stack.pop()</code>의 값이 열린 괄호와 일치하는지 확인하기</li>
  <li>일치할 경우 해당 값으로 <code class="language-plaintext highlighter-rouge">stack</code>에 다시 넣어주기</li>
</ul>

<p>stack을 통해서 괄호가 일치하는 경우에 대해서만 처리해야한다는 사실은 인지했으나, 이미 계산이 된 숫자들을 어떤 식으로 담고, 처리를 진행해야할 지에 대해서는 어려움이 남았었습니다. 예를 들어, 아래와 같은 상황이 발생했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// '(()[][]' 여기까지 진행된 상태일 때, '])' 부분을 어떻게 처리할 지</span>
<span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="c1">// 여기서 "]"가 나오면 3을 어떤 식으로 처리하고 넘어가야 할 지를 파악하지 못함</span>
</code></pre></div></div>

<p>이 부분에서 어려움이 있었으나, 이후, stack에서 하나씩 pop을 할 때, 숫자가 나오면 해당 숫자들을 더하고, 다시 여는 괄호(”[”, “(”)가 나오면 해당 괄호에 관한 값을 곱해주면 된다는 것을 알 수 있었습니다.</p>

<ul>
  <li>닫힌 괄호일 때 <code class="language-plaintext highlighter-rouge">stack.pop()</code>의 값이 숫자일 경우 기존 내부값에 더하기</li>
  <li>닫힌 괄호일 때 <code class="language-plaintext highlighter-rouge">stack.pop()</code>의 값이 일치하는 열린 괄호일 경우 해당 값으로 내부값 곱하기</li>
</ul>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">isResult</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="c1">// 괄호가 올바른 지에 대한 boolean 값</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">string</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">insideValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 현재 닫는 괄호의 내부에 있는 값들의 합</span>
  <span class="kd">let</span> <span class="nx">stop</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">isResult</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 여는 괄호가 나오면 기존에 더해두었던 값에 괄호에 해당하는 값을 곱해주고,</span>
    <span class="c1">// 값이 없는 경우(비어있는 경우) 2를 stack에 담아줌</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">insideValue</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">||</span> <span class="mi">2</span><span class="p">);</span>
      <span class="nx">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="c1">// 숫자가 나오면 해당 숫자를 기존에 있던 값에 더해주고, 다시 stack에서 pop</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">insideValue</span> <span class="o">+=</span> <span class="nx">prevString</span><span class="p">;</span>
      <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
      <span class="c1">// 숫자나 일치하는 여는 괄호가 아닐 시, 잘못된 괄호가 들어온 것이므로 결과가 틀렸음을 설정</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">isResult</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 흐름으로 관련된 괄호들에 대한 모든 조건식을 만들어주면 아래와 같은 전체 코드가 나오게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">stringArray</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="c1">// 입력값을 모두 쪼개둔 값</span>
<span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">isResult</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="nx">stringArray</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isResult</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">string</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">string</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">insideValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">stop</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">isResult</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">insideValue</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">||</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nx">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">insideValue</span> <span class="o">+=</span> <span class="nx">prevString</span><span class="p">;</span>
        <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">isResult</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">string</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">string</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">insideValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">stop</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">isResult</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">stop</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">insideValue</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">||</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nx">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">prevString</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">insideValue</span> <span class="o">+=</span> <span class="nx">prevString</span><span class="p">;</span>
        <span class="nx">prevString</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">isResult</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위 코드를 통해 <code class="language-plaintext highlighter-rouge">stack</code> 결과값을 가져올 때 올바른 괄호 배치가 이루어졌을 시에는 숫자만 담긴 배열이 나오게 됩니다. 하지만, 서로 일치하지 않는 괄호를 가진 경우에는 배열이 비어있거나, 괄호값이 남아있는 채로 <code class="language-plaintext highlighter-rouge">stack</code> 배열이 나오게 됩니다. 즉, 배열 내의 요소들이 숫자로만 이루어진 경우에만 해당 숫자값을 결과로 리턴하고 나머지는 0으로 리턴하면 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isResult</span> <span class="p">?</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">result</span> <span class="p">:</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QEUSTION LINK 문제에서 주어진 괄호 각각의 형태에 따라 조건을 나누어 풀어야 하는 문제였습니다. stack 자료구조를 사용해서 풀어야 했는데, 처음에 풀 때에는 어떤 식으로 계산을 풀어나가야 할 지에 대해 의문이 들었습니다. 우선 다음과 같은 순서에 따라 문제를 풀고자 했습니다. 열린 괄호일 때 stack에 담아주기 닫힌 괄호일 때 stack.pop()의 값이 열린 괄호와 일치하는지 확인하기 일치할 경우 해당 값으로 stack에 다시 넣어주기 stack을 통해서 괄호가 일치하는 경우에 대해서만 처리해야한다는 사실은 인지했으나, 이미 계산이 된 숫자들을 어떤 식으로 담고, 처리를 진행해야할 지에 대해서는 어려움이 남았었습니다. 예를 들어, 아래와 같은 상황이 발생했습니다. // '(()[][]' 여기까지 진행된 상태일 때, '])' 부분을 어떻게 처리할 지 const stack = ["(", 2, "[", 3, 3]; // 여기서 "]"가 나오면 3을 어떤 식으로 처리하고 넘어가야 할 지를 파악하지 못함 이 부분에서 어려움이 있었으나, 이후, stack에서 하나씩 pop을 할 때, 숫자가 나오면 해당 숫자들을 더하고, 다시 여는 괄호(”[”, “(”)가 나오면 해당 괄호에 관한 값을 곱해주면 된다는 것을 알 수 있었습니다. 닫힌 괄호일 때 stack.pop()의 값이 숫자일 경우 기존 내부값에 더하기 닫힌 괄호일 때 stack.pop()의 값이 일치하는 열린 괄호일 경우 해당 값으로 내부값 곱하기 let isResult = true; // 괄호가 올바른 지에 대한 boolean 값 if (string === ")") { let insideValue = 0; // 현재 닫는 괄호의 내부에 있는 값들의 합 let stop = false; let prevString = stack.pop(); while (isResult &amp;&amp; !stop) { // 여는 괄호가 나오면 기존에 더해두었던 값에 괄호에 해당하는 값을 곱해주고, // 값이 없는 경우(비어있는 경우) 2를 stack에 담아줌 if (prevString === "(") { stack.push(insideValue * 2 || 2); stop = true; // 숫자가 나오면 해당 숫자를 기존에 있던 값에 더해주고, 다시 stack에서 pop } else if (typeof prevString === "number") { insideValue += prevString; prevString = stack.pop(); // 숫자나 일치하는 여는 괄호가 아닐 시, 잘못된 괄호가 들어온 것이므로 결과가 틀렸음을 설정 } else { isResult = false; } } } 이러한 흐름으로 관련된 괄호들에 대한 모든 조건식을 만들어주면 아래와 같은 전체 코드가 나오게 됩니다. const stringArray = input[0].split(""); // 입력값을 모두 쪼개둔 값 const stack = []; let isResult = true; stringArray.forEach((string) =&gt; { if (!isResult) return; if (string === "(") { stack.push(string); } if (string === ")") { let insideValue = 0; let stop = false; let prevString = stack.pop(); while (isResult &amp;&amp; !stop) { if (prevString === "(") { stack.push(insideValue * 2 || 2); stop = true; } else if (typeof prevString === "number") { insideValue += prevString; prevString = stack.pop(); } else { isResult = false; } } } if (string === "[") { stack.push(string); } if (string === "]") { let insideValue = 0; let stop = false; let prevString = stack.pop(); while (isResult &amp;&amp; !stop) { if (prevString === "[") { stack.push(insideValue * 3 || 3); stop = true; } else if (typeof prevString === "number") { insideValue += prevString; prevString = stack.pop(); } else { isResult = false; } } } }); 위 코드를 통해 stack 결과값을 가져올 때 올바른 괄호 배치가 이루어졌을 시에는 숫자만 담긴 배열이 나오게 됩니다. 하지만, 서로 일치하지 않는 괄호를 가진 경우에는 배열이 비어있거나, 괄호값이 남아있는 채로 stack 배열이 나오게 됩니다. 즉, 배열 내의 요소들이 숫자로만 이루어진 경우에만 해당 숫자값을 결과로 리턴하고 나머지는 0으로 리턴하면 됩니다. const result = isResult ? stack.reduce((a, b) =&gt; a + b, 0) : 0; console.log(typeof result === "number" ? result : 0);]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 18115번</title><link href="http://localhost:4000/algorithm/2022/11/24/18115/" rel="alternate" type="text/html" title="백준 18115번" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/24/18115</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/24/18115/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/18115">QUESTION LINK</a></strong></p>

<p>카드가 규칙에 따라 이동해서 만들어진 카드의 최종적인 오름차순 배열 형태를 다시 기존 형태로 되돌려야하는 문제입니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>
<span class="mi">2</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span>
</code></pre></div></div>

<p>예를 들어, 위와 같은 값이 주어졌다고 할 때, 실제로 만들어진 카드의 최종 결과물은 왼쪽이 아래, 오른쪽이 위라고 할 때 아래와 같은 형태를 만들게 됩니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<p>여기서, 기존의 배열로 되돌리기 위해서는 가장 위에 있는 카드, 즉 위 배열의 가장 마지막 요소부터 차례대로 규칙을 반대로 적용해서 문제를 풀어주면 됩니다. 여기서 불필요한 배열을 줄이기 위해 위 예시를 통해 만들어지는 규칙 배열의 index를 활용하기로 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">orders</span> <span class="o">=</span> <span class="nx">ordersArray</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// [2, 3, 3, 2, 1]</span>
<span class="kd">const</span> <span class="nx">ordersLength</span> <span class="o">=</span> <span class="nx">orders</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="c1">// 각 요소의 ordersLength - index는 실제 카드의 숫자를 나타내게 됨</span>
</code></pre></div></div>

<p>이를 활용해 순서 배열들을 거꾸로 순회하며, 해당 카드의 규칙 이전 상태로 되돌리는 코드를 아래와 같이 작성했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">orders</span> <span class="o">=</span> <span class="nx">ordersArray</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">ordersLength</span> <span class="o">=</span> <span class="nx">orders</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// 실제 카드의 숫자</span>
<span class="kd">let</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 결과 배열. index가 클 수록 아래에 있는 것으로 가정</span>

<span class="c1">// 카드 숫자가 실제 카드의 개수보다 많아지면 종료</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">target</span> <span class="o">&lt;=</span> <span class="nx">orders</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 카드의 정해져있던 명령</span>
  <span class="kd">const</span> <span class="nx">order</span> <span class="o">=</span> <span class="nx">orders</span><span class="p">[</span><span class="nx">ordersLength</span> <span class="o">-</span> <span class="nx">target</span><span class="p">];</span>

  <span class="c1">// 1인 경우 배열의 가장 처음으로 옴</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[</span><span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">resultArray</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// 2인 경우 배열의 두 번재 자리로 옴</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resultArray</span> <span class="o">=</span> <span class="p">[</span><span class="nx">resultArray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">resultArray</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)];</span>
  <span class="p">}</span>
  <span class="c1">// 3인 경우 가장 아래에 배치</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">3</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resultArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">target</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">resultArray</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>위와 같은 코드를 작성하여 예시로 정해져있던 문제들을 모두 해결할 수 있었습니다. 하지만, 이런 식으로 문제를 해결할 경우, ‘시간 초과’가 계속해서 나왔고, 이 문제를 해결하기 위한 방법을 다시 생각해보았습니다.</p>

<p>여기서 이 문제의 기본적인 사용 알고리즘이 ‘덱’이라는 것을 알게 됐습니다. 이를 위해, 자바스크립트로 ‘덱’을 만드는 방법을 다시 고안했습니다.</p>

<p><strong>덱(deque)은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조의 형태로, 두 개의 포인터를 사용해 양쪽에서 삭제와 삽입을 발생시킬 수 있습니다. 큐(queue)와 스택(stack)을 합친 형태로 볼 수 있습니다.</strong></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 덱에서 각 노드들의 특징을 담은 클래스</span>
<span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 실제로 만들어질 덱의 클래스</span>
<span class="kd">class</span> <span class="nx">Deque</span> <span class="p">{</span>
  <span class="c1">// 처음에는 head, tail이 모두 비어있음</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// head에 값을 추가</span>
  <span class="nx">putHead</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="c1">// 값이 없는 경우, head와 tail이 모두 node로 설정됨</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 이전의 head를 새롭게 지정된 node의 뒷부분으로 보냄</span>
      <span class="kd">const</span> <span class="nx">prevHead</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">prevHead</span><span class="p">;</span>
      <span class="nx">prevHead</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// tail에 값을 추가</span>
  <span class="nx">putTail</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="c1">// 값이 없는 경우, head와 tail이 모두 node로 설정됨</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 이전의 tail을 새롭게 지정된 node의 앞부분으로 보냄</span>
      <span class="kd">const</span> <span class="nx">prevTail</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">;</span>
      <span class="nx">prevTail</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">prevTail</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 이번 문제를 풀기 위해 만들어진 메서드</span>
  <span class="nx">putSecond</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="c1">// 값이 없는 경우, head와 tail이 모두 node로 설정됨</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 값이 있는 경우, head의 뒤, 기존의 second앞에 배치하도록 설정</span>
      <span class="kd">const</span> <span class="p">{</span> <span class="nx">head</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">second</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">putTail</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">head</span><span class="p">;</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">second</span><span class="p">;</span>
        <span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
        <span class="nx">second</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// head를 제거하고 그 다음 값을 head로 설정</span>
  <span class="nx">getHead</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">prevHead</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">prevHead</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">prevHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// tail을 제거하고 그 다음 값을 tail로 설정</span>
  <span class="nx">getTail</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">prevTail</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="nx">prevTail</span><span class="p">.</span><span class="nx">prev</span><span class="p">;</span>
    <span class="nx">prevTail</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위와 같은 형태의 덱을 만들고, 이를 문제에 다시 적용해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Deque</span><span class="p">();</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">target</span> <span class="o">&lt;=</span> <span class="nx">orders</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">order</span> <span class="o">=</span> <span class="nx">orders</span><span class="p">[</span><span class="nx">ordersLength</span> <span class="o">-</span> <span class="nx">target</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">deque</span><span class="p">.</span><span class="nx">putHead</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="c1">// 가장 앞에 추가하므로 putHead 사용</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">deque</span><span class="p">.</span><span class="nx">putSecond</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="c1">// 두 번째 위치에 추가하므로 putSecond 사용</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">order</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">3</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">deque</span><span class="p">.</span><span class="nx">putTail</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="c1">// 가장 마지막에 추가하므로 putTail 사용</span>
  <span class="p">}</span>

  <span class="nx">target</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">curNode</span> <span class="o">=</span> <span class="nx">deque</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">curNode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="o">+=</span> <span class="s2">` </span><span class="p">${</span><span class="nx">curNode</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="nx">curNode</span> <span class="o">=</span> <span class="nx">curNode</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// 처음에 만들어진 빈칸 제거</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>위와 같은 형태를 사용함으로서 이 문제를 해결할 수 있었습니다. 이번 문제의 경우, 앞 ∙ 뒤로 자료를 추가하는 형태로 문제가 만들어져있었습니다. <strong>이러한 형태의 문제는 큐, 스택을 모두 사용해야 하므로 덱을 사용해야 한다는 것을 알게 됐고</strong>, 오래간만에 자바스크립트의 클래스도 사용해볼 수 있는 기회가 되었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 카드가 규칙에 따라 이동해서 만들어진 카드의 최종적인 오름차순 배열 형태를 다시 기존 형태로 되돌려야하는 문제입니다. 5 2 3 3 2 1 예를 들어, 위와 같은 값이 주어졌다고 할 때, 실제로 만들어진 카드의 최종 결과물은 왼쪽이 아래, 오른쪽이 위라고 할 때 아래와 같은 형태를 만들게 됩니다. [5, 4, 3, 2, 1]; 여기서, 기존의 배열로 되돌리기 위해서는 가장 위에 있는 카드, 즉 위 배열의 가장 마지막 요소부터 차례대로 규칙을 반대로 적용해서 문제를 풀어주면 됩니다. 여기서 불필요한 배열을 줄이기 위해 위 예시를 통해 만들어지는 규칙 배열의 index를 활용하기로 했습니다. const orders = ordersArray.split(" "); // [2, 3, 3, 2, 1] const ordersLength = orders.length; // 각 요소의 ordersLength - index는 실제 카드의 숫자를 나타내게 됨 이를 활용해 순서 배열들을 거꾸로 순회하며, 해당 카드의 규칙 이전 상태로 되돌리는 코드를 아래와 같이 작성했습니다. const orders = ordersArray.split(" "); const ordersLength = orders.length; let target = 1; // 실제 카드의 숫자 let resultArray = []; // 결과 배열. index가 클 수록 아래에 있는 것으로 가정 // 카드 숫자가 실제 카드의 개수보다 많아지면 종료 while (target &lt;= orders.length) { // 카드의 정해져있던 명령 const order = orders[ordersLength - target]; // 1인 경우 배열의 가장 처음으로 옴 if (order === "1") { resultArray = [target, ...resultArray]; } // 2인 경우 배열의 두 번재 자리로 옴 if (order === "2") { resultArray = [resultArray[0], target, ...resultArray.slice(1)]; } // 3인 경우 가장 아래에 배치 if (order === "3") { resultArray.push(target); } target += 1; } const result = resultArray.join(" "); console.log(result); 위와 같은 코드를 작성하여 예시로 정해져있던 문제들을 모두 해결할 수 있었습니다. 하지만, 이런 식으로 문제를 해결할 경우, ‘시간 초과’가 계속해서 나왔고, 이 문제를 해결하기 위한 방법을 다시 생각해보았습니다. 여기서 이 문제의 기본적인 사용 알고리즘이 ‘덱’이라는 것을 알게 됐습니다. 이를 위해, 자바스크립트로 ‘덱’을 만드는 방법을 다시 고안했습니다. 덱(deque)은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조의 형태로, 두 개의 포인터를 사용해 양쪽에서 삭제와 삽입을 발생시킬 수 있습니다. 큐(queue)와 스택(stack)을 합친 형태로 볼 수 있습니다. // 덱에서 각 노드들의 특징을 담은 클래스 class Node { constructor(data) { this.data = data; this.prev = null; this.next = null; } } // 실제로 만들어질 덱의 클래스 class Deque { // 처음에는 head, tail이 모두 비어있음 constructor() { this.count = 0; this.head = null; this.tail = null; } // head에 값을 추가 putHead(data) { const node = new Node(data); // 값이 없는 경우, head와 tail이 모두 node로 설정됨 if (!this.count) { this.head = node; this.tail = node; } else { // 이전의 head를 새롭게 지정된 node의 뒷부분으로 보냄 const prevHead = this.head; this.head = node; this.head.next = prevHead; prevHead.prev = node; } this.count += 1; } // tail에 값을 추가 putTail(data) { const node = new Node(data); // 값이 없는 경우, head와 tail이 모두 node로 설정됨 if (!this.count) { this.head = node; this.tail = node; } else { // 이전의 tail을 새롭게 지정된 node의 앞부분으로 보냄 const prevTail = this.tail; prevTail.next = node; node.prev = prevTail; this.tail = node; } this.count += 1; } // 이번 문제를 풀기 위해 만들어진 메서드 putSecond(data) { const node = new Node(data); // 값이 없는 경우, head와 tail이 모두 node로 설정됨 if (!this.count) { this.head = node; this.tail = node; } else { // 값이 있는 경우, head의 뒤, 기존의 second앞에 배치하도록 설정 const { head } = this; const second = head.next; if (!second) { this.putTail(data); } else { node.prev = head; node.next = second; head.next = node; second.prev = node; this.count += 1; } } } // head를 제거하고 그 다음 값을 head로 설정 getHead() { if (!this.head) return; const prevHead = this.head; this.head = prevHead.next; prevHead.next = null; this.count -= 1; return data; } // tail을 제거하고 그 다음 값을 tail로 설정 getTail() { if (!this.tail) return; const prevTail = this.head; this.tail = prevTail.prev; prevTail.prev = null; this.count -= 1; return data; } } 위와 같은 형태의 덱을 만들고, 이를 문제에 다시 적용해주었습니다. let target = 1; const deque = new Deque(); while (target &lt;= orders.length) { const order = orders[ordersLength - target]; if (order === "1") { deque.putHead(target); // 가장 앞에 추가하므로 putHead 사용 } if (order === "2") { deque.putSecond(target); // 두 번째 위치에 추가하므로 putSecond 사용 } if (order === "3") { deque.putTail(target); // 가장 마지막에 추가하므로 putTail 사용 } target += 1; } let result = ""; let curNode = deque.head; while (curNode) { result += ` ${curNode.data}`; curNode = curNode.next; } result = result.slice(1); // 처음에 만들어진 빈칸 제거 console.log(result); 위와 같은 형태를 사용함으로서 이 문제를 해결할 수 있었습니다. 이번 문제의 경우, 앞 ∙ 뒤로 자료를 추가하는 형태로 문제가 만들어져있었습니다. 이러한 형태의 문제는 큐, 스택을 모두 사용해야 하므로 덱을 사용해야 한다는 것을 알게 됐고, 오래간만에 자바스크립트의 클래스도 사용해볼 수 있는 기회가 되었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 2800번</title><link href="http://localhost:4000/algorithm/2022/11/23/2800/" rel="alternate" type="text/html" title="백준 2800번" /><published>2022-11-23T00:00:00+09:00</published><updated>2022-11-23T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/11/23/2800</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/11/23/2800/"><![CDATA[<p><strong><a href="https://www.acmicpc.net/problem/2800">QUESTION LINK</a></strong></p>

<p>문자열 중에 괄호가 있는 곳을 찾고, 이 괄호들을 각자의 짝에 맞게 빼주어야 하는 문제였습니다. 각 괄호의 짝을 지어주는 부분이 중요했는데, 이는 왼쪽 괄호의 위치를 구하고, 오른쪽 괄호가 나올 때마다 마지막 왼쪽 괄호를 넣어주는 <strong>stack 구조</strong>를 활용하기로 했습니다. 문제를 푸는 순서는 다음과 같이 정했습니다.</p>

<ol>
  <li>주어진 식에서 왼쪽 괄호가 보일 때마다 괄호 배열에 해당 위치값을 넣어주기</li>
  <li>1번에서 왼쪽 괄호를 순회하며, 오른쪽 괄호가 보일 때 왼쪽 괄호 배열의 마지막 값을 빼내어 서로 연결해주는 객체에 저장하기</li>
  <li>각 괄호 짝이 없어지는 경우의 수가 담긴 배열 만들기</li>
  <li>경우의 수 배열을 정렬하기</li>
</ol>

<p>위 순서를 통해 진행을 하며, 1, 2번의 경우는 아래 코드와 같이 주어진 문자열을 forEach로 순회하며 진행하는 것으로 코드를 구성했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">expressionArr</span> <span class="o">=</span> <span class="nx">input</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">leftStack</span> <span class="o">=</span> <span class="p">[];</span>
<span class="c1">// 왼쪽 괄호를 담은 stack</span>
<span class="kd">const</span> <span class="nx">matchObj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 왼쪽 오른쪽 짝을 알려주는 객체</span>

<span class="c1">// 순회를 돌면서 왼쪽이 보일 때 stack에, 오른쪽이 보일 때 객체에 담아줌</span>
<span class="nx">expressionArr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">word</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">word</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="nx">leftStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">idx</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">word</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">leftKey</span> <span class="o">=</span> <span class="nx">leftStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="nx">matchObj</span><span class="p">[</span><span class="nx">leftKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">idx</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// (2+(2*2)+2) 일 때,</span>
<span class="c1">// matchObj: { '0': 10, '3': 7 } 결과값이 나옴</span>
</code></pre></div></div>

<p>그리고 주어진 <code class="language-plaintext highlighter-rouge">matchObj</code> 정보를 토대로 경우의 수를 구해야했는데, 이 때 경우의 수를 구하는 방법에 대한 고민이 많았고, 결론적으로 <strong>조합(Combination)</strong>을 적용해 <strong>1개부터 최대 개수의 괄호쌍이 없어질 때까지의 경우의 수</strong>를 찾아 없어졌을 때의 문자열을 결과 배열에 담아주면 되었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조합을 통한 경우의 수를 구하는 함수</span>
<span class="kd">const</span> <span class="nx">getCombination</span> <span class="o">=</span> <span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">selectedNumber</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="c1">// 결과 배열</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">selectedNumber</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">v</span><span class="p">]);</span>
  <span class="c1">// 선택의 가지수가 하나일 때에는 주어진 배열에서 각 요소를 배열로 만든 값을 리턴함</span>
  <span class="c1">// [[1],[2],[3]]의 형태</span>

  <span class="nx">array</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">fixed</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 각 요소를 고정값으로 두고, 요소의 뒷 부분부터 다시 조합을 적용함</span>
    <span class="kd">const</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">rest</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">restCombination</span> <span class="o">=</span> <span class="nx">getCombination</span><span class="p">(</span><span class="nx">rest</span><span class="p">,</span> <span class="nx">selectedNumber</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">attached</span> <span class="o">=</span> <span class="nx">restCombination</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">fixed</span><span class="p">,</span> <span class="p">...</span><span class="nx">v</span><span class="p">]);</span>
    <span class="c1">// 기존 고정값에 새롭게 적용된 조합들을 적용</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">attached</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위 조합 함수를 1개부터 n개의 괄호쌍이 빠질 때까지 찾아주어야 하므로 아래와 같이 <code class="language-plaintext highlighter-rouge">while</code>문으로 경우의 수를 모두 구해줄 수 있습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">matchKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">matchObj</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">matchKeys</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">combination</span> <span class="o">=</span> <span class="nx">getCombination</span><span class="p">(</span><span class="nx">matchKeys</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// [ [ '0' ], [ '3' ] ], [ [ '0', '3' ] ]</span>
</code></pre></div></div>

<p>마지막으로, 주어진 경우의 수 배열을 갖고 해당 위치의 괄호들을 없앤 문자열을 리턴하는 함수를 만들어 적용하도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getRemovedByTargets</span> <span class="o">=</span> <span class="p">(</span><span class="nx">targets</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">newExpressionArr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">expressionArr</span><span class="p">];</span>
  <span class="c1">// 새롭게 만들어질 문자열을 나누어둔 배열</span>
  <span class="nx">targets</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 문자열에서 지정된 부분들을 모두 제거</span>
    <span class="nx">newExpressionArr</span><span class="p">[</span><span class="nx">target</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nx">newExpressionArr</span><span class="p">[</span><span class="nx">matchObj</span><span class="p">[</span><span class="nx">target</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="c1">// 문자열을 생성하여 리턴</span>
  <span class="k">return</span> <span class="nx">newExpressionArr</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">resultArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
<span class="c1">// ((1))과 같은 괄호가 존재하는 경우에 대한 처리가 필요해 Set으로 처리</span>
<span class="kd">const</span> <span class="nx">matchKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">matchObj</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">matchKeys</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">combination</span> <span class="o">=</span> <span class="nx">getCombination</span><span class="p">(</span><span class="nx">matchKeys</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
  <span class="c1">// 생성된 combination에서 각 경우의 수들을 적용한 문자열을 결과값에 넣어줌</span>
  <span class="nx">combination</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">removed</span> <span class="o">=</span> <span class="nx">getRemovedByTargets</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">resultArray</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">removed</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 결과 리턴</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">resultArray</span><span class="p">].</span><span class="nx">sort</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</code></pre></div></div>

<p>이번 문제를 풀며, 가장 어려움을 느낀 곳은 <strong>조합 함수를 만드는 것</strong>이었습니다. 조합이 코드로 이루어지는 과정에서 재귀 함수를 사용하고 이 때, 재귀 함수가 종료되는 시점을 파악하는 것이 어려웠습니다. 항상 조합과 함께 따라오는 순열을 적용하는 함수를 만드는 것에 대한 공부도 필요합니다.</p>

<p>추가적으로, 예외 처리를 할 때 문제가 발생했었는데, 괄호가 중복으로 발생할 때에 대한 처리가 처음에는 제대로 이루어지지 않아 틀렸다는 결과가 나왔습니다. 그래서 위와 같이 <code class="language-plaintext highlighter-rouge">const resultArray = new Set();</code>를 사용하여 문제를 해결할 수 있었고, <strong>예외 처리에 대한 고려</strong>가 더 필요하다는 걸 알 수 있었습니다.</p>]]></content><author><name>JinJeon</name></author><category term="ALGORITHM" /><summary type="html"><![CDATA[QUESTION LINK 문자열 중에 괄호가 있는 곳을 찾고, 이 괄호들을 각자의 짝에 맞게 빼주어야 하는 문제였습니다. 각 괄호의 짝을 지어주는 부분이 중요했는데, 이는 왼쪽 괄호의 위치를 구하고, 오른쪽 괄호가 나올 때마다 마지막 왼쪽 괄호를 넣어주는 stack 구조를 활용하기로 했습니다. 문제를 푸는 순서는 다음과 같이 정했습니다. 주어진 식에서 왼쪽 괄호가 보일 때마다 괄호 배열에 해당 위치값을 넣어주기 1번에서 왼쪽 괄호를 순회하며, 오른쪽 괄호가 보일 때 왼쪽 괄호 배열의 마지막 값을 빼내어 서로 연결해주는 객체에 저장하기 각 괄호 짝이 없어지는 경우의 수가 담긴 배열 만들기 경우의 수 배열을 정렬하기 위 순서를 통해 진행을 하며, 1, 2번의 경우는 아래 코드와 같이 주어진 문자열을 forEach로 순회하며 진행하는 것으로 코드를 구성했습니다. const expressionArr = input[0].split(""); const leftStack = []; // 왼쪽 괄호를 담은 stack const matchObj = {}; // 왼쪽 오른쪽 짝을 알려주는 객체 // 순회를 돌면서 왼쪽이 보일 때 stack에, 오른쪽이 보일 때 객체에 담아줌 expressionArr.forEach((word, idx) =&gt; { if (word === "(") leftStack.push(idx); if (word === ")") { const leftKey = leftStack.pop(); matchObj[leftKey] = idx; } }); // (2+(2*2)+2) 일 때, // matchObj: { '0': 10, '3': 7 } 결과값이 나옴 그리고 주어진 matchObj 정보를 토대로 경우의 수를 구해야했는데, 이 때 경우의 수를 구하는 방법에 대한 고민이 많았고, 결론적으로 조합(Combination)을 적용해 1개부터 최대 개수의 괄호쌍이 없어질 때까지의 경우의 수를 찾아 없어졌을 때의 문자열을 결과 배열에 담아주면 되었습니다. // 조합을 통한 경우의 수를 구하는 함수 const getCombination = (array, selectedNumber) =&gt; { const results = []; // 결과 배열 if (selectedNumber === 1) return array.map((v) =&gt; [v]); // 선택의 가지수가 하나일 때에는 주어진 배열에서 각 요소를 배열로 만든 값을 리턴함 // [[1],[2],[3]]의 형태 array.forEach((fixed, index) =&gt; { // 각 요소를 고정값으로 두고, 요소의 뒷 부분부터 다시 조합을 적용함 const rest = array.slice(index + 1); if (!rest.length) return; const restCombination = getCombination(rest, selectedNumber - 1); const attached = restCombination.map((v) =&gt; [fixed, ...v]); // 기존 고정값에 새롭게 적용된 조합들을 적용 results.push(...attached); }); return results; }; 위 조합 함수를 1개부터 n개의 괄호쌍이 빠질 때까지 찾아주어야 하므로 아래와 같이 while문으로 경우의 수를 모두 구해줄 수 있습니다. const matchKeys = Object.keys(matchObj); let i = 1; while (i &lt;= matchKeys.length) { const combination = getCombination(matchKeys, i); i += 1; } // [ [ '0' ], [ '3' ] ], [ [ '0', '3' ] ] 마지막으로, 주어진 경우의 수 배열을 갖고 해당 위치의 괄호들을 없앤 문자열을 리턴하는 함수를 만들어 적용하도록 했습니다. const getRemovedByTargets = (targets) =&gt; { const newExpressionArr = [...expressionArr]; // 새롭게 만들어질 문자열을 나누어둔 배열 targets.forEach((target) =&gt; { // 문자열에서 지정된 부분들을 모두 제거 newExpressionArr[target] = undefined; newExpressionArr[matchObj[target]] = undefined; }); // 문자열을 생성하여 리턴 return newExpressionArr.join(""); }; const resultArray = new Set(); // ((1))과 같은 괄호가 존재하는 경우에 대한 처리가 필요해 Set으로 처리 const matchKeys = Object.keys(matchObj); let i = 1; while (i &lt;= matchKeys.length) { const combination = getCombination(matchKeys, i); // 생성된 combination에서 각 경우의 수들을 적용한 문자열을 결과값에 넣어줌 combination.forEach((value) =&gt; { const removed = getRemovedByTargets(value); resultArray.add(removed); }); i += 1; } // 결과 리턴 const result = [...resultArray].sort().join("\n"); console.log(result); 이번 문제를 풀며, 가장 어려움을 느낀 곳은 조합 함수를 만드는 것이었습니다. 조합이 코드로 이루어지는 과정에서 재귀 함수를 사용하고 이 때, 재귀 함수가 종료되는 시점을 파악하는 것이 어려웠습니다. 항상 조합과 함께 따라오는 순열을 적용하는 함수를 만드는 것에 대한 공부도 필요합니다. 추가적으로, 예외 처리를 할 때 문제가 발생했었는데, 괄호가 중복으로 발생할 때에 대한 처리가 처음에는 제대로 이루어지지 않아 틀렸다는 결과가 나왔습니다. 그래서 위와 같이 const resultArray = new Set();를 사용하여 문제를 해결할 수 있었고, 예외 처리에 대한 고려가 더 필요하다는 걸 알 수 있었습니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">socket 연결 해제 시 재연결 시도</title><link href="http://localhost:4000/javascript/2022/11/22/socket-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EC%8B%9C-%EC%9E%AC%EC%97%B0%EA%B2%B0-%EC%8B%9C%EB%8F%84/" rel="alternate" type="text/html" title="socket 연결 해제 시 재연결 시도" /><published>2022-11-22T00:00:00+09:00</published><updated>2022-11-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/11/22/socket%20%EC%97%B0%EA%B2%B0%20%ED%95%B4%EC%A0%9C%20%EC%8B%9C%20%EC%9E%AC%EC%97%B0%EA%B2%B0%20%EC%8B%9C%EB%8F%84</id><content type="html" xml:base="http://localhost:4000/javascript/2022/11/22/socket-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C-%EC%8B%9C-%EC%9E%AC%EC%97%B0%EA%B2%B0-%EC%8B%9C%EB%8F%84/"><![CDATA[<h3 id="socket-연결이-끊길-시-다시-연결하는-방법">socket 연결이 끊길 시 다시 연결하는 방법</h3>

<p>연결이 끊기는 경우, <strong>StompJS는 다시 연결하기 위해서 새롭게 SockJS와 StompJS를 설정해주어야 한다</strong>는 <a href="https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over">사실</a>을 알게 되었습니다. 이를 토대로 기존에 작성된 코드가 새로운 SockJS, StompJS를 만들 수 없어, 새롭게 만들 수 있는 형태로 변환하고 어느 컴포넌트에서든 이를 사용할 수 있게 수정했습니다.</p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/0.png" alt="" width="100%" height="" /> 
</figure>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존에 작성된 형태로, 한 번 만들어진 뒤, 이를 다시 사용하는 데에 어려움이 따름</span>
<span class="kd">const</span> <span class="nx">sockServer</span> <span class="o">=</span> <span class="nx">API</span><span class="p">.</span><span class="nx">WEBSOCKET</span><span class="p">;</span> <span class="c1">// 들어갈 주소 설정</span>
<span class="kd">const</span> <span class="nx">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJs</span><span class="p">(</span><span class="nx">sockServer</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 새롭게 작성된 형태로, getStompClient를 호출해 어디서든 다시 소켓 재연결을 시도할 수 있음</span>
<span class="kd">let</span> <span class="nx">stompClient</span><span class="p">:</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">Client</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStompClient</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">sockServer</span> <span class="o">=</span> <span class="nx">API</span><span class="p">.</span><span class="nx">WEBSOCKET</span><span class="p">;</span> <span class="c1">// 들어갈 주소 설정</span>
  <span class="kd">const</span> <span class="nx">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SockJs</span><span class="p">(</span><span class="nx">sockServer</span><span class="p">);</span>
  <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">StompJs</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="nx">sock</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">getStompClient</span><span class="p">();</span>
</code></pre></div></div>

<p>위와 같이, stomp에 연결을 요청할 수 있는 메소드를 만들고, 이를 에러가 발생해 끊기는 상황에서 다시 연결할 때 사용하도록 설정했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">maxRetryCount</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">retryCount</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nx">connectStomp</span><span class="p">({</span>
  <span class="na">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 에러가 발생했을 때</span>
    <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="c1">// 연결이 끊겼음을 알림</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">retryCount</span><span class="p">.</span><span class="nx">current</span> <span class="o">&lt;=</span> <span class="nx">maxRetryCount</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 재시도 횟수가 아직 남아있는 경우</span>
      <span class="nx">retryCount</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">// stomp client를 새로 만들고 socket에 연결함</span>
      <span class="nx">getStompClient</span><span class="p">();</span>
      <span class="nx">connectSocket</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">...</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위와 같은 형태의 코드를 작성함으로서 총 3번의 재시도를 하도록 하였고, 이후의 재시도는 없도록 설정을 해두었습니다. 하지만 이러한 식으로 진행할 경우, 노트북을 닫았다 다시 켜는 상황(네트워크와 브라우저가 자체적으로 멈추는 상황)에 대해서는 올바르게 재요청을 보내 다시 소켓은 연결하지만 <strong>와이파이를 끄는 경우는 이를 제대로 처리할 수가 없었습니다.</strong></p>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/1.gif" alt="" width="100%" height="" /> 
</figure>

<h3 id="재시도를-하는-조건-변경하기">재시도를 하는 조건 변경하기</h3>

<p>이러한 문제를 해결하기 위해서 첫번째로, 지속적으로 브라우저가 연결을 시도하도록 하고, 재시도를 하는 빈도는 ‘횟수’가 아니라 ‘시간’으로 설정해야한다고 판단했습니다. 이를 위해 연결이 끊긴 상황이 발생할 때 일정 시간 주기로 다시 연결을 시도하도록 기능을 추가하고자 했습니다.</p>

<p>처음에는 StompJS 내에 존재하는 <code class="language-plaintext highlighter-rouge">heartbeat</code>이라는 것을 사용하고자 했습니다. 하지만, <code class="language-plaintext highlighter-rouge">heartbeat</code>으로는 와이파이와 같은 인터넷 연결이 끊긴 상황을 인식할 수 없다는 것을 알게 됐고, <code class="language-plaintext highlighter-rouge">setTimeout</code>을 통해 직접적인 확인이 필요하다고 판단했습니다.</p>

<p>에러로 인해 연결이 끊어지는 경우, setTImeout을 통해 정해진 시간 이후 다시 연결을 시도하도록 코드를 구성했습니다. 이를 통해 에러로 인해 소켓 연결이 끊기는 경우 주기적으로 연결을 재시도하도록 할 수 있었습니다. 그리고 연결이 완료될 경우(<code class="language-plaintext highlighter-rouge">onSuccess</code>), 연결이 되지 않았던 시간(<code class="language-plaintext highlighter-rouge">disconnectTimeRef</code>)을 초기화시켜 다음 연결 해제 시 다시 처음부터 계산을 할 수 있도록 했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">socketConnectRetryInterval</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span> <span class="c1">// ms</span>
<span class="kd">const</span> <span class="nx">socketConnectRetryIntervalMax</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 10mins</span>
<span class="kd">const</span> <span class="nx">disconnectTimeRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nl">onError</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">disconnectTime</span> <span class="o">=</span> <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">disconnectTime</span> <span class="o">&gt;</span> <span class="nx">socketConnectRetryIntervalMax</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="nx">socketConnectRetryInterval</span><span class="p">;</span>

  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">getStompClient</span><span class="p">();</span>
    <span class="nx">connectSocket</span><span class="p">();</span>
  <span class="p">},</span> <span class="nx">socketConnectRetryInterval</span><span class="p">);</span>
<span class="c1">// 에러가 있는 경우 정해진 시간이 지날 때마다 요청을 보내 확인하도록 함</span>
<span class="p">},</span>
<span class="nx">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">},</span>
</code></pre></div></div>

<p>그리고 이제 인터넷 연결이 끊긴 것을 인지해야 할 필요가 있었는데, 이를 위해서는 브라우저의 내장 기능인 <code class="language-plaintext highlighter-rouge">eventlistener</code>의 <code class="language-plaintext highlighter-rouge">offline</code>을 활용했습니다. offline이 된 상황이 발생할 경우, 에러가 발생한 것과 동일하게 처리를 해주면 되었기에 위의 코드를 따로 빼내어 offline 상황에도 적용이 될 수 있도록 해주었습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 소켓 연결을 재시도하는 함수로 따로 빼냄</span>
<span class="kd">const</span> <span class="nx">retrySocketConnect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">disconnectTime</span> <span class="o">=</span> <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">disconnectTime</span> <span class="o">&gt;</span> <span class="nx">socketConnectRetryIntervalMax</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">+=</span> <span class="nx">socketConnectRetryInterval</span><span class="p">;</span>
  <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">getStompClient</span><span class="p">();</span>
    <span class="nx">connectSocket</span><span class="p">();</span>
  <span class="p">},</span> <span class="nx">socketConnectRetryInterval</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">connectSocket</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">connectStomp</span><span class="p">({</span>
    <span class="na">onError</span><span class="p">:</span> <span class="nx">retrySocketConnect</span><span class="p">,</span>
    <span class="na">onConnect</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">disconnectTimeRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">setSocketConnect</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">noticeParams</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">entryIds</span><span class="p">,</span>
      <span class="nx">keywordIds</span><span class="p">,</span>
      <span class="na">onSubscribeEntries</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
      <span class="na">onSubscribeKeywords</span><span class="p">:</span> <span class="nx">onSubscribeNotice</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="na">chatParams</span><span class="p">:</span> <span class="p">{</span> <span class="nx">chatroomIds</span><span class="p">,</span> <span class="nx">onReceiveChat</span> <span class="p">},</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="nx">connectSocket</span><span class="p">();</span>
<span class="c1">// 연결이 끊어질 시, 연결 재시도</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">offline</span><span class="dl">"</span><span class="p">,</span> <span class="nx">retrySocketConnect</span><span class="p">);</span>
</code></pre></div></div>

<figure class="figure  figure--center">
  <img class="image" src="/image/221122/2.gif" alt="소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨" width="100%" height="" /> 
  <figcaption class="caption">소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨</figcaption>
  
</figure>

<hr />

<h3 id="참고-링크">참고 링크</h3>

<ul>
  <li><a href="https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over">StompJS 관련 안내문</a></li>
</ul>]]></content><author><name>JinJeon</name></author><category term="JAVASCRIPT" /><summary type="html"><![CDATA[socket 연결이 끊길 시 다시 연결하는 방법 연결이 끊기는 경우, StompJS는 다시 연결하기 위해서 새롭게 SockJS와 StompJS를 설정해주어야 한다는 사실을 알게 되었습니다. 이를 토대로 기존에 작성된 코드가 새로운 SockJS, StompJS를 만들 수 없어, 새롭게 만들 수 있는 형태로 변환하고 어느 컴포넌트에서든 이를 사용할 수 있게 수정했습니다. // 기존에 작성된 형태로, 한 번 만들어진 뒤, 이를 다시 사용하는 데에 어려움이 따름 const sockServer = API.WEBSOCKET; // 들어갈 주소 설정 const sock = new SockJs(sockServer); export const stompClient = StompJs.over(sock); // 새롭게 작성된 형태로, getStompClient를 호출해 어디서든 다시 소켓 재연결을 시도할 수 있음 let stompClient: StompJs.Client; export const getStompClient = () =&gt; { const sockServer = API.WEBSOCKET; // 들어갈 주소 설정 const sock = new SockJs(sockServer); stompClient = StompJs.over(sock); }; getStompClient(); 위와 같이, stomp에 연결을 요청할 수 있는 메소드를 만들고, 이를 에러가 발생해 끊기는 상황에서 다시 연결할 때 사용하도록 설정했습니다. const maxRetryCount = 3; const retryCount = useRef(0); connectStomp({ onError: () =&gt; { // 에러가 발생했을 때 setSocketConnect(false); // 연결이 끊겼음을 알림 if (retryCount.current &lt;= maxRetryCount) { // 재시도 횟수가 아직 남아있는 경우 retryCount.current += 1; // stomp client를 새로 만들고 socket에 연결함 getStompClient(); connectSocket(); } }, ... }); 위와 같은 형태의 코드를 작성함으로서 총 3번의 재시도를 하도록 하였고, 이후의 재시도는 없도록 설정을 해두었습니다. 하지만 이러한 식으로 진행할 경우, 노트북을 닫았다 다시 켜는 상황(네트워크와 브라우저가 자체적으로 멈추는 상황)에 대해서는 올바르게 재요청을 보내 다시 소켓은 연결하지만 와이파이를 끄는 경우는 이를 제대로 처리할 수가 없었습니다. 재시도를 하는 조건 변경하기 이러한 문제를 해결하기 위해서 첫번째로, 지속적으로 브라우저가 연결을 시도하도록 하고, 재시도를 하는 빈도는 ‘횟수’가 아니라 ‘시간’으로 설정해야한다고 판단했습니다. 이를 위해 연결이 끊긴 상황이 발생할 때 일정 시간 주기로 다시 연결을 시도하도록 기능을 추가하고자 했습니다. 처음에는 StompJS 내에 존재하는 heartbeat이라는 것을 사용하고자 했습니다. 하지만, heartbeat으로는 와이파이와 같은 인터넷 연결이 끊긴 상황을 인식할 수 없다는 것을 알게 됐고, setTimeout을 통해 직접적인 확인이 필요하다고 판단했습니다. 에러로 인해 연결이 끊어지는 경우, setTImeout을 통해 정해진 시간 이후 다시 연결을 시도하도록 코드를 구성했습니다. 이를 통해 에러로 인해 소켓 연결이 끊기는 경우 주기적으로 연결을 재시도하도록 할 수 있었습니다. 그리고 연결이 완료될 경우(onSuccess), 연결이 되지 않았던 시간(disconnectTimeRef)을 초기화시켜 다음 연결 해제 시 다시 처음부터 계산을 할 수 있도록 했습니다. const socketConnectRetryInterval = 5000; // ms const socketConnectRetryIntervalMax = 10 * 60 * 1000; // 10mins const disconnectTimeRef = useRef(0); onError: () =&gt; { const disconnectTime = disconnectTimeRef.current; if (disconnectTime &gt; socketConnectRetryIntervalMax) return; disconnectTimeRef.current += socketConnectRetryInterval; setSocketConnect(false); setTimeout(() =&gt; { getStompClient(); connectSocket(); }, socketConnectRetryInterval); // 에러가 있는 경우 정해진 시간이 지날 때마다 요청을 보내 확인하도록 함 }, onConnect: () =&gt; { disconnectTimeRef.current = 0; setSocketConnect(true); }, 그리고 이제 인터넷 연결이 끊긴 것을 인지해야 할 필요가 있었는데, 이를 위해서는 브라우저의 내장 기능인 eventlistener의 offline을 활용했습니다. offline이 된 상황이 발생할 경우, 에러가 발생한 것과 동일하게 처리를 해주면 되었기에 위의 코드를 따로 빼내어 offline 상황에도 적용이 될 수 있도록 해주었습니다. // 소켓 연결을 재시도하는 함수로 따로 빼냄 const retrySocketConnect = () =&gt; { const disconnectTime = disconnectTimeRef.current; if (disconnectTime &gt; socketConnectRetryIntervalMax) return; disconnectTimeRef.current += socketConnectRetryInterval; setSocketConnect(false); setTimeout(() =&gt; { getStompClient(); connectSocket(); }, socketConnectRetryInterval); }; const connectSocket = () =&gt; { connectStomp({ onError: retrySocketConnect, onConnect: () =&gt; { disconnectTimeRef.current = 0; setSocketConnect(true); }, noticeParams: { entryIds, keywordIds, onSubscribeEntries: onSubscribeNotice, onSubscribeKeywords: onSubscribeNotice, }, chatParams: { chatroomIds, onReceiveChat }, }); }; connectSocket(); // 연결이 끊어질 시, 연결 재시도 window.addEventListener("offline", retrySocketConnect); 소켓이 인터넷 연결 여부에 따라 다시 올바르게 연결됨 참고 링크 StompJS 관련 안내문]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/default-social-image.png" /><media:content medium="image" url="http://localhost:4000/assets/default-social-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>