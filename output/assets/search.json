

[
  
  
    
    
      {
        "title": "ELEMENTS",
        "feature_text": "마크다운 및 HTML 사용 예시\n",
        "excerpt": "MARKDOWN AND HTML\n",
        "content": "Heading 1\n\nHeading 2\n\nHeading 3\n\nHeading 4\n\nHeading 5\n\nHeading 6\n\nA small element\n\nA link\n\nLorem ipsum dolor sit amet, consectetur adip* isicing elit, sed do eiusmod *tempor incididunt ut labore et dolore magna aliqua.\n\nDuis aute irure dolor in A link reprehenderit in voluptate velit esse cillum bold text dolore eu fugiat nulla pariatur. Excepteur span element sint occaecat cupidatat non proident, sunt italicised text in culpa qui officia deserunt mollit anim id some code est laborum.\n\n\n  An item\n  An item\n  An item\n  An item\n  An item\n\n\n\n  Item one\n  Item two\n  Item three\n  Item four\n  Item five\n\n\n\n  A simple blockquote\n\n\nSome HTML…\n\n&lt;blockquote cite=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;\n  &lt;p&gt;You planning a vacation, Mr. Sullivan?&lt;/p&gt;\n  &lt;footer&gt;\n    &lt;a href=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"\n      &gt;Sunways Security Guard&lt;/a\n    &gt;\n  &lt;/footer&gt;\n&lt;/blockquote&gt;\n\n\n…CSS…\n\nblockquote {\n  text-align: center;\n  font-weight: bold;\n}\nblockquote footer {\n  font-size: 0.8rem;\n}\n\n\n…and JavaScript\n\nconst blockquote = document.querySelector(\"blockquote\");\nconst bolden = (keyString, string) =&gt;\n  string.replace(\n    new RegExp(keyString, \"g\"),\n    \"&lt;strong&gt;\" + keyString + \"&lt;/strong&gt;\"\n  );\n\nblockquote.innerHTML = bolden(\"Mr. Sullivan\", blockquote.innerHTML);\n\n\nSingle line of code\n\nHTML Includes\n\nContact form\n\n\n  \n    Contact\n    Name: *\n    \n\n    Email Address: *\n    \n\n    Message: *\n    \n\n    \n    \n    * indicates a required field\n\n    \n      \n      \n      \n    \n  \n\n\n\n\nPlease enable JavaScript to use the form.\n\n{% include site-form.html %}\n\n\nDemo map embed\n\n\n\n{% include map.html id=\"XXXXXX\" title=\"Coffee shop map\" %}\n\n\nButton include\n\nA button\n\nA button with icon  twitter\n\n\n{% include button.html text=\"A button\" link=\"https://david.darn.es\" %}\n{% include button.html text=\"A button with icon\"\nlink=\"https://twitter.com/daviddarnes\" icon=\"twitter\" %}\n\n\nIcon include\n\ntwitter\ntwitter\n\n\n{% include icon.html id=\"twitter\" title=\"twitter\" %} [{% include\nicon.html id=\"linkedin\" title=\"twitter\"\n%}](https://www.linkedin.com/in/daviddarnes)\n\n\nVideo include\n\n\n  \n\n\n{% include video.html id=\"zrkcGL5H3MU\" title=\"Siteleaf tutorial video\"\n%}\n\n\nImage includes\n\n\n   \n  Image with caption\n  \n\n\n\n   \n  Right aligned image\n  \n\n\n\n   \n  Left aligned image\n  \n\n\n\n   \n\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\"\ncaption=\"Image with caption\" width=\"300\" height=\"800\" %} {% include figure.html\nimage=\"https://picsum.photos/600/800?image=894\" caption=\"Right aligned image\"\nposition=\"right\" width=\"300\" height=\"800\" %} {% include figure.html\nimage=\"https://picsum.photos/600/800?image=894\" caption=\"Left aligned image\"\nposition=\"left\" width=\"300\" height=\"800\" %} {% include figure.html\nimage=\"https://picsum.photos/1600/800?image=894\" alt=\"Image with just alt text\"\n%}\n\n",
        "url": "/guide/2021/12/01/elements/"
      },
    
      {
        "title": "ALEMBIC",
        "feature_text": "가져온 블로그 테마에 대한 소개\n",
        "excerpt": "Alembic is a starting point for Jekyll projects. Rather than starting from scratch, this boilerplate is designed to get the ball rolling immediately. Install it, configure it, tweak it, push it.\n",
        "content": "Alembic is a starting point for Jekyll projects. Rather than starting from scratch, this boilerplate is designed to get rolling immediately. Install it, configure it, tweak it, push it.\n\nFork it  github\n\n Buy me a coffee ☕️\n Tweet it  twitter\n\n Install Alembic ⚗️\n\nFeatures\n\n\n  Clear and elegant design that can be used out of the box or as solid starting point\n  Tested in all major browsers, including IE and Edge\n  Built in Service Worker so it can work offline and on slow connections\n  Configurable colours and typography in a single settings file\n  Extensive set of shortcodes to include various elements; such as buttons, icons, figure images and more\n  Solid typographic framework from Sassline\n  Configurable navigation via a single file\n  Modular Jekyll components\n  Post category support in the form of a single post index page grouped by category\n  Built in live search using JavaScript\n  Contact form built in using Formspree\n  Designed with Siteleaf in mind\n  Has 9 of the most popular networks as performant sharing buttons\n  Has documentation\n\n\nExamples\n\nHere are a few examples of Alembic out in the wild being used in a variety of ways:\n\n\n  bawejakunal.github.io\n  case2111.github.io\n  karateca.org\n\n\nInstallation\n\nQuick setup\n\nTo give you a running start I’ve put together some starter kits that you can download, fork or even deploy immediately:\n\n\n  ⚗️🍨 Vanilla Jekyll starter kit\n\n  ⚗️🌲 Forestry starter kit\n\n\n  \n    ⚗️💠 Netlify CMS starter kit\n\n  \n  \n    ⚗️:octocat: GitHub Pages with remote theme kit\nDownload kit\n  \n  ⚗️🚀 Stackbit starter kit\n\n\n\nAs a Jekyll theme\n\n\n  Add gem \"alembic-jekyll-theme\" to your Gemfile to add the theme as a dependancy\n  Run the command bundle install in the root of project to install the theme and its dependancies\n  Add theme: alembic-jekyll-theme to your _config.yml file to set the site theme\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nAs a GitHub Pages remote theme\n\n\n  Add gem \"jekyll-remote-theme\" to your Gemfile to add the theme as a dependancy\n  Run the command bundle install in the root of project to install the jekyll remote theme gem as a dependancy\n  Add jekyll-remote-theme to the list of plugins in your _config.yml file\n  Add remote_theme: daviddarnes/alembic@main to your _config.yml file to set the site theme\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nAs a Boilerplate / Fork\n\n(deprecated, not recommended)\n\n\n  Fork the repo\n  Replace the Gemfile with one stating all the gems used in your project\n  Delete the following unnecessary files/folders: .github, LICENSE, screenshot.png, CNAME and alembic-jekyll-theme.gemspec\n  Run the command bundle install in the root of project to install the jekyll remote theme gem as a dependancy\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nCustomising\n\nWhen using Alembic as a theme means you can take advantage of the file overriding method. This allows you to overwrite any file in this theme with your own custom file, by matching the file name and path. The most common example of this would be if you want to add your own styles or change the core style settings.\n\nTo add your own styles copy the styles.scss into your own project with the same file path (assets/styles.scss). From there you can add your own styles, you can even optionally ignore the theme styles by removing the @import \"alembic\"; line.\n\nIf you’re looking to set your own colours and fonts you can overwrite them by matching the variable names from the _settings.scss file in your own styles.scss, make sure to state them before the @import \"alembic\"; line so they take effect. The settings are a mixture of custom variables and settings from Sassline - follow the link to find out how to configure the typographic settings.\n",
        "url": "/guide/2021/12/01/guide/"
      },
    
      {
        "title": "동기 ∙ 비동기",
        "feature_text": "동기와 비동기에 대한 간단한 소개\n",
        "excerpt": "1. 동기(synchronous)\n\n자바스크립트는 한 번에 하나의 작업만 수행한다.\n‘동기’라는 상황은 쉽게 말해, 한 작업이 실행되는 동안 다른 작업은 실행되지 않고 기다리는 것이다.\n이러한 자바스크립트의 특성은 그 엔진의 주요 구성 요소로 인해 나타나며, 그 종류로는 Memory Heap, Call Stack이 있다.\n\n\n  Memory Heap : 변수, 객체의 메모리 할당을 담당한다.\n  Call Stack : 호출된 함수가 쌓이는 곳을 의미한다. stack이라는 단어에서 알 수 있듯, LIFO(Last in First Out)의 구조로 이루어져 있다.\n\n\n1-1. CALL STACK\n\n함수 내의 다른 함수를 실행하는 경우, 이를 debugger를 통해 보면 아래와 같이 callstack이 쌓여있는 것을 볼 수 있다.\n이는 함수의 실행 순서를 stack의 형태로 표현한 것인데, foo내에 있는 함수 bar가 먼저 실행을 다 마쳐야 foo가 다시 진행되는 것을 알 수 있다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nfunction foo() {\n  baseData.forEach((v, i) =&gt; {\n    console.log(\"sync \", i);\n    bar();\n  });\n}\n\nfunction bar() {\n  baseData.forEach((v, i) =&gt; {\n    debugger;\n    console.log(\"sync 2\", i);\n  });\n}\n\nfoo();\n\n\n\n\n2. 비동기(asynchronous)\n\n자바스크립트의 단일 스레드, 동기식 동작과 달리, 어떠한 요청을 보내면 그 요청이 끝나기 전에 바로 다음 동작이 진행되는 것을 말한다.\n동기식으로만 진행되는 경우, 하나의 작업에 많은 시간이 걸리게 되면, 다음 동작들이 모두 영향을 받게 되어 전체적인 속도가 느려지게 되고, 이는 매우 비효율적인 것으로 볼 수 있다.\n이러한 작업의 비효율성을 줄이기 위해 나타난 방식이 비동기 방식이다.\n\n2-1. 여러 이벤트의 동시 동작 원리\n\n자바스크립트의 기본 동작 원리로는 안되는 비동기는 자바스크립트의 실행 환경(runtime)을 통해 이루어낼 수 있다.\n브라우저가 바로 그 환경인데, 여기서는 DOM, AJAX와 같은 비동기를 위한 web API가 들어가있어 비동기 작업을 해낼 수 있다.\n더불어, 이것들의 제어를 위한 Event Loop, Callback Queue가 존재한다.\n\n2-2. 비동기의 동작 순서\n\nconsole.log(\"FIRST\");\nsetTimeout(() =&gt; console.log(\"THIRD\"), 5000);\nconsole.log(\"SECOND\");\n\n/*\nTHIS IS FIRST\nTHIS IS SECOND\nTHIRD\n*/\n\n\n우선 위 코드들을 실행함으로서, ‘first → setTimeout() → second’ 의 순서로 내용들이 진행된다.\n위 코드에서 setTimeout은 web API(브라우저의 제공 API)로, 자바스크립트의 런타임 환경에서 별도의 API로 존재한다.\nAPI가 실행되게 되면, stack에서 우선 실행되는데, 이는 호출을 시킨다는 의미로 호출 후 stack에서는 사라지게 된다.\n그리고 이 API는 작성된 코드의 중간에 갑자기 끼어들어서는 안 된다.\n실행이 완료된 모든 WEB API는 task queue에 들어가서 대기하게 된다.\nevent loop가 call stack과 task queue를 지속적으로 주시하는데, stack이 비어있게 되면, 첫 번째 실행될 API부터 순차적으로 가져와 실행하게 된다.\n\n\n  동기 ∙ 비동기 상황에 대한 다른 예시\n\n\nfunction plus() {\n  let a = 1;\n  setTimeout(() =&gt; console.log(++a), 1000);\n  return a;\n}\n\nconst result = plus();\nconsole.log(\"result :\", result);\n/*\nresult : 1\n2\n*/\n\n\n위 예시에서, console.log가 마무리 된 후에 API가 진행된 것을 볼 수 있다.\n이를 통해, API는 모든 stack내의 내용들이 정리된 후에 event loop를 통해서 진행됨을 알 수 있다.\n\n\n\n3. 비동기의 예시\n\n3-1. for, setTimeout()\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  for (var i = 0; i &lt; arr.length; i++) {\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n};\n\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 7 7 7 7 7 7 7\n\n\n위 코드를 보면, 원래의 의도(0 1 2 3 4 5 6)와 달리 7이 계속 출력된 것을 볼 수 있다.\n이는 var가 가진 특징 때문인데, var는 함수레벨 스코프를 가지며, 전역변수의 값이 변경될 수 있게 된다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\nvar i = 2;\nconst asyncRun = (arr, fn) =&gt; {\n  for (var i = 0; i &lt; arr.length; i++) {\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n  console.log(i); // 7\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 7 7 7 7 7 7 7 7\n\n\n위 코드를 보면, var i = 2;로 값을 지정해준 상태에서, asyncRun 함수 안에서 console.log가 이루어지기 때문에, 값이 2로 나와야 한다.\n그러나, for문 내의 var i = 0을 통해서 값이 재지정되었기 때문에 7이라는 값이 나오게 된다.\nsetTimeout()역시 이미 1초보다 훨씬 이전에 처리된 i의 값으로 처리가 진행되기 때문에 7만 나오게 된다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\nvar i = 2;\nconst asyncRun = (arr, fn) =&gt; {\n  for (let i = 0; i &lt; arr.length; i++) {\n    // var를 let으로 변경\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n  console.log(i); // 2\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 2 0 1 2 3 4 5 6\n\n\n이와 달리, let은 블록레벨 스코프를 가져, 함수, if문, while문 등 중괄호로 된 곳내에서만 작동한다.\n실행 시 1차적으로 for문 밖 i의 값이 2로 제대로 출력되는 것을 볼 수 있고, 내부에서도 원래 의도대로 출력되는 것을 볼 수 있다.\n\n3-2. forEach\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  arr.forEach((v, i) =&gt; {\n    setTimeout(() =&gt; fn(i), 1000);\n  });\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 0 1 2 3 4 5 6\n\n\nforEach로 실행할 시에는 따로 영향받는 요소 없이 지정한 시간 뒤에 모두 제대로 실행되는 것을 볼 수 있다.\n\n3-3. 비동기 + 비동기\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  arr.forEach((v, i) =&gt; {\n    setTimeout(() =&gt; {\n      setTimeout(() =&gt; {\n        console.log(\"cb 2\");\n        fn(i);\n      }, 1000);\n      console.log(\"cb 1\");\n    }, 1000);\n  });\n};\n\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n\n/*\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 2\n0\ncb 2\n1\ncb 2\n2\ncb 2\n3\ncb 2\n4\ncb 2\n5\ncb 2\n6\n*/\n\n\n비동기 내에 또다른 비동기적인 함수를 넣게 되는 경우에는 우선적으로 들어온 함수를 처리하고, 그 다음 들어온 함수의 순서대로 처리되는 것을 볼 수 있다.\n이를 통해, TASK QUEUE에서 QUEUE의 의미를 다시 알 수 있다.\n",
        "content": "1. 동기(synchronous)\n\n자바스크립트는 한 번에 하나의 작업만 수행한다.\n‘동기’라는 상황은 쉽게 말해, 한 작업이 실행되는 동안 다른 작업은 실행되지 않고 기다리는 것이다.\n이러한 자바스크립트의 특성은 그 엔진의 주요 구성 요소로 인해 나타나며, 그 종류로는 Memory Heap, Call Stack이 있다.\n\n\n  Memory Heap : 변수, 객체의 메모리 할당을 담당한다.\n  Call Stack : 호출된 함수가 쌓이는 곳을 의미한다. stack이라는 단어에서 알 수 있듯, LIFO(Last in First Out)의 구조로 이루어져 있다.\n\n\n1-1. CALL STACK\n\n함수 내의 다른 함수를 실행하는 경우, 이를 debugger를 통해 보면 아래와 같이 callstack이 쌓여있는 것을 볼 수 있다.\n이는 함수의 실행 순서를 stack의 형태로 표현한 것인데, foo내에 있는 함수 bar가 먼저 실행을 다 마쳐야 foo가 다시 진행되는 것을 알 수 있다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nfunction foo() {\n  baseData.forEach((v, i) =&gt; {\n    console.log(\"sync \", i);\n    bar();\n  });\n}\n\nfunction bar() {\n  baseData.forEach((v, i) =&gt; {\n    debugger;\n    console.log(\"sync 2\", i);\n  });\n}\n\nfoo();\n\n\n\n\n2. 비동기(asynchronous)\n\n자바스크립트의 단일 스레드, 동기식 동작과 달리, 어떠한 요청을 보내면 그 요청이 끝나기 전에 바로 다음 동작이 진행되는 것을 말한다.\n동기식으로만 진행되는 경우, 하나의 작업에 많은 시간이 걸리게 되면, 다음 동작들이 모두 영향을 받게 되어 전체적인 속도가 느려지게 되고, 이는 매우 비효율적인 것으로 볼 수 있다.\n이러한 작업의 비효율성을 줄이기 위해 나타난 방식이 비동기 방식이다.\n\n2-1. 여러 이벤트의 동시 동작 원리\n\n자바스크립트의 기본 동작 원리로는 안되는 비동기는 자바스크립트의 실행 환경(runtime)을 통해 이루어낼 수 있다.\n브라우저가 바로 그 환경인데, 여기서는 DOM, AJAX와 같은 비동기를 위한 web API가 들어가있어 비동기 작업을 해낼 수 있다.\n더불어, 이것들의 제어를 위한 Event Loop, Callback Queue가 존재한다.\n\n2-2. 비동기의 동작 순서\n\nconsole.log(\"FIRST\");\nsetTimeout(() =&gt; console.log(\"THIRD\"), 5000);\nconsole.log(\"SECOND\");\n\n/*\nTHIS IS FIRST\nTHIS IS SECOND\nTHIRD\n*/\n\n\n우선 위 코드들을 실행함으로서, ‘first → setTimeout() → second’ 의 순서로 내용들이 진행된다.\n위 코드에서 setTimeout은 web API(브라우저의 제공 API)로, 자바스크립트의 런타임 환경에서 별도의 API로 존재한다.\nAPI가 실행되게 되면, stack에서 우선 실행되는데, 이는 호출을 시킨다는 의미로 호출 후 stack에서는 사라지게 된다.\n그리고 이 API는 작성된 코드의 중간에 갑자기 끼어들어서는 안 된다.\n실행이 완료된 모든 WEB API는 task queue에 들어가서 대기하게 된다.\nevent loop가 call stack과 task queue를 지속적으로 주시하는데, stack이 비어있게 되면, 첫 번째 실행될 API부터 순차적으로 가져와 실행하게 된다.\n\n\n  동기 ∙ 비동기 상황에 대한 다른 예시\n\n\nfunction plus() {\n  let a = 1;\n  setTimeout(() =&gt; console.log(++a), 1000);\n  return a;\n}\n\nconst result = plus();\nconsole.log(\"result :\", result);\n/*\nresult : 1\n2\n*/\n\n\n위 예시에서, console.log가 마무리 된 후에 API가 진행된 것을 볼 수 있다.\n이를 통해, API는 모든 stack내의 내용들이 정리된 후에 event loop를 통해서 진행됨을 알 수 있다.\n\n\n\n3. 비동기의 예시\n\n3-1. for, setTimeout()\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  for (var i = 0; i &lt; arr.length; i++) {\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n};\n\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 7 7 7 7 7 7 7\n\n\n위 코드를 보면, 원래의 의도(0 1 2 3 4 5 6)와 달리 7이 계속 출력된 것을 볼 수 있다.\n이는 var가 가진 특징 때문인데, var는 함수레벨 스코프를 가지며, 전역변수의 값이 변경될 수 있게 된다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\nvar i = 2;\nconst asyncRun = (arr, fn) =&gt; {\n  for (var i = 0; i &lt; arr.length; i++) {\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n  console.log(i); // 7\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 7 7 7 7 7 7 7 7\n\n\n위 코드를 보면, var i = 2;로 값을 지정해준 상태에서, asyncRun 함수 안에서 console.log가 이루어지기 때문에, 값이 2로 나와야 한다.\n그러나, for문 내의 var i = 0을 통해서 값이 재지정되었기 때문에 7이라는 값이 나오게 된다.\nsetTimeout()역시 이미 1초보다 훨씬 이전에 처리된 i의 값으로 처리가 진행되기 때문에 7만 나오게 된다.\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\nvar i = 2;\nconst asyncRun = (arr, fn) =&gt; {\n  for (let i = 0; i &lt; arr.length; i++) {\n    // var를 let으로 변경\n    setTimeout(() =&gt; fn(i), 1000);\n  }\n  console.log(i); // 2\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 2 0 1 2 3 4 5 6\n\n\n이와 달리, let은 블록레벨 스코프를 가져, 함수, if문, while문 등 중괄호로 된 곳내에서만 작동한다.\n실행 시 1차적으로 for문 밖 i의 값이 2로 제대로 출력되는 것을 볼 수 있고, 내부에서도 원래 의도대로 출력되는 것을 볼 수 있다.\n\n3-2. forEach\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  arr.forEach((v, i) =&gt; {\n    setTimeout(() =&gt; fn(i), 1000);\n  });\n};\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n// 0 1 2 3 4 5 6\n\n\nforEach로 실행할 시에는 따로 영향받는 요소 없이 지정한 시간 뒤에 모두 제대로 실행되는 것을 볼 수 있다.\n\n3-3. 비동기 + 비동기\n\nconst baseData = [1, 2, 3, 4, 5, 6, 100];\n\nconst asyncRun = (arr, fn) =&gt; {\n  arr.forEach((v, i) =&gt; {\n    setTimeout(() =&gt; {\n      setTimeout(() =&gt; {\n        console.log(\"cb 2\");\n        fn(i);\n      }, 1000);\n      console.log(\"cb 1\");\n    }, 1000);\n  });\n};\n\nasyncRun(baseData, (idx) =&gt; console.log(idx));\n\n/*\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 1\ncb 2\n0\ncb 2\n1\ncb 2\n2\ncb 2\n3\ncb 2\n4\ncb 2\n5\ncb 2\n6\n*/\n\n\n비동기 내에 또다른 비동기적인 함수를 넣게 되는 경우에는 우선적으로 들어온 함수를 처리하고, 그 다음 들어온 함수의 순서대로 처리되는 것을 볼 수 있다.\n이를 통해, TASK QUEUE에서 QUEUE의 의미를 다시 알 수 있다.\n",
        "url": "/dev/2021/12/01/%EB%8F%99%EA%B8%B0_%EB%B9%84%EB%8F%99%EA%B8%B0/"
      },
    
      {
        "title": "해시 ∙ 해시맵",
        "feature_text": "해시, 해시맵이란?\n",
        "excerpt": "1. 해시(Hash)\n\n1-1. 직접 주소 테이블(Direct Address Table)\n\n해시 테이블은 ‘직접 주소 테이블’이라는 자료구조에서 시작된다.\nkey와 value를 가지며 하나의 key에 하나의 value가 매칭된다.\nArray에서는 key값에 숫자만 가능함(index). 그러나 Hash Table은 key값에 문자열도 가능하다.\n찾고자 하는 value와 테이블의 index가 일치하므로, 저장된 데이터를 바로 꺼내올 수 있다.\n시간복잡도 O(1)으로 표현된다.\n이진트리검색, linked list와 같은 구조를 쓰게 될 시 특정값의 삭제가 다른 값의 탐색에 영향을 미칠 수가 있는데, map은 그러한 것에서 자유롭다.\n그러나, 단점으로 꼽히는 것이 ‘공간의 효율성’이다.\n\n[ &lt;3 empty items&gt;, 3, &lt;6 empty items&gt;, 10, &lt;79 empty items&gt;, 90 ]\n\n\n‘적재율‘로 이러한 공간의 활용도를 표현할 수도 있는데, 위와 같은 경우는 총 95개의 공간 중 3개가 사용되어 3.15%의 적재율이라 볼 수 있다.\n\n1-2. 해시 테이블과 해시 함수\n\n\n  해시 함수 : 임의의 길이를 가지는 데이터를 고정된 길이의 데이터로 매핑해주는 함수\n\n\n직접 주소 테이블의 단점을 보완하기 위해 사용할 수 있는 방법이 해시 테이블을 사용하는 것이다.\n해시 테이블의 사용을 위해서 ‘해시 함수’를 만들어주게 된다.\n\n\n  해시 함수의 특징\n해시 함수를 거쳐 나온 값을 통해 value를 추측할 수 없다.\nvalue를 바로 적용하지 않기 때문에, 예를 들면 ‘100’이라는 숫자에 대해서 100개의 공간을 만든 뒤 값을 배치할 필요가 없어지게 된다.\n    function hashFunction(key) {\n  return key % 10;\n}\n    \n    위 함수에서 가장 중요한 것은 ‘10’이라는 크기 내로 한정되어진다는 것이다.\nHash Table의 key와 연결된 value를 삽입, 삭제, 탐색하는 알고리즘 함수이다.(대표적으로 MDS)\nkey가 들어오면 랜덤한 주소값을 생성한 뒤, 그 주소값으로 설정된 테이블에 key, value를 저장한다.\n해시함수 과정에서 해시충돌(Collision)이 발생할 수 있다.\n  \n\n\n\n\n2. 해시 충돌(Collision)\n\n\n  해시 충돌 : 서로 다른 value를 입력했을 때, 테이블 내 같은 index로 값이 들어가(같은 값이 나오게 되어) 겹치는 상황\n\n\n해시 테이블은 데이터의 개수보다 테이블의 크기를 줄이고자 하는 생각에서 나왔기 때문에, 이에 대한 해결책이 존재한다.\n근본적으로, 해시 함수를 짤 때 가능한 겹치는 값이 나오지 않도록 하는 것이 중요하지만, 결국 겹치는 구간이 존재할 수 밖에 없다.\n\n2-1. 개방 주소법(open address)\n\n충돌이 발생할 시, 테이블 내 새로운 주소를 탐사한 후, 비어있는 곳에 데이터를 입력하는 방식.\n해시 함수의 결과값 외에 다른 인덱스를 허용한다는 의미로 ‘개방 주소’라고 표현한다.\n\nA. 선형 탐사법(Linear Probing)\n\n선형으로 순차적으로 탐사하는 방법.\n충돌이 일어났을 경우, 충돌이 발생한 곳의 바로 옆자리로 배치가 이루어진다.\n\nconst hashingIndex = function (number) {\n  const result = number % 3;\n  return result;\n};\nclass hashTable {\n  constructor() {\n    this.table = [];\n  }\n\n  setValue(value = -1) {\n    const index = hashingIndex(value);\n    if (this.table[index]) {\n      this.table[index + 1] = value;\n    } else {\n      this.table[index] = value;\n    }\n  }\n  getTable() {\n    return this.table;\n  }\n}\n\nconst myTable = new hashTable();\nmyTable.setValue(4);\nmyTable.setValue(7);\n\nconsole.log(myTable.getTable());\n// [ &lt;1 empty item&gt;, 4, 7 ]\n\n\n위 코드에서 입력된 4, 7은 모두 3으로 나눌 때의 나머지 값이 1이므로, index 1에 값이 들어가야 한다.\n → 4가 이미 배치되어 있어 7은 그 옆 칸으로 이동하여 배치된다.\n문제점 : 값의 주변이 모두 채워지는 일차 군집화(Primay Clustering)가 발생하기 쉽다.\n → 이로 인해, 옆 칸에 저장되는 데이터가 늘어나고, 그 근처에 새로 저장되려는 값들도 끊임없이 옆으로 새로 이동해 저장되는 문제가 발생한다.\n\nB. 제곱 탐사법(Quadratic Probing)\n\n선형 탐사법과 유사한 방식이지만, 탐사의 폭이 제곱으로 늘어난다.\n충돌의 발생 수의 제곱만큼 이동하게 되므로 ‘한 번 충돌 시 1, 두 번 충돌 시 4’ 이런식으로 늘어나게 된다.\n\n\n\n3. JavaScript의 해시테이블(Hash Table) : Map\n\nJavaScript에서의 key-value 자료구조는 Object가 대표적이었는데, Map, Set이 추가되어 현재 JavaScript의 해시테이블은 “Object, Map, Set”가 있다.\n\n3-1. Map\n\nkey-value로 이루어진 해시 테이블로, Object와 주로 비교된다.\n탐색은 get(), 삽입은 set()으로 한다.\nkey 값은 고유한 값으로, 하나만 존재할 수 있으며, number, string, function, object, NaN이 자료형으로 사용된다.\nset()을 이용해 value를 설정한다.\n\nlet map = new Map();\n\nlet testNumber = 1;\nlet testString = \"string\";\nlet testObject = { A: \"a\" };\nlet testFucntion = (B) =&gt; {\n  B = \"b\";\n};\n\nmap.set(testNumber, 1);\nmap.set(testString, 2);\nmap.set(testObject, 3);\nmap.set(testFucntion, 4);\n\nconsole.log(map);\n/*\nMap(4) {\n  1 =&gt; 1,\n  'string' =&gt; 2,\n  { A: 'a' } =&gt; 3,\n  [Function (anonymous)] =&gt; 4\n}\n*/\n// map의 형태\n\n\n\n  get()을 통한 value 가져오기\n\n\nmap.get(testNumber); // 1\nmap.get(testString); // 2\nmap.get(testObject); // 3\nmap.get(testFucntion); // 4\n\n\n\n  has()를 통한 value 찾기\n\n\nmap.has(testFucntion); // true\nmap.has(testNumber); // true\n\n\n\n  delete()를 통한 value 삭제\n\n\nmap.delete(testFucntion); // true\nmap.get(testFucntion); // undefined\nmap.get(\"none\"); // undefined\n\n\n\n  size를 통한 value의 유무 확인\n\n\nmap.size; // 3\nmap.length; // undefined\n\n\n\n  for-of를 통한 hash 탐색\n\n\nfor (let [key, value] of map) {\n  console.log(key, \"=\", value);\n}\n// 1 = 1\n// string = 2\n// { A: 'a' } = 3\n// [Function: testFucntion] = 4\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// 1\n// string\n// { A: 'a' }\n// [Function: testFucntion]\nfor (let value of map.values()) {\n  console.log(value);\n}\n// 1\n// 2\n// 3\n// 4\nconsole.log(map.values());\n// [Map Iterator] { 1, 2, 3, 4 }\nconsole.log(map.keys());\n// [Map Iterator] { 1, 'string', { A: 'a' }, [Function: testFucntion] }\n\n\n\n\n4. 충돌(Collision)\n\n받아온 key값에 대해 hash function으로 index를 지정하고 넣어주게 되는데, 이미 해당 index에 값이 존재하는 경우가 발생할 수 있으며 이를 collision이라고 한다.\n해결을 위해서 대표적인 두 가지 방법이 존재한다.\n\n\n  Open Addressing\n겹치는 해당 index의 옆 자리에 넣게 되는 방법이다.\n이후에 해당 자리를 찾기 위해서 hash 값 index 이후부터 찾는 key값이 나올 때까지 찾는다.\n  Separate Chainining\nLinked List를 이용해 다음 링크에 끼워넣는 방법이다.\n이후 찾을 때에는 해당 링크를 타고 들어가면 된다.\n\n\n\n\n참고 링크\n\n\n  JavaScript Map, Hashmap\n전체적인 설명 : https://velog.io/@jun094/Hash와-Map\n설명 동영상 : https://www.youtube.com/watch?v=HraOg7W3VAM\n  Hashmap 충돌 해결법\nhttps://overcome-the-limits.tistory.com/entry/자료구조-해시테이블-with-JavaScript\n\n\nLinux\n\n\n\nLinux의 특징\n\n유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 ‘오픈 소스’를 꼽을 수 있다.\n커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다.\n즉, 이 커널로 자신의 운영 체제를 개발할 수 있다.\nLinux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다.\n",
        "content": "1. 해시(Hash)\n\n1-1. 직접 주소 테이블(Direct Address Table)\n\n해시 테이블은 ‘직접 주소 테이블’이라는 자료구조에서 시작된다.\nkey와 value를 가지며 하나의 key에 하나의 value가 매칭된다.\nArray에서는 key값에 숫자만 가능함(index). 그러나 Hash Table은 key값에 문자열도 가능하다.\n찾고자 하는 value와 테이블의 index가 일치하므로, 저장된 데이터를 바로 꺼내올 수 있다.\n시간복잡도 O(1)으로 표현된다.\n이진트리검색, linked list와 같은 구조를 쓰게 될 시 특정값의 삭제가 다른 값의 탐색에 영향을 미칠 수가 있는데, map은 그러한 것에서 자유롭다.\n그러나, 단점으로 꼽히는 것이 ‘공간의 효율성’이다.\n\n[ &lt;3 empty items&gt;, 3, &lt;6 empty items&gt;, 10, &lt;79 empty items&gt;, 90 ]\n\n\n‘적재율‘로 이러한 공간의 활용도를 표현할 수도 있는데, 위와 같은 경우는 총 95개의 공간 중 3개가 사용되어 3.15%의 적재율이라 볼 수 있다.\n\n1-2. 해시 테이블과 해시 함수\n\n\n  해시 함수 : 임의의 길이를 가지는 데이터를 고정된 길이의 데이터로 매핑해주는 함수\n\n\n직접 주소 테이블의 단점을 보완하기 위해 사용할 수 있는 방법이 해시 테이블을 사용하는 것이다.\n해시 테이블의 사용을 위해서 ‘해시 함수’를 만들어주게 된다.\n\n\n  해시 함수의 특징\n해시 함수를 거쳐 나온 값을 통해 value를 추측할 수 없다.\nvalue를 바로 적용하지 않기 때문에, 예를 들면 ‘100’이라는 숫자에 대해서 100개의 공간을 만든 뒤 값을 배치할 필요가 없어지게 된다.\n    function hashFunction(key) {\n  return key % 10;\n}\n    \n    위 함수에서 가장 중요한 것은 ‘10’이라는 크기 내로 한정되어진다는 것이다.\nHash Table의 key와 연결된 value를 삽입, 삭제, 탐색하는 알고리즘 함수이다.(대표적으로 MDS)\nkey가 들어오면 랜덤한 주소값을 생성한 뒤, 그 주소값으로 설정된 테이블에 key, value를 저장한다.\n해시함수 과정에서 해시충돌(Collision)이 발생할 수 있다.\n  \n\n\n\n\n2. 해시 충돌(Collision)\n\n\n  해시 충돌 : 서로 다른 value를 입력했을 때, 테이블 내 같은 index로 값이 들어가(같은 값이 나오게 되어) 겹치는 상황\n\n\n해시 테이블은 데이터의 개수보다 테이블의 크기를 줄이고자 하는 생각에서 나왔기 때문에, 이에 대한 해결책이 존재한다.\n근본적으로, 해시 함수를 짤 때 가능한 겹치는 값이 나오지 않도록 하는 것이 중요하지만, 결국 겹치는 구간이 존재할 수 밖에 없다.\n\n2-1. 개방 주소법(open address)\n\n충돌이 발생할 시, 테이블 내 새로운 주소를 탐사한 후, 비어있는 곳에 데이터를 입력하는 방식.\n해시 함수의 결과값 외에 다른 인덱스를 허용한다는 의미로 ‘개방 주소’라고 표현한다.\n\nA. 선형 탐사법(Linear Probing)\n\n선형으로 순차적으로 탐사하는 방법.\n충돌이 일어났을 경우, 충돌이 발생한 곳의 바로 옆자리로 배치가 이루어진다.\n\nconst hashingIndex = function (number) {\n  const result = number % 3;\n  return result;\n};\nclass hashTable {\n  constructor() {\n    this.table = [];\n  }\n\n  setValue(value = -1) {\n    const index = hashingIndex(value);\n    if (this.table[index]) {\n      this.table[index + 1] = value;\n    } else {\n      this.table[index] = value;\n    }\n  }\n  getTable() {\n    return this.table;\n  }\n}\n\nconst myTable = new hashTable();\nmyTable.setValue(4);\nmyTable.setValue(7);\n\nconsole.log(myTable.getTable());\n// [ &lt;1 empty item&gt;, 4, 7 ]\n\n\n위 코드에서 입력된 4, 7은 모두 3으로 나눌 때의 나머지 값이 1이므로, index 1에 값이 들어가야 한다.\n → 4가 이미 배치되어 있어 7은 그 옆 칸으로 이동하여 배치된다.\n문제점 : 값의 주변이 모두 채워지는 일차 군집화(Primay Clustering)가 발생하기 쉽다.\n → 이로 인해, 옆 칸에 저장되는 데이터가 늘어나고, 그 근처에 새로 저장되려는 값들도 끊임없이 옆으로 새로 이동해 저장되는 문제가 발생한다.\n\nB. 제곱 탐사법(Quadratic Probing)\n\n선형 탐사법과 유사한 방식이지만, 탐사의 폭이 제곱으로 늘어난다.\n충돌의 발생 수의 제곱만큼 이동하게 되므로 ‘한 번 충돌 시 1, 두 번 충돌 시 4’ 이런식으로 늘어나게 된다.\n\n\n\n3. JavaScript의 해시테이블(Hash Table) : Map\n\nJavaScript에서의 key-value 자료구조는 Object가 대표적이었는데, Map, Set이 추가되어 현재 JavaScript의 해시테이블은 “Object, Map, Set”가 있다.\n\n3-1. Map\n\nkey-value로 이루어진 해시 테이블로, Object와 주로 비교된다.\n탐색은 get(), 삽입은 set()으로 한다.\nkey 값은 고유한 값으로, 하나만 존재할 수 있으며, number, string, function, object, NaN이 자료형으로 사용된다.\nset()을 이용해 value를 설정한다.\n\nlet map = new Map();\n\nlet testNumber = 1;\nlet testString = \"string\";\nlet testObject = { A: \"a\" };\nlet testFucntion = (B) =&gt; {\n  B = \"b\";\n};\n\nmap.set(testNumber, 1);\nmap.set(testString, 2);\nmap.set(testObject, 3);\nmap.set(testFucntion, 4);\n\nconsole.log(map);\n/*\nMap(4) {\n  1 =&gt; 1,\n  'string' =&gt; 2,\n  { A: 'a' } =&gt; 3,\n  [Function (anonymous)] =&gt; 4\n}\n*/\n// map의 형태\n\n\n\n  get()을 통한 value 가져오기\n\n\nmap.get(testNumber); // 1\nmap.get(testString); // 2\nmap.get(testObject); // 3\nmap.get(testFucntion); // 4\n\n\n\n  has()를 통한 value 찾기\n\n\nmap.has(testFucntion); // true\nmap.has(testNumber); // true\n\n\n\n  delete()를 통한 value 삭제\n\n\nmap.delete(testFucntion); // true\nmap.get(testFucntion); // undefined\nmap.get(\"none\"); // undefined\n\n\n\n  size를 통한 value의 유무 확인\n\n\nmap.size; // 3\nmap.length; // undefined\n\n\n\n  for-of를 통한 hash 탐색\n\n\nfor (let [key, value] of map) {\n  console.log(key, \"=\", value);\n}\n// 1 = 1\n// string = 2\n// { A: 'a' } = 3\n// [Function: testFucntion] = 4\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// 1\n// string\n// { A: 'a' }\n// [Function: testFucntion]\nfor (let value of map.values()) {\n  console.log(value);\n}\n// 1\n// 2\n// 3\n// 4\nconsole.log(map.values());\n// [Map Iterator] { 1, 2, 3, 4 }\nconsole.log(map.keys());\n// [Map Iterator] { 1, 'string', { A: 'a' }, [Function: testFucntion] }\n\n\n\n\n4. 충돌(Collision)\n\n받아온 key값에 대해 hash function으로 index를 지정하고 넣어주게 되는데, 이미 해당 index에 값이 존재하는 경우가 발생할 수 있으며 이를 collision이라고 한다.\n해결을 위해서 대표적인 두 가지 방법이 존재한다.\n\n\n  Open Addressing\n겹치는 해당 index의 옆 자리에 넣게 되는 방법이다.\n이후에 해당 자리를 찾기 위해서 hash 값 index 이후부터 찾는 key값이 나올 때까지 찾는다.\n  Separate Chainining\nLinked List를 이용해 다음 링크에 끼워넣는 방법이다.\n이후 찾을 때에는 해당 링크를 타고 들어가면 된다.\n\n\n\n\n참고 링크\n\n\n  JavaScript Map, Hashmap\n전체적인 설명 : https://velog.io/@jun094/Hash와-Map\n설명 동영상 : https://www.youtube.com/watch?v=HraOg7W3VAM\n  Hashmap 충돌 해결법\nhttps://overcome-the-limits.tistory.com/entry/자료구조-해시테이블-with-JavaScript\n\n\nLinux\n\n\n\nLinux의 특징\n\n유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 ‘오픈 소스’를 꼽을 수 있다.\n커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다.\n즉, 이 커널로 자신의 운영 체제를 개발할 수 있다.\nLinux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다.\n",
        "url": "/dev/2021/12/11/%ED%95%B4%EC%8B%9C_%ED%95%B4%EC%8B%9C%EB%A7%B5/"
      },
    
      {
        "title": "디지털 논리회로",
        "feature_text": "여러 종류의 게이트 및 가산기 그리고 진법의 변환 과정 설명\n",
        "excerpt": "디지털 논리회로란?\n\n\n  이산적인 숫자를 게이트 입력으로 받아, 입력 논리의 필요 조건을 만족, 불만족하는 지에 대해 1 또는 0의 신호로 출력하는 하드웨어 소자이다.\n\n\n디지털 논리회로의 연결을 통해 컴퓨터의 구성 부품을 만들게 된다.\n또한, 논리적 사고를 위한 가장 기본적인 동작으로 프로그래밍 논리 구조와 연결된다.\n\n종류\n\n\n  AND 게이트(논리곱) : 두 입력 모두 1인 경우에만 1, 나머지는 0이 출력된다.\n\n\n\n\n\n  OR 게이트(논리합) : 두 입력 중 1이 존재할 경우 1, 아닐 시 0이 출력된다.\n\n\n\n\n\n  NOT 게이트(논리부정, INVERTOR) : 입력이 반전되어 출력된다.\n\n\n\n\n\n  NAND 게이트 : 두 입력 중 하나 이상 0인 경우 1, 나머지는 0이 출력된다.\n즉, 두 입력이 모두 1인 경우 0이 출력된다. AND 게이트와 반대의 역할을 한다.\n\n\n\n\n\n  NOR 게이트(부정논리합) : 두 입력 중 하나 이상 1인 경우 0, 나머지는 1이 출력된다.\n즉, 두 입력 모두 0인 경우에 1이 출력된다.\nOR 게이트와 반대의 역할을 한다.\n\n\n\n\n\n  XOR 게이트(배타적 논리합) : 입력이 같을 경우 0, 다를 경우 1이 출력된다. 참 입력의 개수가 홀수일 때 참을 내보낸다.\n\n\n\n\n이진수\n\n전원이 켜진 상태와 꺼진 상태를 각각 true, false의 형태로 나타낼 수 있으며, 이런 방식을 수학자 조지 부울의 이름을 따서 Boolean 타입이라고 부른다.\nBoolean 타입은 논리대수의 기본 타입이며 동시에 디지털 시스템을 구성하는 하드웨어 및 소프트웨어의 가장 기본적인 타입이다.\n모든 전자부품은 전기의 흐름 유무로 Boolean 타입을 나타낼 수 있으며, 이 개념의 확장으로 모든 10진수 숫자를 2진수 코드로 나타낼 수 있다.\n예시로, 1비트(bit)는 2개(0-1)의 값을 나타낼 수 있고, 2비트는 4개(0-3), 3비트는 8개(0-7)의 값을 나타낼 수 있다. 그리고 이는 각각 2^(비트수)의 형태로 나타난다.\n\n반가산기(half-adder)\n\n두 개의 비트를 더하는 과정에서, 결과값을 2비트의 값으로 표현해볼 수 있다.\n\n\n\n\n\n  \n    \n      +\n      0\n      1\n    \n  \n  \n    \n      0\n      00\n      01\n    \n    \n      1\n      01\n      10\n    \n  \n\n\n\n\n왼쪽과 같이 2비트의 값으로 나타낼 수 있고, 한 비트 내의 두 이진수를 더하면, 두 비트가 되어 각각의 비트를 합(sum)비트, 자리올림(carry)비트라고 한다.\n\n\n  합비트\n\n\n\n  \n    \n       \n      0\n      1\n    \n  \n  \n    \n      0\n      0\n      1\n    \n    \n      1\n      1\n      0\n    \n  \n\n\n\n  자리올림비트\n\n\n\n  \n    \n       \n      0\n      1\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      1\n      0\n      1\n    \n  \n\n\n전가산기(full-adder)\n\n두번째 자리부터는 자리올림이 발생한 경우에 대해서도 더해줘야 하기 때문에, 세 개의 이진수를 더하는 경우에는 두 개의 반가산기 및 OR 게이트를 활용하는 전가산기를 사용한다.\n\n\n\n\n\n\n10진법과 2진법\n\n10진법\n\n10의 배수의 단위로 숫자를 나누어 나타내는 방법이다. 10단위가 올라갈 때마다 숫자가 증가하는 모습을 보인다.\n\n2진법\n\n2의 배수의 단위로 숫자를 나누어 나타낸다. 2단위가 증가 시 숫자가 올라가게 된다. 가장 작은 단위는 2^0 단위로, 이 한 단위를 비트(bit)로 표현하게 된다.\n",
        "content": "디지털 논리회로란?\n\n\n  이산적인 숫자를 게이트 입력으로 받아, 입력 논리의 필요 조건을 만족, 불만족하는 지에 대해 1 또는 0의 신호로 출력하는 하드웨어 소자이다.\n\n\n디지털 논리회로의 연결을 통해 컴퓨터의 구성 부품을 만들게 된다.\n또한, 논리적 사고를 위한 가장 기본적인 동작으로 프로그래밍 논리 구조와 연결된다.\n\n종류\n\n\n  AND 게이트(논리곱) : 두 입력 모두 1인 경우에만 1, 나머지는 0이 출력된다.\n\n\n\n\n\n  OR 게이트(논리합) : 두 입력 중 1이 존재할 경우 1, 아닐 시 0이 출력된다.\n\n\n\n\n\n  NOT 게이트(논리부정, INVERTOR) : 입력이 반전되어 출력된다.\n\n\n\n\n\n  NAND 게이트 : 두 입력 중 하나 이상 0인 경우 1, 나머지는 0이 출력된다.\n즉, 두 입력이 모두 1인 경우 0이 출력된다. AND 게이트와 반대의 역할을 한다.\n\n\n\n\n\n  NOR 게이트(부정논리합) : 두 입력 중 하나 이상 1인 경우 0, 나머지는 1이 출력된다.\n즉, 두 입력 모두 0인 경우에 1이 출력된다.\nOR 게이트와 반대의 역할을 한다.\n\n\n\n\n\n  XOR 게이트(배타적 논리합) : 입력이 같을 경우 0, 다를 경우 1이 출력된다. 참 입력의 개수가 홀수일 때 참을 내보낸다.\n\n\n\n\n이진수\n\n전원이 켜진 상태와 꺼진 상태를 각각 true, false의 형태로 나타낼 수 있으며, 이런 방식을 수학자 조지 부울의 이름을 따서 Boolean 타입이라고 부른다.\nBoolean 타입은 논리대수의 기본 타입이며 동시에 디지털 시스템을 구성하는 하드웨어 및 소프트웨어의 가장 기본적인 타입이다.\n모든 전자부품은 전기의 흐름 유무로 Boolean 타입을 나타낼 수 있으며, 이 개념의 확장으로 모든 10진수 숫자를 2진수 코드로 나타낼 수 있다.\n예시로, 1비트(bit)는 2개(0-1)의 값을 나타낼 수 있고, 2비트는 4개(0-3), 3비트는 8개(0-7)의 값을 나타낼 수 있다. 그리고 이는 각각 2^(비트수)의 형태로 나타난다.\n\n반가산기(half-adder)\n\n두 개의 비트를 더하는 과정에서, 결과값을 2비트의 값으로 표현해볼 수 있다.\n\n\n\n\n\n  \n    \n      +\n      0\n      1\n    \n  \n  \n    \n      0\n      00\n      01\n    \n    \n      1\n      01\n      10\n    \n  \n\n\n\n\n왼쪽과 같이 2비트의 값으로 나타낼 수 있고, 한 비트 내의 두 이진수를 더하면, 두 비트가 되어 각각의 비트를 합(sum)비트, 자리올림(carry)비트라고 한다.\n\n\n  합비트\n\n\n\n  \n    \n       \n      0\n      1\n    \n  \n  \n    \n      0\n      0\n      1\n    \n    \n      1\n      1\n      0\n    \n  \n\n\n\n  자리올림비트\n\n\n\n  \n    \n       \n      0\n      1\n    \n  \n  \n    \n      0\n      0\n      0\n    \n    \n      1\n      0\n      1\n    \n  \n\n\n전가산기(full-adder)\n\n두번째 자리부터는 자리올림이 발생한 경우에 대해서도 더해줘야 하기 때문에, 세 개의 이진수를 더하는 경우에는 두 개의 반가산기 및 OR 게이트를 활용하는 전가산기를 사용한다.\n\n\n\n\n\n\n10진법과 2진법\n\n10진법\n\n10의 배수의 단위로 숫자를 나누어 나타내는 방법이다. 10단위가 올라갈 때마다 숫자가 증가하는 모습을 보인다.\n\n2진법\n\n2의 배수의 단위로 숫자를 나누어 나타낸다. 2단위가 증가 시 숫자가 올라가게 된다. 가장 작은 단위는 2^0 단위로, 이 한 단위를 비트(bit)로 표현하게 된다.\n",
        "url": "/dev/2022/01/03/%EB%94%94%EC%A7%80%ED%84%B8_%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C/"
      },
    
      {
        "title": "Linux, Ubuntu, SSH",
        "feature_text": "리눅스에 대한 간단한 설명 및 우분투 설치 방법\n",
        "excerpt": "리눅스\n\n1. 개발환경\n\n\n  로컬 컴퓨터, 리모트 컴퓨터 : 웹 서버에 배포하기 위해서 로컬 컴퓨터에서 작업한 내용을 리모트 컴퓨터로 옮기게 된다.\n  로컬 컴퓨터, 가상 컴퓨터 : 물리적 환경에서만 리모트 컴퓨터를 쓸 수 있는 제약을 막기 위해 가상 컴퓨터에서의 배포를 진행해보게 되며, 이를 위해 가상 환경 구현을 진행한다.\n  유닉스 : iOS, OS X 등의 베이스가 되는 컴퓨터의 운영체제로, 1969년 벨 연구소 직원인 켄 톰슨이 게임의 원활한 진행을 위해 고안하다가 만들었다.\n  리눅스 : 윈도우, 맥OS와 달리 무료로 제공되는 운영체제로, ‘리누스 토르발스’가 1991년에 만들었다.\n\n\nLinux\n\n1. Linux의 특징\n\n유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 ‘오픈 소스’를 꼽을 수 있다.\n커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다.\n즉, 이 커널로 자신의 운영 체제를 개발할 수 있다.\nLinux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다.\n장치 메모리를 관리하고 프로세스를 관리하는 역할을 수행한다.\n현재 여러 사용자가 기본 설정에 따라 다운로드할 수 있는 Linux 배포판을 사용할 수 있으며, 이 배포판은 여러 개발자들이 만들었다.\n현재 Linux 커널은 운영 체제 역할을 위한 다양한 배포판을 지원하는데, 이 중 하나가 바로 Ubuntu이다.\n\n2. Linux의 장점\n\n안정적이며 안전한 운영 체제이며 여러 사용자가 동시 작업할 수 있기 때문에 다중 사용자 시스템으로 사용된다.\n많은 프로세서를 지원하며 멀티 태스킹으로 많은 프로세스의 실행이 가능하다.\n\n3. OS(Operating System, 운영체제)\n\n컴퓨터 시스템의 하드웨어, 소프트웨어 자원들을 효율적으로 운영해, 사용자의 시스템 이용을 편리하도록 하는 시스템 소프트웨어를 말한다.\n애플리케이션들이 동작하도록 자원을 관리하며 핵심 소프트웨어의 역할을 수행한다.\n추가적으로, 외부의 접근을 방어하는 역할도 수행한다.\n운영체제는 사용자 영역과 커널 영역으로 나눌 수 있다.\n\n\n  사용자 영역 : 사용자의 프로그램 사용을 위한 공간이다.\n  커널 영역 : 사용자 영역의 사용 프로그램을 안전하고 효율적으로 작동하기 위해 컴퓨터 자원을 관리하는 공간이다.\n\n\n4. Kernal(커널)\n\n컴퓨터의 운영체제의 핵심이 되는 프로그램으로, 시스템의 모든 것을 통제하는 역할을 수행한다.\n운영체제의 프로그램 수행을 위한 여러 서비스를 제공한다.\n보안, 자원관리, 추상화 같은 역할을 수행한다.\n\n5. 배포판?\n\n리눅스에서 작동하는 여러 프로그램을 모아 놓은 것으로, 이렇게 여러 프로그램이 모여 주어진 일을 수행하는 경우가 있으며, 이 중 하나가 Ubuntu이다.\n\n6. Parallels, Ubuntu 설치\n\n이미 윈도우 사용을 위해 Parallels 구입을 한 상태이기 때문에 Parallels로 Ubuntu 설치를 진행했다.\n우선, Ubuntu 페이지에서 다운로드를 진행하면 ubuntu-20.04.3-desktop-amd64.iso라는 이름의 파일이 생기게 된다.\nParallels에서 새로운 OS 설치 버튼을 클릭하면 다운로드된 iso파일을 스스로 인식해 진행할 수 있다.\n\n\n\n\n\n일반적인 윈도우 같은 운영체제의 설치와 같은 방식으로 진행되며, 따라서 진행을 하다보면 Ubuntu의 설치가 완료된다.\n\n\n\n7. SSH 설정\n\n원격 접속 설정을 위해 ssh 설정을 해야 하는데, Ubuntu 내의 터미널 파일을 켜야 한다.\n\n\n\n좌측 하단에 메뉴 버튼을 클릭 시 이러한 창이 나오는데, 거기서 terminal을 찾아서 실행하면 된다. 단축키는 Ctrl + Alt + T(맥에서는 아직 찾지 못함)\n\n\n\n위와 같은 창이 나오게 되고, ssh와 관련된 입력들을 넣어주면 된다.\n\n1) SSH server install\n\n$ sudo apt update\n$ sudo apt install openssh-server\n\n\n위 명령어를 입력해 SSH server를 설치한다.\n설치 여부의 확인을 위해 sudo systemctl status ssh를 입력하면 아래와 같은 결과가 나오는 것을 볼 수 있다.\n\n\n\n여기서 active(running)이라는 표시가 있으면 제대로 동작하고 있다고 할 수 있다.\n만약, 동작하지 않을 시 아래의 명령어 중 하나를 입력해 실행시킨다.\n\n$ sudo systemctl enable ssh\n$ sudo systemctl start ssh\n\n\n2) Firewall\n\n방화벽을 사용 중일 경우, SSH를 허용해야 하며, $ sudo ufw allow ssh를 입력해 허용할 수 있다.\n방화벽 사용 여부의 확인은 $ sudo ufw status를 통해 할 수 있다.\n\n3) Client\n\nUbuntu는 기본적으로 SSH client가 설치되어 있는데, 혹시 설치되지 않은 경우에는 $ sudo apt-get install openssh-client를 통해 설치할 수 있다.\nClient에서의 실행을 위해 username과 IP주소가 필요한데, IP주소는 ip a명령어를 통해서 확인할 수 있다.\n명령어 입력 시 긴 줄이 나오게 되는데, 이 중 inet (IP주소)/24 brd~라고 되어 있는 부분에서 IP주소를 가져오면 된다.\n\n\n\n원래의 이용하는 PC(Client)에서 터미널로 들어가 username@IP를 입력하면 접속과 관련된 질문이 나오고, yes를 누른 뒤 비밀번호 입력까지 완료하면 접속이 된다.\n\n\n\n접속을 나오고 싶을 때에는 exit를 입력하면 나올 수 있고, SSH 종료를 위해서 sudo systemctl stop ssh를 입력하면 된다.\n\n\n\n4) Directory 생성\n\nmkdir (filename)입력 시 생성이 가능하다.\n이전과 같이 원격으로 접속을 하고, 입력하게 될 시, 새로운 디렉토리가 만들어지게 된다.\n\n\n\nls는 디렉토리 내의 파일 목록들을 보여주는데, mkdir을 한 뒤 다시 보면 생성된 것을 확인할 수 있다.\n\n5) 접근 권한 부여\n\nchmod라는 명령어를 통해서 파일과 폴더에 대한 접근권한을 부여할 수 있다.\n정확한 명령어는 아래와 같다.\n\nchmod [옵션] [사용자] [설정기호] [권한] [file or directory]\n\n\n\n  접근 권한 문자열\n\n\n\n  \n    \n      구분\n      기호\n      설명\n    \n  \n  \n    \n      접근권한\n      r\n      읽기\n    \n    \n       \n      w\n      쓰기\n    \n    \n       \n      x\n      실행\n    \n    \n      수행 연산\n      +\n      권한 추가\n    \n    \n       \n      -\n      권한 제거\n    \n    \n       \n      +\n      권한 부여\n    \n    \n      사용자\n      u\n      user의 약자, 소유자\n    \n    \n       \n      g\n      group의 약자, 그룹\n    \n    \n       \n      o\n      other의 약자, 일반 사용자\n    \n    \n       \n      a\n      all의 약자, 모든 사용자\n    \n    \n       \n      비어 있음\n      a와 동일\n    \n  \n\n\n\n  접근 권한 숫자열\n\n\n\n  \n    \n      8진수\n      2진수\n      파일 모드\n      권한\n    \n  \n  \n    \n      0\n      000\n      - - -\n      권한 없음\n    \n    \n      1\n      001\n      - - x\n      실행\n    \n    \n      2\n      010\n      - w -\n      쓰기\n    \n    \n      3\n      011\n      - w x\n      쓰기, 실행\n    \n    \n      4\n      100\n      r - -\n      읽기\n    \n    \n      5\n      101\n      r - x\n      읽기, 실행\n    \n    \n      6\n      110\n      r w -\n      읽기, 쓰기\n    \n    \n      7\n      111\n      r w x\n      읽기, 쓰기, 실행\n    \n  \n\n\n숫자열 세 개를 작성하는 경우, 소유자(u), 그룹(g), 일반사용자(o)의 순서로 권한을 부여한다.\n예를 들어 754의 경우 소유자는 7(읽기, 쓰기, 실행), 그룹은 5(읽기, 실행), 일반사용자는 4(읽기)가 가능한 것으로 설정할 수 있다.\n\njinjeon@ubuntu:~$ chmod 764 test\n\n\n위와 같이 입력 시, test 디렉토리에 소유자 7, 그룹 6, 일반 사용자 4의 권한을 준 것이다.\n\n링크\n\n\n  VirtualBox, Ubuntu 설치 안내\nhttps://popcorn16.tistory.com/85\n  parallels, Ubuntu 설치 안내\nhttps://m.blog.naver.com/woodkill/220790227283\n  Linux, Ubuntu의 차이\nhttps://ko.strephonsays.com/difference-between-linux-and-ubuntu\n  SSH 설치 및 접속 방법\nhttps://codechacha.com/ko/ubuntu-install-openssh/\nhttps://jmoon.co.kr/183\n  Ubuntu root 계정 전환 방법\nhttps://gabii.tistory.com/entry/Ubuntu-초기-root-계정-설정-및-계정-전환\n  폴더 권한 변경(764)\nhttps://itworld.gmax8.com/25\n\n",
        "content": "리눅스\n\n1. 개발환경\n\n\n  로컬 컴퓨터, 리모트 컴퓨터 : 웹 서버에 배포하기 위해서 로컬 컴퓨터에서 작업한 내용을 리모트 컴퓨터로 옮기게 된다.\n  로컬 컴퓨터, 가상 컴퓨터 : 물리적 환경에서만 리모트 컴퓨터를 쓸 수 있는 제약을 막기 위해 가상 컴퓨터에서의 배포를 진행해보게 되며, 이를 위해 가상 환경 구현을 진행한다.\n  유닉스 : iOS, OS X 등의 베이스가 되는 컴퓨터의 운영체제로, 1969년 벨 연구소 직원인 켄 톰슨이 게임의 원활한 진행을 위해 고안하다가 만들었다.\n  리눅스 : 윈도우, 맥OS와 달리 무료로 제공되는 운영체제로, ‘리누스 토르발스’가 1991년에 만들었다.\n\n\nLinux\n\n1. Linux의 특징\n\n유닉스 기반의 무료 오픈 소스 운영체제이며, 윈도우와 맥과 가장 구별되는 점으로 ‘오픈 소스’를 꼽을 수 있다.\n커스터마이즈된 OS를 만들 수 있는 커널로, Linux 커널을 기반으로 하며, 커널은 운영 체제의 핵심이라고 할 수 있다.\n즉, 이 커널로 자신의 운영 체제를 개발할 수 있다.\nLinux 아키텍처는 커널, 시스템 라이브러리, 시스템 도구와 같은 구성 요소로 이루어진다.\n장치 메모리를 관리하고 프로세스를 관리하는 역할을 수행한다.\n현재 여러 사용자가 기본 설정에 따라 다운로드할 수 있는 Linux 배포판을 사용할 수 있으며, 이 배포판은 여러 개발자들이 만들었다.\n현재 Linux 커널은 운영 체제 역할을 위한 다양한 배포판을 지원하는데, 이 중 하나가 바로 Ubuntu이다.\n\n2. Linux의 장점\n\n안정적이며 안전한 운영 체제이며 여러 사용자가 동시 작업할 수 있기 때문에 다중 사용자 시스템으로 사용된다.\n많은 프로세서를 지원하며 멀티 태스킹으로 많은 프로세스의 실행이 가능하다.\n\n3. OS(Operating System, 운영체제)\n\n컴퓨터 시스템의 하드웨어, 소프트웨어 자원들을 효율적으로 운영해, 사용자의 시스템 이용을 편리하도록 하는 시스템 소프트웨어를 말한다.\n애플리케이션들이 동작하도록 자원을 관리하며 핵심 소프트웨어의 역할을 수행한다.\n추가적으로, 외부의 접근을 방어하는 역할도 수행한다.\n운영체제는 사용자 영역과 커널 영역으로 나눌 수 있다.\n\n\n  사용자 영역 : 사용자의 프로그램 사용을 위한 공간이다.\n  커널 영역 : 사용자 영역의 사용 프로그램을 안전하고 효율적으로 작동하기 위해 컴퓨터 자원을 관리하는 공간이다.\n\n\n4. Kernal(커널)\n\n컴퓨터의 운영체제의 핵심이 되는 프로그램으로, 시스템의 모든 것을 통제하는 역할을 수행한다.\n운영체제의 프로그램 수행을 위한 여러 서비스를 제공한다.\n보안, 자원관리, 추상화 같은 역할을 수행한다.\n\n5. 배포판?\n\n리눅스에서 작동하는 여러 프로그램을 모아 놓은 것으로, 이렇게 여러 프로그램이 모여 주어진 일을 수행하는 경우가 있으며, 이 중 하나가 Ubuntu이다.\n\n6. Parallels, Ubuntu 설치\n\n이미 윈도우 사용을 위해 Parallels 구입을 한 상태이기 때문에 Parallels로 Ubuntu 설치를 진행했다.\n우선, Ubuntu 페이지에서 다운로드를 진행하면 ubuntu-20.04.3-desktop-amd64.iso라는 이름의 파일이 생기게 된다.\nParallels에서 새로운 OS 설치 버튼을 클릭하면 다운로드된 iso파일을 스스로 인식해 진행할 수 있다.\n\n\n\n\n\n일반적인 윈도우 같은 운영체제의 설치와 같은 방식으로 진행되며, 따라서 진행을 하다보면 Ubuntu의 설치가 완료된다.\n\n\n\n7. SSH 설정\n\n원격 접속 설정을 위해 ssh 설정을 해야 하는데, Ubuntu 내의 터미널 파일을 켜야 한다.\n\n\n\n좌측 하단에 메뉴 버튼을 클릭 시 이러한 창이 나오는데, 거기서 terminal을 찾아서 실행하면 된다. 단축키는 Ctrl + Alt + T(맥에서는 아직 찾지 못함)\n\n\n\n위와 같은 창이 나오게 되고, ssh와 관련된 입력들을 넣어주면 된다.\n\n1) SSH server install\n\n$ sudo apt update\n$ sudo apt install openssh-server\n\n\n위 명령어를 입력해 SSH server를 설치한다.\n설치 여부의 확인을 위해 sudo systemctl status ssh를 입력하면 아래와 같은 결과가 나오는 것을 볼 수 있다.\n\n\n\n여기서 active(running)이라는 표시가 있으면 제대로 동작하고 있다고 할 수 있다.\n만약, 동작하지 않을 시 아래의 명령어 중 하나를 입력해 실행시킨다.\n\n$ sudo systemctl enable ssh\n$ sudo systemctl start ssh\n\n\n2) Firewall\n\n방화벽을 사용 중일 경우, SSH를 허용해야 하며, $ sudo ufw allow ssh를 입력해 허용할 수 있다.\n방화벽 사용 여부의 확인은 $ sudo ufw status를 통해 할 수 있다.\n\n3) Client\n\nUbuntu는 기본적으로 SSH client가 설치되어 있는데, 혹시 설치되지 않은 경우에는 $ sudo apt-get install openssh-client를 통해 설치할 수 있다.\nClient에서의 실행을 위해 username과 IP주소가 필요한데, IP주소는 ip a명령어를 통해서 확인할 수 있다.\n명령어 입력 시 긴 줄이 나오게 되는데, 이 중 inet (IP주소)/24 brd~라고 되어 있는 부분에서 IP주소를 가져오면 된다.\n\n\n\n원래의 이용하는 PC(Client)에서 터미널로 들어가 username@IP를 입력하면 접속과 관련된 질문이 나오고, yes를 누른 뒤 비밀번호 입력까지 완료하면 접속이 된다.\n\n\n\n접속을 나오고 싶을 때에는 exit를 입력하면 나올 수 있고, SSH 종료를 위해서 sudo systemctl stop ssh를 입력하면 된다.\n\n\n\n4) Directory 생성\n\nmkdir (filename)입력 시 생성이 가능하다.\n이전과 같이 원격으로 접속을 하고, 입력하게 될 시, 새로운 디렉토리가 만들어지게 된다.\n\n\n\nls는 디렉토리 내의 파일 목록들을 보여주는데, mkdir을 한 뒤 다시 보면 생성된 것을 확인할 수 있다.\n\n5) 접근 권한 부여\n\nchmod라는 명령어를 통해서 파일과 폴더에 대한 접근권한을 부여할 수 있다.\n정확한 명령어는 아래와 같다.\n\nchmod [옵션] [사용자] [설정기호] [권한] [file or directory]\n\n\n\n  접근 권한 문자열\n\n\n\n  \n    \n      구분\n      기호\n      설명\n    \n  \n  \n    \n      접근권한\n      r\n      읽기\n    \n    \n       \n      w\n      쓰기\n    \n    \n       \n      x\n      실행\n    \n    \n      수행 연산\n      +\n      권한 추가\n    \n    \n       \n      -\n      권한 제거\n    \n    \n       \n      +\n      권한 부여\n    \n    \n      사용자\n      u\n      user의 약자, 소유자\n    \n    \n       \n      g\n      group의 약자, 그룹\n    \n    \n       \n      o\n      other의 약자, 일반 사용자\n    \n    \n       \n      a\n      all의 약자, 모든 사용자\n    \n    \n       \n      비어 있음\n      a와 동일\n    \n  \n\n\n\n  접근 권한 숫자열\n\n\n\n  \n    \n      8진수\n      2진수\n      파일 모드\n      권한\n    \n  \n  \n    \n      0\n      000\n      - - -\n      권한 없음\n    \n    \n      1\n      001\n      - - x\n      실행\n    \n    \n      2\n      010\n      - w -\n      쓰기\n    \n    \n      3\n      011\n      - w x\n      쓰기, 실행\n    \n    \n      4\n      100\n      r - -\n      읽기\n    \n    \n      5\n      101\n      r - x\n      읽기, 실행\n    \n    \n      6\n      110\n      r w -\n      읽기, 쓰기\n    \n    \n      7\n      111\n      r w x\n      읽기, 쓰기, 실행\n    \n  \n\n\n숫자열 세 개를 작성하는 경우, 소유자(u), 그룹(g), 일반사용자(o)의 순서로 권한을 부여한다.\n예를 들어 754의 경우 소유자는 7(읽기, 쓰기, 실행), 그룹은 5(읽기, 실행), 일반사용자는 4(읽기)가 가능한 것으로 설정할 수 있다.\n\njinjeon@ubuntu:~$ chmod 764 test\n\n\n위와 같이 입력 시, test 디렉토리에 소유자 7, 그룹 6, 일반 사용자 4의 권한을 준 것이다.\n\n링크\n\n\n  VirtualBox, Ubuntu 설치 안내\nhttps://popcorn16.tistory.com/85\n  parallels, Ubuntu 설치 안내\nhttps://m.blog.naver.com/woodkill/220790227283\n  Linux, Ubuntu의 차이\nhttps://ko.strephonsays.com/difference-between-linux-and-ubuntu\n  SSH 설치 및 접속 방법\nhttps://codechacha.com/ko/ubuntu-install-openssh/\nhttps://jmoon.co.kr/183\n  Ubuntu root 계정 전환 방법\nhttps://gabii.tistory.com/entry/Ubuntu-초기-root-계정-설정-및-계정-전환\n  폴더 권한 변경(764)\nhttps://itworld.gmax8.com/25\n\n",
        "url": "/dev/2022/01/06/%EB%A6%AC%EB%88%85%EC%8A%A4/"
      },
    
      {
        "title": "Shell Script",
        "feature_text": "Shell Script에 대한 설명 및 사용 방법\n",
        "excerpt": "Shell\n\n\n  OS와 대화하는 프로그램으로, 여러 종류가 있으며 그 예시로 ‘bash, zsh’가 있다.\n\n\n1. Shell Script?\n\nShell의 종류는 Bourne Shell, Bash, ksh, zsh가 있다.\nBash는 Bourne-Agin Shell의 약자로 명령형 편집 기능을 제공하며 리눅스에서 가장 많이 사용된다.\nzsh는 z셸 스크립을 위한 명령 인터프리터이다.\nShell Script(sh file)를 사용하게 되며, 이는 txt 형식으로 저장되는 프로그램으로, shell이 실행할 수 있는 명령들의 집합이라고 볼 수 있다.\n자동화 작업들을 shell script로 만들어 편리한 사용이 가능하다.\n\n2. Shell Script 파일 생성, 작성, 실행\n\n\n  생성 : vi (filename).sh을 입력해 파일을 생성할 수 있으며, 이 곳에서 shell script를 작성하게 된다.\n  입력 : i키를 누르면 입력이 가능한 상태가 되며, 한 줄 씩 작성을 진행하면 된다.\n  저장 : esc키를 누른 뒤, :wq키를 입력해 나오면 된다.\n  실행 : sh (filename).sh를 입력하면 저장된 내용이 실행된다.\n\n\n#!/bin/bash\necho \"HIHIHI!\"\npwd\nls\n\n\n위와 같이 작성을 한 뒤, 실행하면 아래의 사진과 같은 결과가 나온다.\n입력값 불러오기(echo), 현재 위치 경로 출력(pwd), 현재 위치 디렉토리 파일 출력(ls)의 순서대로 나온 것을 볼 수 있다.\n\n\n\n3. Shell Script내 간단한 문법들\n\n3-1. 반복문 - for\n\n기본적으로 사용하는 반복문으로 for가 있다. for in - do - done의 형태로 이루어지며, 코드로 보면 다음과 같다.\n\nfor file in $files\ndo\n\tfilename=`basename $file`\ndone\n\n\n변수로 지정해준 $files내의 각 요소들을 변수명 file로 지정해주었고, do - done 사이에 이와 관련된 내용들을 작성해주면 된다.\n\n3-2. 파일, 디렉토리 찾기 - find\n\nfind . -name \"DAY*\"\n\nfind . -name \"DAY*\" -type d\nfind . -name \"DAY*\" -type f\n\n\n‘.’은 현재 디렉토리 내의 모든 파일, -name은 이름으로 찾는 것, “DAY*”는 DAY라는 형식으로 이루어진 모든 파일임을 말한다.\n-type d는 디렉토리로, -type f는 파일로 찾는다는 것을 말한다.\n\nfind . -empty\n\n\n-empty를 이용해 빈 파일을 찾는 데에 사용할 수 있다.\n\nfind . -size +100M\n\n\n-size를 이용해 특정 크기 이상, 이하의 파일을 찾는 데에 사용할 수 있다.\n\nfind . -name \"DAY*\" -exec ls -l {} \\;\n\n\n-exec를 이용해 부가적인 작업의 수행이 가능하다.\n검색된 파일이 {} 위치에 들어오게 되고, 추가적인 작업을 이어나가면 된다.\n\n3-3. 디렉토리 생성 ∙ 삭제\n\nmkdir ABC\nrm -rf ABC\n\n\nmkdir를 이용해 뒤에 나오는 단어의 이름으로 디렉토리를 생성할 수 있다.\nrm을 이용해 파일 및 디렉토리의 삭제가 가능하다. 단, 디렉토리의 삭제를 위해서는 -r이라는 옵션이 들어가야하고, -f라는 옵션을 함께 사용하면, 경고 없이 모두 강제로 삭제된다.\n\n3-4. 경로에서 파일명 가져오기\n\ndirname=`basename $dir`\n\n\nbasename을 이용하면 특정 경로를 나타내는 값들의 마지막 부분,\n예를 들면, home/ABC/backup/test.txt와 같은 상황에서 test.txt만 나오도록 할 수 있다.\n위 코드의 경우, ` dirname=```의 형태를 갖고 있는데, 이렇게 할 경우,  dirname이라는 변수가 만들어지고, $dirname로 활용할 수 있다.\n\n3-5. 문자열 일부 가져오기\n\ndirnum=${dirname:3}\n\n# dirname : \"HELLO WORLD\"\n# dirnum : LO WORLD\n\n\ndirname의 값으로 나오는 문자열 중, 네 번째(3+1)의 값부터 문자열을 잘라 표현해준다. 즉, 뒤에 나오는 숫자에 맞는 순서의 문자부터 그 뒤의 값들을 보여준다.\n\n3-6. 조건문 사용하기 - if\n\nif [ -f $filename ]\nthen\n  ...\nelse\n\t...\nfi\n\n\nif 의 내부에 값이 true일 경우, then의 다음에 오는 과정들을 처리하고, 아닐경우 else의 뒤에 오는 과정들을 처리한다. 이 과정을 fi가 나올 때까지 진행한다.\n조건문의 여러 상황에 대해 정리된 자료 링크가 있어 아래에 추가적으로 적는다.\n\n# if 여러 상황에 대해서\n[ -z ${A} ] : A 문자열의 길이가 0이면 TRUE\n[ -n ${A} ] : A 문자열의 길이가 0이 아니면 TRUE\n[ ${A} -eq ${B} ] : A와 B값이 같으면 TRUE\n[ ${A} -ne ${B} ] : A와 B값이 다르면 TRUE\n[ ${A} -gt ${B} ] : A가 B보다 크면 TRUE\n[ ${A} -ge ${B} ] : A가 B보다 크거나 같으면 TRUE\n[ ${A} -lt ${B} ] : A가 B보다 작으면 TRUE\n[ ${A} -le ${B} ] : A가 B보다 작거나 같으면 TRUE\n\n[ 조건식A -a 조건식B ] : 조건식 A와 B가 모두 TRUE이면 TRUE (&amp;&amp; 와 동일)\n[ 조건식A -o 조건식B ] : 조건식 A가 TRUE거나 조건식B가 TRUE면 TRUE (|| 와 동일)\n\n파일관련\n[ -d ${A} ] : A 파일이 디렉토리면 TRUE\n[ -e ${A} ] : A 파일이(노드, 디렉토리, 소켓 등등 모두) 존재하면 TRUE\n[ -L ${A} ] : A 파일이 심볼릭 링크면 TRUE\n[ -r ${A} ] : A 파일이 읽기 가능하면 TRUE\n[ -s ${A} ] : A 파일의 크기가 0 보다 크면 TRUE\n[ -w ${A} ] : A 파일이 쓰기 가능하면 TRUE\n[ -x ${A} ] : A 파일이 실행 가능하면 TRUE\n[ -c ${A} ] : A 파일이 Special character file 이면 TRUE\n[ -f ${A} ] : A 파일이 디렉토리가 아닌 일반 regular 파일이면 TRUE\n[ -S ${A} ] : A 파일이 소켓이면 TRUE\n[ ${A} -nt ${B} ] : A 파일 B 파일보다 최신파일이면 참\n[ ${A} -ot ${B} ]  : A 파일이 B 파일보다 이전파일이면 참\n[ ${A} -ef ${B} ] : A 파일과 B 파일이 같은 파일이면 참\n\n\n3-7. 결과값 표시 - echo\n\necho text or 변수명\n\n\n적혀진 텍스트, 혹은 변수의 값을 표현해준다.\nJavaScript의 console.log와 같은 역할을 한다고 볼 수 있어, Shell Script 사용 시 사용자에게 보여주어야 할 메세지가 있을 때에도 사용할 수 있다.\n\n3-8. 시간 구하기 - date\n\ndate\n\nday=`date +%Y%m%d`\n\n\ndate라고 작성할 시 2022년 1월 10일 월요일 01시 51분 38초 KST 와 같이 결과값이 나오게 된다.\n위의 코드같은 경우, 결과 값으로 20220110가 나오게 되며, 이를 활용해 다양한 날짜의 표현이 가능하다. 세세한 여러 표현 방법을 알려주는 링크를 참고하면 좋을 듯 하다.\n\n3-9. 파일 압축하기 - zip\n\nzip BACKUP_$day.zip ./BEFORE_ZIP\n\nzip AAA.zip -r ./*\n\n\nzip “파일이름” “압축할 디렉토리” 의 순서로 작성하면 된다.\n두 번째와 같이 -r을 작성하면 현재폴더의 모든 것 및 하위 폴더들도 모두 압축하게 된다.\n\n3-10. 다른 서버로의 파일 전송 - scp\n\n# 로컬에서 원격\nscp [전송할 파일 경로] [유저명]@[IP주소]:[받을 경로]\n\n# 원격에서 로컬\nscp [유저명]@[IP주소]:[전송할 파일 경로] [받을 경로]\n\n# 원격에서 원격\nscp [유저명]@[IP주소]:[전송할 파일 경로] [유저명]@[IP주소]:[받을 경로]\n\n\nscp ./BACKUP_$day.zip $ubuntuserver:backup와 같이 작성하면, 내 서버내의 특정 파일을 다른 원격으로 보내는 경우로, 첫 번째 예시의 사례와 같다.\n\n\n\n링크\n\n\n  쉘 스크립트 생성\nhttps://jaynamm.tistory.com/entry/Shell-Script-Shell-Script-생성-및-실행\nhttps://rrecoder.tistory.com/62\n  쉘 스크립트 scp 간단 사용법\nhttps://doheejin.github.io/linux/2021/03/03/linux-scp.html\n  터미널 디렉토리, 파일 삭제 방법\nhttps://www.delftstack.com/ko/howto/linux/how-to-delete-files-and-directories-in-linux-terminal/\n\n",
        "content": "Shell\n\n\n  OS와 대화하는 프로그램으로, 여러 종류가 있으며 그 예시로 ‘bash, zsh’가 있다.\n\n\n1. Shell Script?\n\nShell의 종류는 Bourne Shell, Bash, ksh, zsh가 있다.\nBash는 Bourne-Agin Shell의 약자로 명령형 편집 기능을 제공하며 리눅스에서 가장 많이 사용된다.\nzsh는 z셸 스크립을 위한 명령 인터프리터이다.\nShell Script(sh file)를 사용하게 되며, 이는 txt 형식으로 저장되는 프로그램으로, shell이 실행할 수 있는 명령들의 집합이라고 볼 수 있다.\n자동화 작업들을 shell script로 만들어 편리한 사용이 가능하다.\n\n2. Shell Script 파일 생성, 작성, 실행\n\n\n  생성 : vi (filename).sh을 입력해 파일을 생성할 수 있으며, 이 곳에서 shell script를 작성하게 된다.\n  입력 : i키를 누르면 입력이 가능한 상태가 되며, 한 줄 씩 작성을 진행하면 된다.\n  저장 : esc키를 누른 뒤, :wq키를 입력해 나오면 된다.\n  실행 : sh (filename).sh를 입력하면 저장된 내용이 실행된다.\n\n\n#!/bin/bash\necho \"HIHIHI!\"\npwd\nls\n\n\n위와 같이 작성을 한 뒤, 실행하면 아래의 사진과 같은 결과가 나온다.\n입력값 불러오기(echo), 현재 위치 경로 출력(pwd), 현재 위치 디렉토리 파일 출력(ls)의 순서대로 나온 것을 볼 수 있다.\n\n\n\n3. Shell Script내 간단한 문법들\n\n3-1. 반복문 - for\n\n기본적으로 사용하는 반복문으로 for가 있다. for in - do - done의 형태로 이루어지며, 코드로 보면 다음과 같다.\n\nfor file in $files\ndo\n\tfilename=`basename $file`\ndone\n\n\n변수로 지정해준 $files내의 각 요소들을 변수명 file로 지정해주었고, do - done 사이에 이와 관련된 내용들을 작성해주면 된다.\n\n3-2. 파일, 디렉토리 찾기 - find\n\nfind . -name \"DAY*\"\n\nfind . -name \"DAY*\" -type d\nfind . -name \"DAY*\" -type f\n\n\n‘.’은 현재 디렉토리 내의 모든 파일, -name은 이름으로 찾는 것, “DAY*”는 DAY라는 형식으로 이루어진 모든 파일임을 말한다.\n-type d는 디렉토리로, -type f는 파일로 찾는다는 것을 말한다.\n\nfind . -empty\n\n\n-empty를 이용해 빈 파일을 찾는 데에 사용할 수 있다.\n\nfind . -size +100M\n\n\n-size를 이용해 특정 크기 이상, 이하의 파일을 찾는 데에 사용할 수 있다.\n\nfind . -name \"DAY*\" -exec ls -l {} \\;\n\n\n-exec를 이용해 부가적인 작업의 수행이 가능하다.\n검색된 파일이 {} 위치에 들어오게 되고, 추가적인 작업을 이어나가면 된다.\n\n3-3. 디렉토리 생성 ∙ 삭제\n\nmkdir ABC\nrm -rf ABC\n\n\nmkdir를 이용해 뒤에 나오는 단어의 이름으로 디렉토리를 생성할 수 있다.\nrm을 이용해 파일 및 디렉토리의 삭제가 가능하다. 단, 디렉토리의 삭제를 위해서는 -r이라는 옵션이 들어가야하고, -f라는 옵션을 함께 사용하면, 경고 없이 모두 강제로 삭제된다.\n\n3-4. 경로에서 파일명 가져오기\n\ndirname=`basename $dir`\n\n\nbasename을 이용하면 특정 경로를 나타내는 값들의 마지막 부분,\n예를 들면, home/ABC/backup/test.txt와 같은 상황에서 test.txt만 나오도록 할 수 있다.\n위 코드의 경우, ` dirname=```의 형태를 갖고 있는데, 이렇게 할 경우,  dirname이라는 변수가 만들어지고, $dirname로 활용할 수 있다.\n\n3-5. 문자열 일부 가져오기\n\ndirnum=${dirname:3}\n\n# dirname : \"HELLO WORLD\"\n# dirnum : LO WORLD\n\n\ndirname의 값으로 나오는 문자열 중, 네 번째(3+1)의 값부터 문자열을 잘라 표현해준다. 즉, 뒤에 나오는 숫자에 맞는 순서의 문자부터 그 뒤의 값들을 보여준다.\n\n3-6. 조건문 사용하기 - if\n\nif [ -f $filename ]\nthen\n  ...\nelse\n\t...\nfi\n\n\nif 의 내부에 값이 true일 경우, then의 다음에 오는 과정들을 처리하고, 아닐경우 else의 뒤에 오는 과정들을 처리한다. 이 과정을 fi가 나올 때까지 진행한다.\n조건문의 여러 상황에 대해 정리된 자료 링크가 있어 아래에 추가적으로 적는다.\n\n# if 여러 상황에 대해서\n[ -z ${A} ] : A 문자열의 길이가 0이면 TRUE\n[ -n ${A} ] : A 문자열의 길이가 0이 아니면 TRUE\n[ ${A} -eq ${B} ] : A와 B값이 같으면 TRUE\n[ ${A} -ne ${B} ] : A와 B값이 다르면 TRUE\n[ ${A} -gt ${B} ] : A가 B보다 크면 TRUE\n[ ${A} -ge ${B} ] : A가 B보다 크거나 같으면 TRUE\n[ ${A} -lt ${B} ] : A가 B보다 작으면 TRUE\n[ ${A} -le ${B} ] : A가 B보다 작거나 같으면 TRUE\n\n[ 조건식A -a 조건식B ] : 조건식 A와 B가 모두 TRUE이면 TRUE (&amp;&amp; 와 동일)\n[ 조건식A -o 조건식B ] : 조건식 A가 TRUE거나 조건식B가 TRUE면 TRUE (|| 와 동일)\n\n파일관련\n[ -d ${A} ] : A 파일이 디렉토리면 TRUE\n[ -e ${A} ] : A 파일이(노드, 디렉토리, 소켓 등등 모두) 존재하면 TRUE\n[ -L ${A} ] : A 파일이 심볼릭 링크면 TRUE\n[ -r ${A} ] : A 파일이 읽기 가능하면 TRUE\n[ -s ${A} ] : A 파일의 크기가 0 보다 크면 TRUE\n[ -w ${A} ] : A 파일이 쓰기 가능하면 TRUE\n[ -x ${A} ] : A 파일이 실행 가능하면 TRUE\n[ -c ${A} ] : A 파일이 Special character file 이면 TRUE\n[ -f ${A} ] : A 파일이 디렉토리가 아닌 일반 regular 파일이면 TRUE\n[ -S ${A} ] : A 파일이 소켓이면 TRUE\n[ ${A} -nt ${B} ] : A 파일 B 파일보다 최신파일이면 참\n[ ${A} -ot ${B} ]  : A 파일이 B 파일보다 이전파일이면 참\n[ ${A} -ef ${B} ] : A 파일과 B 파일이 같은 파일이면 참\n\n\n3-7. 결과값 표시 - echo\n\necho text or 변수명\n\n\n적혀진 텍스트, 혹은 변수의 값을 표현해준다.\nJavaScript의 console.log와 같은 역할을 한다고 볼 수 있어, Shell Script 사용 시 사용자에게 보여주어야 할 메세지가 있을 때에도 사용할 수 있다.\n\n3-8. 시간 구하기 - date\n\ndate\n\nday=`date +%Y%m%d`\n\n\ndate라고 작성할 시 2022년 1월 10일 월요일 01시 51분 38초 KST 와 같이 결과값이 나오게 된다.\n위의 코드같은 경우, 결과 값으로 20220110가 나오게 되며, 이를 활용해 다양한 날짜의 표현이 가능하다. 세세한 여러 표현 방법을 알려주는 링크를 참고하면 좋을 듯 하다.\n\n3-9. 파일 압축하기 - zip\n\nzip BACKUP_$day.zip ./BEFORE_ZIP\n\nzip AAA.zip -r ./*\n\n\nzip “파일이름” “압축할 디렉토리” 의 순서로 작성하면 된다.\n두 번째와 같이 -r을 작성하면 현재폴더의 모든 것 및 하위 폴더들도 모두 압축하게 된다.\n\n3-10. 다른 서버로의 파일 전송 - scp\n\n# 로컬에서 원격\nscp [전송할 파일 경로] [유저명]@[IP주소]:[받을 경로]\n\n# 원격에서 로컬\nscp [유저명]@[IP주소]:[전송할 파일 경로] [받을 경로]\n\n# 원격에서 원격\nscp [유저명]@[IP주소]:[전송할 파일 경로] [유저명]@[IP주소]:[받을 경로]\n\n\nscp ./BACKUP_$day.zip $ubuntuserver:backup와 같이 작성하면, 내 서버내의 특정 파일을 다른 원격으로 보내는 경우로, 첫 번째 예시의 사례와 같다.\n\n\n\n링크\n\n\n  쉘 스크립트 생성\nhttps://jaynamm.tistory.com/entry/Shell-Script-Shell-Script-생성-및-실행\nhttps://rrecoder.tistory.com/62\n  쉘 스크립트 scp 간단 사용법\nhttps://doheejin.github.io/linux/2021/03/03/linux-scp.html\n  터미널 디렉토리, 파일 삭제 방법\nhttps://www.delftstack.com/ko/howto/linux/how-to-delete-files-and-directories-in-linux-terminal/\n\n",
        "url": "/dev/2022/01/09/%EC%89%98/"
      },
    
      {
        "title": "LINKED LIST",
        "feature_text": "연결리스트의 특징 및 구현 방법\n",
        "excerpt": "1. 배열과 연결리스트의 장단점 비교\n\n1-1. 배열\n\n\n  장점 : 랜덤 엑세스가 빠르다.\n  단점 : 메모리 사용이 비효율적이다. 배열 내 데이터 이동 및 재구성이 어렵다.\n\n\n1-2. 연결리스트\n\n\n  장점 : 동적 메모리 사용이 가능하다. 메모리 사용이 효율적이다. 대용량 데이터 처리에 적합하다.\n  단점 : 특정 위치 데이터 검색 시 느리다. 메모리의 추가적인 사용이 필요하다.\n\n\n\n\n2. 노드\n\n\n   \n\n\n연결리스트는 ‘노드’라는 객체로 이루어져 있다.\n노드는 저장할 공간과 다음 주소를 가리킬 공간으로 나뉘게 된다.\n입력 정보를 위의 DATA 영역에 담고 노드가 추가될 때 NEXT ADDRESS를 이용해 다음 노드와 연결하게 된다.\n\n\n   \n\n\n각 노드는 연속된 공간이 아닌 메모리의 여러 부분에 분포되어 있다.\n노드마다 NEXT ADDRESS를 저장해 다음 노드로 갈 수 있다.\n마지막 노드는 다음 주소가 NULL로 표시된다.\n\n\n\n3. 연결리스트 구현\n\n‘초기화(init)’, ‘삽입(insert)’, ‘삭제(remove)’를 진행할 수 있는 함수가 필요하다.\n\n3-1. 초기화\n\n처음에 노드를 생성하는 과정을 말한다.\n노드에 접근하기 위해서 맨 처음 노드 주소를 가리킬 노드가 필요하다.(HEAD)\n\n\n   \n\n\n3-2. 삽입\n\nA. 앞에 삽입하는 경우\n\nHEAD의 뒤에서 처리가 이루어지게 된다.\n’새로운 노드의 NEXT → 현재 HEAD의 NEXT’\n’HEAD의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어지게 되며 아래의 그림과 같은 방식이 된다.\n\n\n   \n\n\nB. 뒤에 삽입하는 경우\n\n앞의 과정과 반대로, HEAD대신 TAIL을 사용한다.\n’새로운 노드의 NEXT → NULL’,\n’TAIL의 NEXT의 NEXT’ → ‘새로운 노드의 DATA’,\n’TAIL의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어지며, 아래의 그림과 같이 된다.\n\n\n   \n\n\nC. 원하는 위치에 삽입하는 경우\n\n특정 위치에 삽입할 경우(여기서는 FIRST와 SECOND사이), 삽입할 위치를 찾는 노드(LOCATION)가 먼저 필요하다.\n이전에는 HEAD, TAIL과 같은 위치가 있는 노드가 있었지만, 지금은 없는 경우이므로 직접적인 설정이 필요하다.\n’LOCATION의 NEXT → FIRST의 DATA’,\n’새로운 노드의 NEXT → SECOND의 DATA’,\n’FIRST의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어진다.\n\n\n   \n\n\n3-3. 삭제\n\n원하는 위치에 삽입하는 경우와 비슷하다.\n그러나, 삭제할 노드(DELETE)의 전 ∙ 후를 연결해야 하기에 새로운 노드(PRE)가 필요하다.\n’LOCATION의 NEXT → DELETE의 DATA’,\n’PRE의 NEXT의 NEXT → DELETE의 NEXT’,\n’DELETE를 삭제’\n의 순서로 이루어지며 아래 그림의 형태와 같다.\n\n\n   \n\n\n\n\n링크\n\n\n  연결리스트 안내\nhttps://sycho-lego.tistory.com/17\n\n",
        "content": "1. 배열과 연결리스트의 장단점 비교\n\n1-1. 배열\n\n\n  장점 : 랜덤 엑세스가 빠르다.\n  단점 : 메모리 사용이 비효율적이다. 배열 내 데이터 이동 및 재구성이 어렵다.\n\n\n1-2. 연결리스트\n\n\n  장점 : 동적 메모리 사용이 가능하다. 메모리 사용이 효율적이다. 대용량 데이터 처리에 적합하다.\n  단점 : 특정 위치 데이터 검색 시 느리다. 메모리의 추가적인 사용이 필요하다.\n\n\n\n\n2. 노드\n\n\n   \n\n\n연결리스트는 ‘노드’라는 객체로 이루어져 있다.\n노드는 저장할 공간과 다음 주소를 가리킬 공간으로 나뉘게 된다.\n입력 정보를 위의 DATA 영역에 담고 노드가 추가될 때 NEXT ADDRESS를 이용해 다음 노드와 연결하게 된다.\n\n\n   \n\n\n각 노드는 연속된 공간이 아닌 메모리의 여러 부분에 분포되어 있다.\n노드마다 NEXT ADDRESS를 저장해 다음 노드로 갈 수 있다.\n마지막 노드는 다음 주소가 NULL로 표시된다.\n\n\n\n3. 연결리스트 구현\n\n‘초기화(init)’, ‘삽입(insert)’, ‘삭제(remove)’를 진행할 수 있는 함수가 필요하다.\n\n3-1. 초기화\n\n처음에 노드를 생성하는 과정을 말한다.\n노드에 접근하기 위해서 맨 처음 노드 주소를 가리킬 노드가 필요하다.(HEAD)\n\n\n   \n\n\n3-2. 삽입\n\nA. 앞에 삽입하는 경우\n\nHEAD의 뒤에서 처리가 이루어지게 된다.\n’새로운 노드의 NEXT → 현재 HEAD의 NEXT’\n’HEAD의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어지게 되며 아래의 그림과 같은 방식이 된다.\n\n\n   \n\n\nB. 뒤에 삽입하는 경우\n\n앞의 과정과 반대로, HEAD대신 TAIL을 사용한다.\n’새로운 노드의 NEXT → NULL’,\n’TAIL의 NEXT의 NEXT’ → ‘새로운 노드의 DATA’,\n’TAIL의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어지며, 아래의 그림과 같이 된다.\n\n\n   \n\n\nC. 원하는 위치에 삽입하는 경우\n\n특정 위치에 삽입할 경우(여기서는 FIRST와 SECOND사이), 삽입할 위치를 찾는 노드(LOCATION)가 먼저 필요하다.\n이전에는 HEAD, TAIL과 같은 위치가 있는 노드가 있었지만, 지금은 없는 경우이므로 직접적인 설정이 필요하다.\n’LOCATION의 NEXT → FIRST의 DATA’,\n’새로운 노드의 NEXT → SECOND의 DATA’,\n’FIRST의 NEXT → 새로운 노드의 DATA’\n의 형태로 이루어진다.\n\n\n   \n\n\n3-3. 삭제\n\n원하는 위치에 삽입하는 경우와 비슷하다.\n그러나, 삭제할 노드(DELETE)의 전 ∙ 후를 연결해야 하기에 새로운 노드(PRE)가 필요하다.\n’LOCATION의 NEXT → DELETE의 DATA’,\n’PRE의 NEXT의 NEXT → DELETE의 NEXT’,\n’DELETE를 삭제’\n의 순서로 이루어지며 아래 그림의 형태와 같다.\n\n\n   \n\n\n\n\n링크\n\n\n  연결리스트 안내\nhttps://sycho-lego.tistory.com/17\n\n",
        "url": "/dev/2022/01/10/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/"
      },
    
      {
        "title": "DATA CONSTRUCTOR",
        "feature_text": "자료 구조에 대한 큰 흐름 보기\n",
        "excerpt": "여기서는 간략하게 비선형 구조, 선형 구조로 나누어 살펴본다.\n추후에 더 자세한 정리가 이루어지면 링크를 걸어놓을 예정이다.\n\n1. 비선형 구조\n\n하나의 데이터 안에 여러 개의 자료가 존재할 수 있는 것을 말한다.\n\nA. 트리\n\n정점과 선분을 이용해 사이클을 이루지 않도록 구성한 그래프 형태로, 방향성이 존재해 부모 ∙ 자식 계층 구조가 명확하다.\n\n\n   \n\n\nB. 그래프\n\n정점, 선분을 이용해 사이클을 이루도록 구성한 것으로, 순환이 가능하다.\n\n\n   \n\n\n\n\n2. 선형 구조\n\n자료를 구성하는 데이터를 순차적으로 나열한 형태를 말한다.\n종류로는 배열(선형 리스트), 연결 리스트, 스택, 큐, 테크 등이 있다.\n포인터 등을 사용해 자료를 연결하면 그 결과가 일직선 상에 표시되거나 하나의 원상에 표시된다.\n\nA. 배열 (Array)\n\n인덱스를 갖고 있으며, 순차적으로 데이터가 삽입, 삭제될 수 있는 구조이다.\n데이터의 순차적 삽입, 삭제 시 가장 효과적이다.\n인덱스를 사용해 검색이 빠르다는 장점이 있지만, 중간 삽입 ∙ 삭제가 어렵다는 단점이 있다.\n\nB. 연결리스트 (Linked List)\n\n자료 항목 순서에 따라 노드의 포인터 부분을 이용해 서로 연결한 구조이다.\n 노드의 삽입, 삭제 작업이 용이하며, 기억 공간이 연속적으로 놓이지 않아도 저장이 가능하다.\n 중간 삽입 ∙ 삭제가 빠르고 용이하다는 장점이 있지만, 접근 속도가 느리며 중간 노드 연결이 끊어질 시 다음 노드를 찾기 어렵다는 단점이 있다.\n\n\n   \n\n\nC. 스택 (Stack)\n\n리스트의 한 쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 구조이다.\nLast In, First Out / 인터럽트가 발생하여 복귀주소를 저장할 때 사용한다.\n스택의 용도로 7가지가 있다.\n\n\n  부 프로그램 호출 시 복귀주소 저장\n  함수 호출 순서 제어\n  인터럽트가 발생해 복귀 주소 저장 시\n  후위 표기법으로 표현된 산술식 연산\n  0 주소 지정방식 명령어 자료 저장소\n  재귀 프로그램 순서 제어\n  컴파일러를 이용한 언어 번역\n\n\n\n   \n\n\nD. 큐 (Queue)\n\n한 쪽에서는 삽입, 다른 쪽에서는 삭제가 이루어지는 구조이다.\n시작과 끝을 표시하는 두 개의 포인터가 존재한다.\n\n\n   \n\n\nE. 데크 (DEQ : Double Ended Queue)\n\n스택, 큐의 장점만을 갖고 만든 것으로, 삽입과 삭제가 리스트 양쪽에서 모두 발생하는 구조이다.\n입력이 한쪽, 출력이 양쪽에서 일어나는 입력제한과 입력이 양쪽, 출력이 한쪽에서 일어나는 출력제한이 있다.\n\n\n\n링크\n\n\n  데이터 구조 안내\nhttps://dnf-lover.tistory.com/entry/자료구조-자료구조의-선형-비선형-분류에-따른-각-종류와-자료구조별-특징-간단-정리\nhttps://server-engineer.tistory.com/130\n  생활코딩 : 자료구조 안내\nhttps://opentutorials.org/module/1335/8821\n\n",
        "content": "여기서는 간략하게 비선형 구조, 선형 구조로 나누어 살펴본다.\n추후에 더 자세한 정리가 이루어지면 링크를 걸어놓을 예정이다.\n\n1. 비선형 구조\n\n하나의 데이터 안에 여러 개의 자료가 존재할 수 있는 것을 말한다.\n\nA. 트리\n\n정점과 선분을 이용해 사이클을 이루지 않도록 구성한 그래프 형태로, 방향성이 존재해 부모 ∙ 자식 계층 구조가 명확하다.\n\n\n   \n\n\nB. 그래프\n\n정점, 선분을 이용해 사이클을 이루도록 구성한 것으로, 순환이 가능하다.\n\n\n   \n\n\n\n\n2. 선형 구조\n\n자료를 구성하는 데이터를 순차적으로 나열한 형태를 말한다.\n종류로는 배열(선형 리스트), 연결 리스트, 스택, 큐, 테크 등이 있다.\n포인터 등을 사용해 자료를 연결하면 그 결과가 일직선 상에 표시되거나 하나의 원상에 표시된다.\n\nA. 배열 (Array)\n\n인덱스를 갖고 있으며, 순차적으로 데이터가 삽입, 삭제될 수 있는 구조이다.\n데이터의 순차적 삽입, 삭제 시 가장 효과적이다.\n인덱스를 사용해 검색이 빠르다는 장점이 있지만, 중간 삽입 ∙ 삭제가 어렵다는 단점이 있다.\n\nB. 연결리스트 (Linked List)\n\n자료 항목 순서에 따라 노드의 포인터 부분을 이용해 서로 연결한 구조이다.\n 노드의 삽입, 삭제 작업이 용이하며, 기억 공간이 연속적으로 놓이지 않아도 저장이 가능하다.\n 중간 삽입 ∙ 삭제가 빠르고 용이하다는 장점이 있지만, 접근 속도가 느리며 중간 노드 연결이 끊어질 시 다음 노드를 찾기 어렵다는 단점이 있다.\n\n\n   \n\n\nC. 스택 (Stack)\n\n리스트의 한 쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 구조이다.\nLast In, First Out / 인터럽트가 발생하여 복귀주소를 저장할 때 사용한다.\n스택의 용도로 7가지가 있다.\n\n\n  부 프로그램 호출 시 복귀주소 저장\n  함수 호출 순서 제어\n  인터럽트가 발생해 복귀 주소 저장 시\n  후위 표기법으로 표현된 산술식 연산\n  0 주소 지정방식 명령어 자료 저장소\n  재귀 프로그램 순서 제어\n  컴파일러를 이용한 언어 번역\n\n\n\n   \n\n\nD. 큐 (Queue)\n\n한 쪽에서는 삽입, 다른 쪽에서는 삭제가 이루어지는 구조이다.\n시작과 끝을 표시하는 두 개의 포인터가 존재한다.\n\n\n   \n\n\nE. 데크 (DEQ : Double Ended Queue)\n\n스택, 큐의 장점만을 갖고 만든 것으로, 삽입과 삭제가 리스트 양쪽에서 모두 발생하는 구조이다.\n입력이 한쪽, 출력이 양쪽에서 일어나는 입력제한과 입력이 양쪽, 출력이 한쪽에서 일어나는 출력제한이 있다.\n\n\n\n링크\n\n\n  데이터 구조 안내\nhttps://dnf-lover.tistory.com/entry/자료구조-자료구조의-선형-비선형-분류에-따른-각-종류와-자료구조별-특징-간단-정리\nhttps://server-engineer.tistory.com/130\n  생활코딩 : 자료구조 안내\nhttps://opentutorials.org/module/1335/8821\n\n",
        "url": "/dev/2022/01/10/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"
      },
    
      {
        "title": "SOCKET 연결 및 채팅",
        "feature_text": "SockJS, StompJS를 활용한 채팅 설정하기\n",
        "excerpt": "채팅과 관련된 기능들을 구현하면서 백엔드와의 협의 후 Sock.JS와 Stomp.JS를 사용하게 됐습니다. 이 두 가지를 사용하기에 앞서 두 가지가 어떠한 역할을 하는지, 왜 이것들을 써야하는지 간단하게 살펴보고 어떻게 사용하는 지 적어보고자 합니다.\n\nWeb Socket\n\nTCP 연결에 완전 이중 통신 채널을 제공하는 컴퓨터 프로토콜입니다. 일반적인 서버 - 클라이언트의 관계가 stateless인 것에 반해, Web Socket은 stateful한 방식을 사용해, 지속적인 연결이 이루어지게 됩니다.\n\n서버 - 클라이언트간 웹소켓 연결은 HTTP 프로토콜을 통해 이루어지며, 연결의 시작은 클라이언트가 서버로 random key를 보냅니다. 이후 서버에서 random key를 통해 토큰을 만든 뒤, 클라이언트에 response를 보내고, 이를 통해 handshake 과정이 이루어져서 양방향 통신이 진행됩니다.\n\n서버 - 클라이언트간 웹소켓 연결(TCP/IP)이 이루어지고 일정 시간이 지나면 HTTP 연결은 자동으로 끊어지게 됩니다.\n\nSockJS\n\n(큰 도움을 주신 사이트)\n\n브라우저에서 web socket을 지원하지 않는 경우에도 web socket을 사용 가능하게 해주는 WebSocket Emulation으로서 사용되는 라이브러리입니다.\n브라우저와 서버 사이의 짧은 지연시간, 크로스 브라우징의 지원이 장점입니다.\n(현재 서버에서는 Spring을 사용하고 있어, Sock JS를 사용했으며, 서버에서 Node.js를 사용할 경우, Socket.io를 사용합니다.)\n구성과 전송타입은 아래와 같고 추후에 아래 내용들을 자세히 정리할 예정입니다!\n\n구성\n\n\n  SockJS Protocol\n  SockJS Javascript Client: 브라우저용 클라이언트 라이브러리\n  SockJS Server: Spring-websocket 모듈로 제공\n  SockJS Java Client: Spring-websocket 모듈로 제공\n\n\n전송 타입\n\n\n  WebSocket\n  HTTP Streaming\n  HTTP Long Polling\n\n\nStompJS\n\n(추후 참고할 만한 링크)\n\n웹소켓의 서브 프로토콜로서, 프로토콜 연결, 메세지 전송, 상대방 구독 기능을 제공하는 텍스트 기반 메세지 프로토콜입니다. stomp를 이용하면 여러 개의 채팅방 개설이 가능하다는 장점이 있습니다.\n\n서버가 Spring을 사용할 경우, 보통 SockJS, StompJS 이 두 가지를 통해 소켓 연결을 진행하게 됩니다.\n\n사용\n\n설치\n\n아래 코드를 통해서 기본적인 sockjs, stompjs를 설치할 수 있습니다.\n\nnpm install --save-dev sockjs-client stompjs\n\n\nSockJS, StompJS 연결\n\n이후 주소를 설정하고 Sock을 새로 만든 뒤, 이를 Stomp Client 위에서 작동할 수 있도록 설정합니다.\n\nimport SockJs from \"sockjs-client\";\nimport StompJs from \"stompjs\";\n\n// 들어갈 주소 설정\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`;\nconst sock = new SockJs(sockServer);\nconst stompClient = StompJs.over(sock);\n\n\nStomp Client로 서버에 연결 요청\n\nStomp Client에 연결을 요청하고, 해당 요청이 성공적일 시 구독으로 진행할 작업을 적어줍니다.\n\nconst connectChatroom = (subscribeParams: subscribeParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  // 현재 서버에서 확인을 위해 필요로 하는 헤더\n\n  try {\n    // stompClient.debug = () =&gt; null;\n    // console 창에 나오게 되는 내용들이 보이지 않도록 함\n    stompClient.connect(headers, () =&gt; subscribeChat(subscribeParams));\n    // 연결을 시도함\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\n원하는 주소로 구독 및 메세지 올 때 처리하기\n\nsubscribeChat이라는 함수를 따로 만들어, Stomp Client가 연결에 성공할 시 진행할 작업을 따로 빼내어 정리해주었습니다. stompClient.connect를 통해서 연결이 이루어지게 되는데, 이는 서버에 connect 프레임을 전송하는 것으로, 이 프레임에 header, body를 넣을 수 있고 현재는 header만 보낸 상황입니다.\n\nconst subscribeChat = ({\n  onReceive,\n  chatroomId,\n  chatroomIds,\n}: subscribeParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  const subscribeToStomp = (id: string | number) =&gt; {\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n    // 서버와 협의된 구독 URL\n    stompClient.subscribe(subscribeURL, onReceive, headers);\n    // Stomp Client에서 구독 후, 이후 메세지가 올 시 처리할 값을 onReceive 함수로 처리함\n  };\n\n  // id값이 한 개일 때, 여러 개일 때를 구분해서 구독을 진행하도록 설정\n  if (chatroomId) subscribeToStomp(chatroomId);\n  if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n};\n\n\n현재 앱의 특성상 id값을 하나만 받는 경우(채팅 상세에 들어갈 시), id값을 여러 개 받는 경우(모든 채팅의 알림을 받을 시)에 대해 같은 형식의 처리가 이루어지기 때문에 아래와 같이 같은 함수 내에서 구분해 처리하도록 했습니다.\n\nsubscribeURL을 통해서 구독할 주소를 설정하게 되고, 이후 그 주소를 통해 등록한 곳으로부터 메세지가 오면 onReceive 함수를 통해 처리를 할 수 있게 됩니다.\n\n구독 끊기\n\nconst unsubscribe = () =&gt; {\n  stompClient.unsubscribe(\"sub-0\");\n};\n\n\nunsubscribe 함수를 통해 구독을 끊을 수 있으며, 서버와의 연결 해제가 아닌 해당 주소에 대한 구독만 끊어내는 개념으로 볼 수 있습니다.\n\n연결 끊기\n\nconst disconnectChatroom = () =&gt; {\n  try {\n    // stompClient.debug = () =&gt; null;\n    stompClient.disconnect(() =&gt; unsubscribe());\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\ndiconnect를 통해서 서버와의 연결을 해제할 수 있으며, 이 때에도 콜백 함수를 통해 특정 작업을 진행할 수 있습니다.\n\n\n\n추가적인 문제\n\n(위에 반영되었습니다.)\n\n아래의 코드로 호출 시 하나의 구독 주소에 여러번 접근하는 형식이 적용되어, 문제가 발생합니다.\n\nconst useChatAlarm = () =&gt; {\n  const { state, contents } = useRecoilValueLoadable(chatroomIdsState);\n\n  return () =&gt; {\n    useEffect(() =&gt; {\n      if (state !== \"hasValue\" || !contents) return;\n      contents?.forEach(({ id }) =&gt; {\n        const { connectChatroom } = chatSocket();\n        connectChatroom({ chatroomId: id });\n      });\n    }, [state]);\n  };\n};\n\nconst subscribeChat = ({ setter, chatroomId }: subscribeParamsType) =&gt; {\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${chatroomId}`;\n  // 하나의 id만 등록이 가능함\n  const headers = getAuthHeaders();\n\n  // 이 부분을 forEach로 반복하기 때문에, 같은 주소(subscribeURL)에 반복적인 요청이 들어가게 됨\n  stompClient.subscribe(\n    subscribeURL,\n    // 콜백 함수가 직접적으로 들어가 있어, 다른 작업이 필요한 경우, 이 곳을 직접적으로 고쳐야 함\n    (chatData) =&gt; {\n      const newChat = JSON.parse(chatData.body);\n      setter((chats) =&gt; {\n        const newChats = [...chats, newChat];\n        return newChats;\n      });\n    },\n    headers\n  );\n};\n\n\n\n   \n\n\n사진과 같이 같은 주소에 대한 여러 번의 호출로 인해 연결이 끊겨버린다는 문제가 발생합니다.\n\n해결 방법\n\n1. onSet 함수 및 주소 분리\n\ntype subscribeParamsType = {\n  onSet: (chatData: StompJs.Message) =&gt; void;\n  chatroomId?: string | number;\n  chatroomIds?: string[] | number[];\n};\n\nconst subscribeChat = ({ onSet, chatroomId, chatroomIds }: subscribeParamsType) =&gt; {\n  const subscribeToStomp = (id: string | number) =&gt; {\n    const headers = getAuthHeaders();\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n\t\t// id 값에 따라 주소가 나뉠 수 있도록 공통 함수를 설정\n    stompClient.subscribe(subscribeURL, onSet, headers);\n\t\t// subscribe 내에서 콜백(onSet)을 만드는 것이 아니라 이를 분리해 외부에서 적용하도록\n  };\n\t...\n};\n\n\nchatroomId의 개수가 늘어나는 경우에 대해서 이전 코드에서는 제대로 된 해결책이 없어 우선 이 사항부터 해결하기 위해 onSet이라는 set이 발생했을 때의 함수를 먼저 따로 빼냈습니다. 이로 인해 set이 발생했을 때의 사항에 대해서는 직접적으로 사용하는 곳에서 처리를 하도록 빼낼 수 있었고, 아래 코드와 같이 사용하는 곳에서 set 상황을 컨트롤 할 수 있게 됐습니다.\n\nconst getNewChatMessage = (chatData: StompJs.Message) =&gt; {\n  const newChat = JSON.parse(chatData.body);\n  setCurChats((chats) =&gt; {\n    const newChats = [...chats, newChat];\n\n    return newChats;\n  });\n};\n// onSet 함수로, 들어온 값에 대해 새로운 채팅에 추가하는 함수\n\nuseEffect(() =&gt; {\n  const { disconnectChatroom, connectChatroom } = chatroomSocket();\n  connectChatroom({ onSet: getNewChatMessage, chatroomId });\n  // 연결할 때 함수를 대입\n  return () =&gt; disconnectChatroom();\n}, []);\n\n\n2. id 개수에 따른 상황 분리\n\nid가 하나인 경우와 여러개인 경우에 대해서 구독하는 방식이 약간의 차이가 존재하는데, 이를 해결하기 위해 상황별로 구독하는 방법을 바꾸도록 설정해 문제를 해결했습니다.\n\nif (chatroomId) subscribeToStomp(chatroomId);\nif (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n\n",
        "content": "채팅과 관련된 기능들을 구현하면서 백엔드와의 협의 후 Sock.JS와 Stomp.JS를 사용하게 됐습니다. 이 두 가지를 사용하기에 앞서 두 가지가 어떠한 역할을 하는지, 왜 이것들을 써야하는지 간단하게 살펴보고 어떻게 사용하는 지 적어보고자 합니다.\n\nWeb Socket\n\nTCP 연결에 완전 이중 통신 채널을 제공하는 컴퓨터 프로토콜입니다. 일반적인 서버 - 클라이언트의 관계가 stateless인 것에 반해, Web Socket은 stateful한 방식을 사용해, 지속적인 연결이 이루어지게 됩니다.\n\n서버 - 클라이언트간 웹소켓 연결은 HTTP 프로토콜을 통해 이루어지며, 연결의 시작은 클라이언트가 서버로 random key를 보냅니다. 이후 서버에서 random key를 통해 토큰을 만든 뒤, 클라이언트에 response를 보내고, 이를 통해 handshake 과정이 이루어져서 양방향 통신이 진행됩니다.\n\n서버 - 클라이언트간 웹소켓 연결(TCP/IP)이 이루어지고 일정 시간이 지나면 HTTP 연결은 자동으로 끊어지게 됩니다.\n\nSockJS\n\n(큰 도움을 주신 사이트)\n\n브라우저에서 web socket을 지원하지 않는 경우에도 web socket을 사용 가능하게 해주는 WebSocket Emulation으로서 사용되는 라이브러리입니다.\n브라우저와 서버 사이의 짧은 지연시간, 크로스 브라우징의 지원이 장점입니다.\n(현재 서버에서는 Spring을 사용하고 있어, Sock JS를 사용했으며, 서버에서 Node.js를 사용할 경우, Socket.io를 사용합니다.)\n구성과 전송타입은 아래와 같고 추후에 아래 내용들을 자세히 정리할 예정입니다!\n\n구성\n\n\n  SockJS Protocol\n  SockJS Javascript Client: 브라우저용 클라이언트 라이브러리\n  SockJS Server: Spring-websocket 모듈로 제공\n  SockJS Java Client: Spring-websocket 모듈로 제공\n\n\n전송 타입\n\n\n  WebSocket\n  HTTP Streaming\n  HTTP Long Polling\n\n\nStompJS\n\n(추후 참고할 만한 링크)\n\n웹소켓의 서브 프로토콜로서, 프로토콜 연결, 메세지 전송, 상대방 구독 기능을 제공하는 텍스트 기반 메세지 프로토콜입니다. stomp를 이용하면 여러 개의 채팅방 개설이 가능하다는 장점이 있습니다.\n\n서버가 Spring을 사용할 경우, 보통 SockJS, StompJS 이 두 가지를 통해 소켓 연결을 진행하게 됩니다.\n\n사용\n\n설치\n\n아래 코드를 통해서 기본적인 sockjs, stompjs를 설치할 수 있습니다.\n\nnpm install --save-dev sockjs-client stompjs\n\n\nSockJS, StompJS 연결\n\n이후 주소를 설정하고 Sock을 새로 만든 뒤, 이를 Stomp Client 위에서 작동할 수 있도록 설정합니다.\n\nimport SockJs from \"sockjs-client\";\nimport StompJs from \"stompjs\";\n\n// 들어갈 주소 설정\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`;\nconst sock = new SockJs(sockServer);\nconst stompClient = StompJs.over(sock);\n\n\nStomp Client로 서버에 연결 요청\n\nStomp Client에 연결을 요청하고, 해당 요청이 성공적일 시 구독으로 진행할 작업을 적어줍니다.\n\nconst connectChatroom = (subscribeParams: subscribeParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  // 현재 서버에서 확인을 위해 필요로 하는 헤더\n\n  try {\n    // stompClient.debug = () =&gt; null;\n    // console 창에 나오게 되는 내용들이 보이지 않도록 함\n    stompClient.connect(headers, () =&gt; subscribeChat(subscribeParams));\n    // 연결을 시도함\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\n원하는 주소로 구독 및 메세지 올 때 처리하기\n\nsubscribeChat이라는 함수를 따로 만들어, Stomp Client가 연결에 성공할 시 진행할 작업을 따로 빼내어 정리해주었습니다. stompClient.connect를 통해서 연결이 이루어지게 되는데, 이는 서버에 connect 프레임을 전송하는 것으로, 이 프레임에 header, body를 넣을 수 있고 현재는 header만 보낸 상황입니다.\n\nconst subscribeChat = ({\n  onReceive,\n  chatroomId,\n  chatroomIds,\n}: subscribeParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  const subscribeToStomp = (id: string | number) =&gt; {\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n    // 서버와 협의된 구독 URL\n    stompClient.subscribe(subscribeURL, onReceive, headers);\n    // Stomp Client에서 구독 후, 이후 메세지가 올 시 처리할 값을 onReceive 함수로 처리함\n  };\n\n  // id값이 한 개일 때, 여러 개일 때를 구분해서 구독을 진행하도록 설정\n  if (chatroomId) subscribeToStomp(chatroomId);\n  if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n};\n\n\n현재 앱의 특성상 id값을 하나만 받는 경우(채팅 상세에 들어갈 시), id값을 여러 개 받는 경우(모든 채팅의 알림을 받을 시)에 대해 같은 형식의 처리가 이루어지기 때문에 아래와 같이 같은 함수 내에서 구분해 처리하도록 했습니다.\n\nsubscribeURL을 통해서 구독할 주소를 설정하게 되고, 이후 그 주소를 통해 등록한 곳으로부터 메세지가 오면 onReceive 함수를 통해 처리를 할 수 있게 됩니다.\n\n구독 끊기\n\nconst unsubscribe = () =&gt; {\n  stompClient.unsubscribe(\"sub-0\");\n};\n\n\nunsubscribe 함수를 통해 구독을 끊을 수 있으며, 서버와의 연결 해제가 아닌 해당 주소에 대한 구독만 끊어내는 개념으로 볼 수 있습니다.\n\n연결 끊기\n\nconst disconnectChatroom = () =&gt; {\n  try {\n    // stompClient.debug = () =&gt; null;\n    stompClient.disconnect(() =&gt; unsubscribe());\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\ndiconnect를 통해서 서버와의 연결을 해제할 수 있으며, 이 때에도 콜백 함수를 통해 특정 작업을 진행할 수 있습니다.\n\n\n\n추가적인 문제\n\n(위에 반영되었습니다.)\n\n아래의 코드로 호출 시 하나의 구독 주소에 여러번 접근하는 형식이 적용되어, 문제가 발생합니다.\n\nconst useChatAlarm = () =&gt; {\n  const { state, contents } = useRecoilValueLoadable(chatroomIdsState);\n\n  return () =&gt; {\n    useEffect(() =&gt; {\n      if (state !== \"hasValue\" || !contents) return;\n      contents?.forEach(({ id }) =&gt; {\n        const { connectChatroom } = chatSocket();\n        connectChatroom({ chatroomId: id });\n      });\n    }, [state]);\n  };\n};\n\nconst subscribeChat = ({ setter, chatroomId }: subscribeParamsType) =&gt; {\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${chatroomId}`;\n  // 하나의 id만 등록이 가능함\n  const headers = getAuthHeaders();\n\n  // 이 부분을 forEach로 반복하기 때문에, 같은 주소(subscribeURL)에 반복적인 요청이 들어가게 됨\n  stompClient.subscribe(\n    subscribeURL,\n    // 콜백 함수가 직접적으로 들어가 있어, 다른 작업이 필요한 경우, 이 곳을 직접적으로 고쳐야 함\n    (chatData) =&gt; {\n      const newChat = JSON.parse(chatData.body);\n      setter((chats) =&gt; {\n        const newChats = [...chats, newChat];\n        return newChats;\n      });\n    },\n    headers\n  );\n};\n\n\n\n   \n\n\n사진과 같이 같은 주소에 대한 여러 번의 호출로 인해 연결이 끊겨버린다는 문제가 발생합니다.\n\n해결 방법\n\n1. onSet 함수 및 주소 분리\n\ntype subscribeParamsType = {\n  onSet: (chatData: StompJs.Message) =&gt; void;\n  chatroomId?: string | number;\n  chatroomIds?: string[] | number[];\n};\n\nconst subscribeChat = ({ onSet, chatroomId, chatroomIds }: subscribeParamsType) =&gt; {\n  const subscribeToStomp = (id: string | number) =&gt; {\n    const headers = getAuthHeaders();\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n\t\t// id 값에 따라 주소가 나뉠 수 있도록 공통 함수를 설정\n    stompClient.subscribe(subscribeURL, onSet, headers);\n\t\t// subscribe 내에서 콜백(onSet)을 만드는 것이 아니라 이를 분리해 외부에서 적용하도록\n  };\n\t...\n};\n\n\nchatroomId의 개수가 늘어나는 경우에 대해서 이전 코드에서는 제대로 된 해결책이 없어 우선 이 사항부터 해결하기 위해 onSet이라는 set이 발생했을 때의 함수를 먼저 따로 빼냈습니다. 이로 인해 set이 발생했을 때의 사항에 대해서는 직접적으로 사용하는 곳에서 처리를 하도록 빼낼 수 있었고, 아래 코드와 같이 사용하는 곳에서 set 상황을 컨트롤 할 수 있게 됐습니다.\n\nconst getNewChatMessage = (chatData: StompJs.Message) =&gt; {\n  const newChat = JSON.parse(chatData.body);\n  setCurChats((chats) =&gt; {\n    const newChats = [...chats, newChat];\n\n    return newChats;\n  });\n};\n// onSet 함수로, 들어온 값에 대해 새로운 채팅에 추가하는 함수\n\nuseEffect(() =&gt; {\n  const { disconnectChatroom, connectChatroom } = chatroomSocket();\n  connectChatroom({ onSet: getNewChatMessage, chatroomId });\n  // 연결할 때 함수를 대입\n  return () =&gt; disconnectChatroom();\n}, []);\n\n\n2. id 개수에 따른 상황 분리\n\nid가 하나인 경우와 여러개인 경우에 대해서 구독하는 방식이 약간의 차이가 존재하는데, 이를 해결하기 위해 상황별로 구독하는 방법을 바꾸도록 설정해 문제를 해결했습니다.\n\nif (chatroomId) subscribeToStomp(chatroomId);\nif (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n\n",
        "url": "/javascript/2022/08/16/socket/"
      },
    
      {
        "title": "자동 스크롤을 위한 React의 Callback Ref",
        "feature_text": "자동 스크롤을 위한 React의 Callback Ref\n",
        "excerpt": "채팅을 구현하는 상황에서, 채팅의 경우 첫 렌더링 시 무조건 가장 하단의 채팅부터 보여주어야 하기 때문에, 이를 위해서 렌더링 후 바로 채팅의 하단을 보여주는 것을 구현했습니다.\n\n이 상황에서 기존에는 두 가지 방법을 사용했습니다.\n\n\n  window의 scroll 기능 사용하기\n  useEffect와 ref를 적용해 보여주기\n\n\nwindow.scrollTo(0, document.body.offsetHeight);\n\n\n두 방법 중 처음에는 위와 같이 1번의 방법을 사용했으나, 리액트의 특성을 살리지 못한다는 판단이 들어(document.body와 같은 부분에서), 2번의 방법을 시도했었습니다.\n\nuseEffect를 사용하고, 의존성에 ref를 부여하는 방법으로 원래 해결을 하려고 했으나, 이는 올바르지 않은 방법임을 곧 알게 됐습니다.\n\n왜냐하면, 렌더링을 건너뛰는useEffect 의 경우, 컴포넌트가 다시 렌더링이 이루어질 때까지 ref가 업데이트 된 것을 확인할 수가 없기 때문입니다. 즉, 이미 설정된 ref에 대해서는 useEffect 내부의 메소드가 작동하지만(원래 한 번 동작하므로), 이후에는 ref의 변경이 있어도, 그 순서가 useEffect보다 늦다면, 의존성 배열에 담아주어도 전혀 반응하지 않습니다.\n\n즉, ref를 useEffect에 넣는 것은 렌더링이 모두 이루어진 다음에 수행하는 데에 적합하지 않은 방식이기 때문에, ref의 지정에 따른 메소드를 수행하는 방법이 필요했습니다.\n\n그 과정에서 발견한 것이 callback ref라는 개념인데, 이는 React에 기본적으로 내장된 기능으로서, React Element의 ref props에 useCallback으로 설정된 함수를 넣어주는 경우, 해당 React Element가 파라미터가 되어, 해당 함수를 실행하게 됩니다.\n\n//**callback ref for scroll to bottom */\nconst scrollToBottomRef = useCallback((lastChatDiv: HTMLDivElement) =&gt; {\n  if (!lastChatDiv) return;\n  // change target only if last chat didn't exist\n  setLastChat((prevLastChat) =&gt; (prevLastChat ? prevLastChat : lastChatDiv));\n  lastChatDiv.scrollIntoView({ block: \"end\" });\n}, []);\n\n\n위 함수가 해당 기능을 하는 함수인데, 위와 같이 lastChatDiv라는 element를 받는 함수를 만들어, 해당 함수 내에 원하는 기능이 이루어지도록 했습니다.\n\n위 함수를 통해, 처음에 페이지에 진입하는 상황에 대해서 지정된 요소(가장 하단 요소)로 스크롤이 이루어지도록 만들었습니다.\n\nreturn (\n  &lt;S.Wrapper&gt;\n    &lt;S.Date&gt;2021년 5월 29일&lt;/S.Date&gt;\n    &lt;S.Chats&gt;\n      {chatroomLogs}\n      &lt;S.EmptyBlock ref={scrollToBottomRef} /&gt;\n      // 최하단에 만들어지는 빈 블록으로, 이 곳에 설정을 해주어 이 곳에 이동이\n      되도록 합니다.\n    &lt;/S.Chats&gt;\n  &lt;/S.Wrapper&gt;\n);\n\n",
        "content": "채팅을 구현하는 상황에서, 채팅의 경우 첫 렌더링 시 무조건 가장 하단의 채팅부터 보여주어야 하기 때문에, 이를 위해서 렌더링 후 바로 채팅의 하단을 보여주는 것을 구현했습니다.\n\n이 상황에서 기존에는 두 가지 방법을 사용했습니다.\n\n\n  window의 scroll 기능 사용하기\n  useEffect와 ref를 적용해 보여주기\n\n\nwindow.scrollTo(0, document.body.offsetHeight);\n\n\n두 방법 중 처음에는 위와 같이 1번의 방법을 사용했으나, 리액트의 특성을 살리지 못한다는 판단이 들어(document.body와 같은 부분에서), 2번의 방법을 시도했었습니다.\n\nuseEffect를 사용하고, 의존성에 ref를 부여하는 방법으로 원래 해결을 하려고 했으나, 이는 올바르지 않은 방법임을 곧 알게 됐습니다.\n\n왜냐하면, 렌더링을 건너뛰는useEffect 의 경우, 컴포넌트가 다시 렌더링이 이루어질 때까지 ref가 업데이트 된 것을 확인할 수가 없기 때문입니다. 즉, 이미 설정된 ref에 대해서는 useEffect 내부의 메소드가 작동하지만(원래 한 번 동작하므로), 이후에는 ref의 변경이 있어도, 그 순서가 useEffect보다 늦다면, 의존성 배열에 담아주어도 전혀 반응하지 않습니다.\n\n즉, ref를 useEffect에 넣는 것은 렌더링이 모두 이루어진 다음에 수행하는 데에 적합하지 않은 방식이기 때문에, ref의 지정에 따른 메소드를 수행하는 방법이 필요했습니다.\n\n그 과정에서 발견한 것이 callback ref라는 개념인데, 이는 React에 기본적으로 내장된 기능으로서, React Element의 ref props에 useCallback으로 설정된 함수를 넣어주는 경우, 해당 React Element가 파라미터가 되어, 해당 함수를 실행하게 됩니다.\n\n//**callback ref for scroll to bottom */\nconst scrollToBottomRef = useCallback((lastChatDiv: HTMLDivElement) =&gt; {\n  if (!lastChatDiv) return;\n  // change target only if last chat didn't exist\n  setLastChat((prevLastChat) =&gt; (prevLastChat ? prevLastChat : lastChatDiv));\n  lastChatDiv.scrollIntoView({ block: \"end\" });\n}, []);\n\n\n위 함수가 해당 기능을 하는 함수인데, 위와 같이 lastChatDiv라는 element를 받는 함수를 만들어, 해당 함수 내에 원하는 기능이 이루어지도록 했습니다.\n\n위 함수를 통해, 처음에 페이지에 진입하는 상황에 대해서 지정된 요소(가장 하단 요소)로 스크롤이 이루어지도록 만들었습니다.\n\nreturn (\n  &lt;S.Wrapper&gt;\n    &lt;S.Date&gt;2021년 5월 29일&lt;/S.Date&gt;\n    &lt;S.Chats&gt;\n      {chatroomLogs}\n      &lt;S.EmptyBlock ref={scrollToBottomRef} /&gt;\n      // 최하단에 만들어지는 빈 블록으로, 이 곳에 설정을 해주어 이 곳에 이동이\n      되도록 합니다.\n    &lt;/S.Chats&gt;\n  &lt;/S.Wrapper&gt;\n);\n\n",
        "url": "/react/2022/09/25/CallBackRef-copy/"
      },
    
      {
        "title": "깊이 우선 그래프 순회",
        "feature_text": "DFS를 사용해 그래프 순회하기\n",
        "excerpt": "트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다.\n\n여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다.\n\n\n  위키피디아의 링크 내 이동 시 최단 거리 찾기\n  페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능\n  GPS 네비게이션\n  미로 문제 풀기\n\n\nDFS 순회?\n\n그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다.\n\n핵심은 각 노드마다 있는 가지 중 방문하지 않은 곳을 방문하는 형식으로 이루어집니다.\n\n{\n  A: [ 'B', 'C' ],\n  B: [ 'A', 'D' ],\n  C: [ 'A', 'E' ],\n  D: [ 'B', 'E', 'F' ],\n  E: [ 'C', 'D', 'F' ],\n  F: [ 'D', 'E' ]\n}\n\n\n\n   \n\n\n재귀형 DFS 순회\n\n재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다.\n\ndepthFirstRecursive(vertex) {\n  const result = [];\n  // 결과를 담을 배열\n  const visited = {};\n  // 방문한 곳을 나타내는 객체\n  const { graph } = this;\n  // 해당 함수가 사용되는 전체 그래프\n  const dfs = (point) =&gt; {\n    if (!point) return null;\n    // 값이 없을경우에 대한 예외 처리\n    visited[point] = true;\n    // dfs가 사용되었으므로 방문했음을 표기\n    result.push(point);\n    // 결과에 해당 포인트에 대한 결과 입력\n    graph[point].forEach((nextPoint) =&gt; {\n    // 해당 포인트와 연결된 다음 포인트에 대해서 처리\n      if (!visited[nextPoint]) dfs(nextPoint);\n      // 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리\n    });\n  };\n  dfs(vertex);\n\t// 시작 지점에서 처리 시작\n\n  return result;\n}\n\nconsole.log(g.depthFirstRecursive(\"A\"));\n// [ 'A', 'B', 'D', 'E', 'C', 'F' ]\n\n\n재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다.\n\n여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다.\n\n반복형 DFS 순회\n\nwhile을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다.\n\ndepthFirstIterative(vertex) {\n  const result = [];\n  // 결과 배열\n  const visited = {};\n  // 방문 확인 배열\n  const { graph } = this;\n  // 현재 그래프\n  const stack = [vertex];\n  // 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴\n\n  let curVertex;\n  visited[vertex] = true;\n  // while문을 돌면서 현재의 위치를 나타내는 변수\n  while (stack.length) {\n    curVertex = stack.pop();\n    // DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요!\n    result.push(curVertex);\n    // 결과에 방문에 대한 결과값 처리\n    graph[curVertex].forEach((nextVertex) =&gt; {\n      // 현재 위치의 다음 위치들에 대해서 방문 여부 확인\n      if (visited[nextVertex]) return;\n      // 방문하지 않았을 시 stack에 추가\n      visited[nextVertex] = true;\n      // 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에,\n      // stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음\n      stack.push(nextVertex);\n    });\n  }\n\n  return result;\n}\n\n\n\n   \n\n\n반복을 사용하는 경우 while문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다.\n\nwhile을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다.\n\n그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.\n",
        "content": "트리는 그래프의 일종으로, 그래프 자체는 한 노드에서 다른 노드로 갈 수 있는 경로가 트리에 비해 더 많아집니다.\n\n여러 갈래로 연결된 그래프에서 최단 거리를 찾는 것과 같은 작업에서 ‘그래프 순회’의 방법을 사용하게 되며, 예시는 아래와 같습니다.\n\n\n  위키피디아의 링크 내 이동 시 최단 거리 찾기\n  페이스북의 친구 추천 시 최단 거리의 다른 친구 추천하기 기능\n  GPS 네비게이션\n  미로 문제 풀기\n\n\nDFS 순회?\n\n그래프에서의 형제는 트리와 조금 다른 형태로 이루어지게 되고, 이 형제들은 트리와 달리 반드시 같은 래벨은 아닙니다. 이러한 그래프 순회에서 가지를 따라가는 것이 순회의 가장 기본이 됩니다.\n\n핵심은 각 노드마다 있는 가지 중 방문하지 않은 곳을 방문하는 형식으로 이루어집니다.\n\n{\n  A: [ 'B', 'C' ],\n  B: [ 'A', 'D' ],\n  C: [ 'A', 'E' ],\n  D: [ 'B', 'E', 'F' ],\n  E: [ 'C', 'D', 'F' ],\n  F: [ 'D', 'E' ]\n}\n\n\n\n   \n\n\n재귀형 DFS 순회\n\n재귀 함수를 사용하는 방법으로 DFS를 구현하고, 이를 통해 그래프를 순환하게 됩니다. 그래프를 순환하는 함수는 아래 코드와 같습니다.\n\ndepthFirstRecursive(vertex) {\n  const result = [];\n  // 결과를 담을 배열\n  const visited = {};\n  // 방문한 곳을 나타내는 객체\n  const { graph } = this;\n  // 해당 함수가 사용되는 전체 그래프\n  const dfs = (point) =&gt; {\n    if (!point) return null;\n    // 값이 없을경우에 대한 예외 처리\n    visited[point] = true;\n    // dfs가 사용되었으므로 방문했음을 표기\n    result.push(point);\n    // 결과에 해당 포인트에 대한 결과 입력\n    graph[point].forEach((nextPoint) =&gt; {\n    // 해당 포인트와 연결된 다음 포인트에 대해서 처리\n      if (!visited[nextPoint]) dfs(nextPoint);\n      // 다음 포인트가 방문되지 않았을 경우, 해당 포인트를 방문하여 함수를 처리\n    });\n  };\n  dfs(vertex);\n\t// 시작 지점에서 처리 시작\n\n  return result;\n}\n\nconsole.log(g.depthFirstRecursive(\"A\"));\n// [ 'A', 'B', 'D', 'E', 'C', 'F' ]\n\n\n재귀형으로 그래프를 탐색하는 경우 크게 ‘방문관련 객체’, ‘결과 배열’, ‘각 포인트의 방문 여부에 따른 재귀 처리’의 세 가지 특징이 있습니다.\n\n여기서는 A라는 포인트로 시작을 했으나, 이는 꼭 A에서만 진행할 필요가 없으며, 어떠한 포인트에서 돌든 결국 모든 포인트를 거쳤다는 사실이 중요합니다.\n\n반복형 DFS 순회\n\nwhile을 이용한 반복문 처리를 통해 DFS 순회를 하게 됩니다.\n\ndepthFirstIterative(vertex) {\n  const result = [];\n  // 결과 배열\n  const visited = {};\n  // 방문 확인 배열\n  const { graph } = this;\n  // 현재 그래프\n  const stack = [vertex];\n  // 처리해야할 stack 배열. 처음에는 설정된 값 하나만 들어옴\n\n  let curVertex;\n  visited[vertex] = true;\n  // while문을 돌면서 현재의 위치를 나타내는 변수\n  while (stack.length) {\n    curVertex = stack.pop();\n    // DFS를 실행하기 위해, 뒤에 있는 값부터 처리하는 것이 중요!\n    result.push(curVertex);\n    // 결과에 방문에 대한 결과값 처리\n    graph[curVertex].forEach((nextVertex) =&gt; {\n      // 현재 위치의 다음 위치들에 대해서 방문 여부 확인\n      if (visited[nextVertex]) return;\n      // 방문하지 않았을 시 stack에 추가\n      visited[nextVertex] = true;\n      // 방문을 했으므로 true처리 =&gt; stack에 들어오는 것으로 실질적인 계산을 하기 때문에,\n      // stack에 넣기 바로 전에 처리를 해주어야 에러가 발생하지 않음\n      stack.push(nextVertex);\n    });\n  }\n\n  return result;\n}\n\n\n\n   \n\n\n반복을 사용하는 경우 while문을 쓰게 됩니다. 그리고 ‘결과’, ‘방문’, ‘처리할 값들’을 나타내는 배열이나 객체가 필요합니다.\n\nwhile을 돌면서 처리를 하게 되는데, 이 때 현재 위치에 대해서 필요한 처리(여기서는 결과 배열에 추가)를 하게 되며, 이후 다음 위치들에 대해서 방문 여부를 확인 후 stack에 넣어주는 방식으로 진행합니다.\n\n그래프의 형태가 같아도, 다른 결과가 나올 수 있게 되는데, 이는 배열에 주입된 순서에 따라 B와 C 중 어느 것이든 먼저 갈 수 있고, 이에 따라 깊이 우선의 순서가 바뀌기 때문입니다. 하지만, 모든 곳을 깊이 우선으로 탐색한다는 데에는 변함이 없습니다.\n",
        "url": "/algorithm/2022/10/10/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%EA%B7%B8%EB%9E%98%ED%94%84_%EC%88%9C%ED%9A%8C-copy/"
      },
    
      {
        "title": "REACT DATEPICKER",
        "feature_text": "REACT DATEPICKER를 활용한 날짜, 시간 설정\n",
        "excerpt": "날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다.\n\n&lt;S.DateInputForm type='date' value={appointmentDateTime} onChange={handelChangeDateTime} /&gt;\n&lt;S.DateInputForm type='time' value={appointmentTime} onChange={handelChangeTime} /&gt;\n\n\n\n   \n\n\n하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다.\n(링크 : React Datepicker crafted by HackerOne)\n\n설치는 아래 코드들로 진행했습니다.\n\nnpm install react-datepicker --save\nnpm install @types/react-datepicker\n\n\n\n\n날짜 설정\n\n사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다.\n\nimport \"react-datepicker/dist/react-datepicker.css\";\n\nimport ReactDatePicker from \"react-datepicker\";\n\nexport const StyledDatePicker = styled(ReactDatePicker)`\n  border: none;\n  background-color: transparent;\n  padding: 0;\n`;\n\n\n&lt;S.StyledDatePicker\n  onFocus={() =&gt; setIsDateFocused(true)}\n  onBlur={() =&gt; setIsDateFocused(false)}\n  onChange={handelChangeDate}\n  dateFormat=\"yyyy.MM.dd\"\n/&gt;\n\n\n\n   \n\n\n이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다.\n\n.react-datepicker {\n\t&amp;__day {\n\t  ${fonts.xSmall};\n\t  color: ${colors.grey4};\n\t  width: calc(100% / 10);\n\t  aspect-ratio: 1;\n\t  line-height: initial;\n\t  display: inline-flex;\n\t  align-items: center;\n\t  justify-content: center;\n\t  margin: 0;\n\n\t  :hover {\n\t    border-radius: 10rem;\n\t  }\n\n\t  &amp;-name {\n\t    ${fonts.xSmall};\n\n\t\t...\n\n\t  &amp;--disabled {\n\t    text-decoration: line-through;\n\t    color: ${colors.grey3};\n\t  }\n\t}\n\n\n\n\n날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(react-datepicker__current-month)와 같은 선상에 있으면서 position: absolute로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 top으로 직접 받아 처리하도록 우선 구성했습니다.\n\n&amp;__current {\n  &amp;-month {\n    text-align: left;\n    padding-left: calc(100% * 7 / 80 - 5px);\n    padding-bottom: 0.5rem;\n    padding-top: 0.75rem;\n  }\n}\n\n&amp;__navigation {\n\t  &amp;--previous {\n\t    top: 5px;\n\t    left: unset;\n\t    right: calc(32px);\n\t  }\n\t  &amp;--next {\n\t    top: 5px;\n\t    right: 0px;\n\t  }\n\t  &amp;-icon {\n\t    ::before {\n\t      border: none;\n\t    }\n\t\t}\n\t}\n}\n\n\ndatepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다.\n\n&lt;S.StyledDatePicker\n  selected={new Date(appointmentDateTime)}\n  // 선택된 날짜를 지정\n  onFocus={() =&gt; setIsDateFocused(true)}\n  // 기존 input과 동일\n  onBlur={() =&gt; setIsDateFocused(false)}\n  // 기존 input과 동일\n  onChange={handelChangeDate}\n  // 기존 input과 동일\n  dateFormat=\"yyyy.MM.dd\"\n  // input에 보이는 날짜 형식 설정\n  minDate={new Date()}\n  // 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨\n  showPopperArrow={false}\n  // 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정\n  formatWeekDay={(nameOfDay) =&gt; nameOfDay.substring(0, 1)}\n  // 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경\n  nextMonthButtonLabel={&lt;Icon iconName=\"ChevronRight\" iconSize={0.75} /&gt;}\n  // 다음 달 보기 버튼 표현방식 변경\n  previousMonthButtonLabel={&lt;Icon iconName=\"ChevronLeft\" iconSize={0.75} /&gt;}\n  // 이전 달 보기 버튼 표현방식 변경\n/&gt;\n\n\n\n   \n\n\n시간 설정\n\n시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다.\n\n\n  \n   \n\n\n  \n   \n\n\n\n\n왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다.\n\n시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다.\n\nexport const StyledTimePicker = styled(ReactDatePicker)`\n  width: 100%;\n  border: none;\n  background-color: transparent;\n  padding: 0;\n\n  :focus {\n    outline: none;\n  }\n`;\n\n...\n\n&amp;__header {\n  padding: 0;\n  &amp;--time {\n    background-color: transparent;\n    border-bottom: none;\n  }\n}\n\n&amp;-time__header {\n  ${flexCenter};\n\n  justify-content: left;\n  width: 100px;\n  word-spacing: 10px;\n  margin: 0 auto;\n  white-space: pre;\n  font-size: 8px;\n  font-weight: 400;\n  height: 25px;\n  color: ${colors.grey4};\n}\n\n...\n\n\n&lt;S.TimeInputWrapper isTimeFocused={isTimeFocused}&gt;\n  &lt;S.StyledTimePicker\n    onChange={handleChangeTimeTest}\n    // 기존 input과 동일\n    timeIntervals={timeIntervals}\n    // 시간 설정의 간격을 조절함\n    showTimeSelect\n    showTimeSelectOnly\n    // 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함\n    selected={currentTimeDateType}\n    // 선택된 시간에 selected 클래스를 지정함\n    showPopperArrow={false}\n    timeFormat=\"HH mm aa\"\n    value={appointmentTime}\n    timeCaption=\"HOUR MINUTE\"\n    onFocus={() =&gt; setIsTimeFocused(true)}\n    onBlur={() =&gt; setIsTimeFocused(false)}\n  /&gt;\n  &lt;Icon iconName=\"ChevronDown\" iconSize={0.9} /&gt;\n&lt;/S.TimeInputWrapper&gt;\n\n\n날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다.\n\n단, 시간 설정을 할 때에는 showTimeSelect, showTimeSelectOnly 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다.\n\n시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다.\n\n\n   \n\n\n특이 사항\n\n스타일 관련 작업들을 진행하면서, !important를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. !important를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.\n",
        "content": "날짜와 시간을 설정하는 부분에서, 기존에는 input 자체의 내장 기능으로 date와 time을 사용해 시간을 설정할 수 있도록 했었습니다.\n\n&lt;S.DateInputForm type='date' value={appointmentDateTime} onChange={handelChangeDateTime} /&gt;\n&lt;S.DateInputForm type='time' value={appointmentTime} onChange={handelChangeTime} /&gt;\n\n\n\n   \n\n\n하지만, 이렇게 설정할 경우, 브라우저 내의 date와 time 설정 방식을 사용해야 하기 때문에 추가적인 디자인 변경이 어렵다는 것을 알게 됐고, 직접 디자인이 변경한 관련 라이브러리를 찾아보니 react datepicker라는 것이 있다는 것을 알게 됐습니다.\n(링크 : React Datepicker crafted by HackerOne)\n\n설치는 아래 코드들로 진행했습니다.\n\nnpm install react-datepicker --save\nnpm install @types/react-datepicker\n\n\n\n\n날짜 설정\n\n사용하는 방법 자체는 간단한데, 아래의 코드와 같이 datepicker를 불러와 css와 함께 삽입해주면 기본적인 datepicker의 달력이 나오게 됩니다.\n\nimport \"react-datepicker/dist/react-datepicker.css\";\n\nimport ReactDatePicker from \"react-datepicker\";\n\nexport const StyledDatePicker = styled(ReactDatePicker)`\n  border: none;\n  background-color: transparent;\n  padding: 0;\n`;\n\n\n&lt;S.StyledDatePicker\n  onFocus={() =&gt; setIsDateFocused(true)}\n  onBlur={() =&gt; setIsDateFocused(false)}\n  onChange={handelChangeDate}\n  dateFormat=\"yyyy.MM.dd\"\n/&gt;\n\n\n\n   \n\n\n이 달력 내의 각각의 요소마다 클래스로 지정이 되어 있어, 스타일을 변경하고자 하는 부분의 클래스를 따라 들어가 원하는 스타일로 CSS 작업을 진행하면 됩니다.\n\n.react-datepicker {\n\t&amp;__day {\n\t  ${fonts.xSmall};\n\t  color: ${colors.grey4};\n\t  width: calc(100% / 10);\n\t  aspect-ratio: 1;\n\t  line-height: initial;\n\t  display: inline-flex;\n\t  align-items: center;\n\t  justify-content: center;\n\t  margin: 0;\n\n\t  :hover {\n\t    border-radius: 10rem;\n\t  }\n\n\t  &amp;-name {\n\t    ${fonts.xSmall};\n\n\t\t...\n\n\t  &amp;--disabled {\n\t    text-decoration: line-through;\n\t    color: ${colors.grey3};\n\t  }\n\t}\n\n\n\n\n날짜 설정과 관련된 스타일 작업을 하면서 약간의 어려움을 느꼈던 부분은 이전 ∙ 다음 달로 넘어가는 화살표의 디자인을 설정하는 것이었는데, 현재 설정 월을 표시해주는 헤더(react-datepicker__current-month)와 같은 선상에 있으면서 position: absolute로 포지셔닝이 되어 있어, 이는 헤더와 같은 값을 top으로 직접 받아 처리하도록 우선 구성했습니다.\n\n&amp;__current {\n  &amp;-month {\n    text-align: left;\n    padding-left: calc(100% * 7 / 80 - 5px);\n    padding-bottom: 0.5rem;\n    padding-top: 0.75rem;\n  }\n}\n\n&amp;__navigation {\n\t  &amp;--previous {\n\t    top: 5px;\n\t    left: unset;\n\t    right: calc(32px);\n\t  }\n\t  &amp;--next {\n\t    top: 5px;\n\t    right: 0px;\n\t  }\n\t  &amp;-icon {\n\t    ::before {\n\t      border: none;\n\t    }\n\t\t}\n\t}\n}\n\n\ndatepicker의 기능을 위한 설정도 필요했는데, 대표적으로 선택된 날짜 지정, 날짜 표현 형식 변경, 주 단위 변경 등이 있었습니다. 다행히 datepicker 내에 이와 관련된 기능들이 포함되어 있어, 이를 찾아 적용해주었습니다.\n\n&lt;S.StyledDatePicker\n  selected={new Date(appointmentDateTime)}\n  // 선택된 날짜를 지정\n  onFocus={() =&gt; setIsDateFocused(true)}\n  // 기존 input과 동일\n  onBlur={() =&gt; setIsDateFocused(false)}\n  // 기존 input과 동일\n  onChange={handelChangeDate}\n  // 기존 input과 동일\n  dateFormat=\"yyyy.MM.dd\"\n  // input에 보이는 날짜 형식 설정\n  minDate={new Date()}\n  // 최소 선택 가능 날짜 지정. 이전 날짜는 선택이 안 됨\n  showPopperArrow={false}\n  // 말풍선처럼 꼬리가 붙어있는 것을 보여줄지 여부를 결정\n  formatWeekDay={(nameOfDay) =&gt; nameOfDay.substring(0, 1)}\n  // 주 단위를 어떤 식으로 보여줄지 결정. 여기서는 Wed =&gt; W로 변경\n  nextMonthButtonLabel={&lt;Icon iconName=\"ChevronRight\" iconSize={0.75} /&gt;}\n  // 다음 달 보기 버튼 표현방식 변경\n  previousMonthButtonLabel={&lt;Icon iconName=\"ChevronLeft\" iconSize={0.75} /&gt;}\n  // 이전 달 보기 버튼 표현방식 변경\n/&gt;\n\n\n\n   \n\n\n시간 설정\n\n시간을 설정하는 부분도 동일한 방식으로 적용하려 했으나, 가장 큰 문제점은 기본적인 datepicker 내의 시간 디자인과 우리의 디자인이 시간 설정 방식 면에서 다르다는 점이었습니다.\n\n\n  \n   \n\n\n  \n   \n\n\n\n\n왼쪽이 디자인 상의 시간 설정이고, 오른쪽이 datepicker에서 제공하는 시간 설정입니다. 이 경우, 디자인을 바꾼다고 해도 좌측과 같은 설정 방법을 만들 수가 없어, 시간 설정과 관련된 라이브러리를 한 번 더 찾아 적용해야 한다는 부담이 생겼습니다.\n\n시간 설정과 관련된 여러 라이브러리들을 찾아봤지만, 좌측과 같은 시간 설정 방식을 제공하는 라이브러리를 찾는 데에는 한계가 있었습니다. 또한, 현재 진행해야 할 다른 부분들이 많이 남아 있어, 시간 설정 부분에만 더 많은 시간을 할애하기에 어려움이 많아 datepicker의 시간 설정을 최대한 비슷한 디자인으로 수정하는 것으로 방법을 바꾸었습니다.\n\nexport const StyledTimePicker = styled(ReactDatePicker)`\n  width: 100%;\n  border: none;\n  background-color: transparent;\n  padding: 0;\n\n  :focus {\n    outline: none;\n  }\n`;\n\n...\n\n&amp;__header {\n  padding: 0;\n  &amp;--time {\n    background-color: transparent;\n    border-bottom: none;\n  }\n}\n\n&amp;-time__header {\n  ${flexCenter};\n\n  justify-content: left;\n  width: 100px;\n  word-spacing: 10px;\n  margin: 0 auto;\n  white-space: pre;\n  font-size: 8px;\n  font-weight: 400;\n  height: 25px;\n  color: ${colors.grey4};\n}\n\n...\n\n\n&lt;S.TimeInputWrapper isTimeFocused={isTimeFocused}&gt;\n  &lt;S.StyledTimePicker\n    onChange={handleChangeTimeTest}\n    // 기존 input과 동일\n    timeIntervals={timeIntervals}\n    // 시간 설정의 간격을 조절함\n    showTimeSelect\n    showTimeSelectOnly\n    // 시간 설정만 보여주도록 설정. 위 두 가지를 모두 입력해야 함\n    selected={currentTimeDateType}\n    // 선택된 시간에 selected 클래스를 지정함\n    showPopperArrow={false}\n    timeFormat=\"HH mm aa\"\n    value={appointmentTime}\n    timeCaption=\"HOUR MINUTE\"\n    onFocus={() =&gt; setIsTimeFocused(true)}\n    onBlur={() =&gt; setIsTimeFocused(false)}\n  /&gt;\n  &lt;Icon iconName=\"ChevronDown\" iconSize={0.9} /&gt;\n&lt;/S.TimeInputWrapper&gt;\n\n\n날짜 설정을 할 때와 동일한 방식으로 스타일을 구성했으며, 이로 인한 어려움은 크게 없었습니다.\n\n단, 시간 설정을 할 때에는 showTimeSelect, showTimeSelectOnly 이 두 가지 설정을 넣어주어야 시간 설정에 대한 창만 나오게 되므로 이를 주의할 필요가 있었습니다.\n\n시간 설정도 같은 방식의 스타일을 적용해 문제를 해결했으며 이 라이브러리 덕분에 input과 관련된 디자인 설정 시 드는 어려움을 줄일 수 있었습니다.\n\n\n   \n\n\n특이 사항\n\n스타일 관련 작업들을 진행하면서, !important를 사용해야 할 상황이 종종 생겼습니다. 이는 datepicker 내에서 디자인 설정을 하며 우선 적용된 부분들이 있어, 이를 건드리기 위한 것이었습니다. !important를 사용할 경우 추후 수정 작업 때 문제가 될 수 있어 사용을 피해야하지만, 이 부분에 대한 특별한 해결책은 아직 찾아내지 못했습니다.\n",
        "url": "/react/2022/10/11/react_datepicker/"
      },
    
      {
        "title": "채팅 목록 업데이트 기능 만들기",
        "feature_text": "stomp(socket)으로 만든 채팅 목록에 들어오는 채팅 알림 업데이트 하기\n",
        "excerpt": "이전에 소켓의 연결을 통해, 새로운 채팅이 소켓에 들어오는 상황이 발생하면 그 메세지를 저장하는 기능을 만들었습니다. 이후 메세지 목록 내에서도 업데이트가 되는 상황이 발생하면, 이 사항을 바로 반영하는 기능을 넣어야 했습니다.\n\n해당 기능을 만들기 위해서 거쳐야 하는 단계는 다음과 같았습니다.\n\n\n  새로운 채팅이 들어오면 채팅의 정보를 바로 가져오기(id, contents)\n  새로운 채팅의 정보와 일치하는 채팅 찾기\n  해당 채팅 업데이트 하기\n  업데이트 된 정보 처리하기\n\n\n새로운 채팅의 정보 가져오기\n\nexport type ChatroomsUpdate = {\n  id?: number;\n  contents?: string;\n};\n\nexport const chatroomsUpdateState = atom&lt;ChatroomsUpdate&gt;({\n  key: \"chatroomsUpdate\",\n  default: {},\n});\n\n// ChatroomsItem.tsx\nconst { id: updateId, contents: updateContents } =\n  useRecoilValue(chatroomsUpdateState);\n\n\n현재 사용 중인 Recoil의 특성상, 특정 상태의 업데이트가 이루어지게 되면 해당 상태를 쓰는 곳에서도 업데이트가 이루어지기 때문에 해당 값을 가져오는 것만으로 업데이트가 가능했습니다.\n\n일치하는 채팅 찾기 및 업데이트\n\n// ChatroomsItem.tsx\nconst [curUnreadCount, setCurUnreadCount] = useState(unreadCount);\nconst [curRecentMessage, setCurRecentMessage] = useState&lt;string | undefined&gt;(\n  recentMessage\n);\n\nuseEffect(() =&gt; {\n  if (chatRoomMemberId !== updateId) return;\n\n  setCurRecentMessage(updateContents);\n  setCurUnreadCount((prev) =&gt; prev + 1);\n}, [updateContents]);\n\n\n이후 useEffect를 통해 updateContents가 변하는 경우마다 특정 상황이 이루어지도록 했습니다. 여기서 id값이 일치하는 경우에만 다음 작업이 이루어질 수 있도록 했으며, 이를 통해 해당 id를 찾는 작업을 진행했습니다.\n\nid가 일치하는 경우, 해당 항목의 메세지를 새롭게 설정된 메세지(setCurRecentMessage)로 바꾸고, 읽지 않은 개수(setCurUnreadCount)도 증가하도록 설정했습니다.\n\n업데이트된 정보 처리하기\n\n하지만, 이렇게 설정할 경우, 한 가지 문제가 발생하게 됐는데, updateContents라는 정보가 다른 페이지에 있다가 넘어오는 경우 useEffect의 특성으로 인해 렌더링 후 바로 해당 id의 정보가 업데이트되어 버린다는 것입니다. 즉, 읽지 않은 항목이 1개씩 늘어나게 됩니다.\n\n이 부분을 해결하기 위해서 두 가지 중 하나를 골라야했습니다.\n\n\n  업데이트가 이루어질 때마다 updateContents를 초기화하기\n  updateContents를 특정 타이밍에 초기화하기\n\n\n첫 번째 경우의 수를 사용할 경우, 초기화를 하는 중간에 새로운 정보가 socket을 통해 들어오게 되면 제대로 된 데이터 처리가 되지 않을 가능성이 존재합니다. 이로 인해 updateContents를 일정 시점에 초기화해주어야 하는데, 그 시점을 ‘채팅 목록 페이지를 나가는 시점’으로 했습니다. 이를 구현하기 위해 현재 페이지 내의 useEffect에 리턴 함수를 적용해주었습니다.\n\n// Chatrooms.tsx\nuseEffect(() =&gt; {\n  return () =&gt; setChatroomsUpdate({});\n}, []);\n\n\n\n   \n\n\n🔎 여기서 현재 의문점이 드는 것은, 업데이트가 발생할 때마다 모든 채팅 한 번씩 검사는 거친다는 점에서, 렌더링에는 큰 무리가 없지만 계산이 계속 적용된다는 것에 문제가 있지는 않을까하는 생각이 들었고, 추후에 이것 외에 다른 방식으로 id값을 비교할 방법이 있는지 알아보고자 합니다.\n",
        "content": "이전에 소켓의 연결을 통해, 새로운 채팅이 소켓에 들어오는 상황이 발생하면 그 메세지를 저장하는 기능을 만들었습니다. 이후 메세지 목록 내에서도 업데이트가 되는 상황이 발생하면, 이 사항을 바로 반영하는 기능을 넣어야 했습니다.\n\n해당 기능을 만들기 위해서 거쳐야 하는 단계는 다음과 같았습니다.\n\n\n  새로운 채팅이 들어오면 채팅의 정보를 바로 가져오기(id, contents)\n  새로운 채팅의 정보와 일치하는 채팅 찾기\n  해당 채팅 업데이트 하기\n  업데이트 된 정보 처리하기\n\n\n새로운 채팅의 정보 가져오기\n\nexport type ChatroomsUpdate = {\n  id?: number;\n  contents?: string;\n};\n\nexport const chatroomsUpdateState = atom&lt;ChatroomsUpdate&gt;({\n  key: \"chatroomsUpdate\",\n  default: {},\n});\n\n// ChatroomsItem.tsx\nconst { id: updateId, contents: updateContents } =\n  useRecoilValue(chatroomsUpdateState);\n\n\n현재 사용 중인 Recoil의 특성상, 특정 상태의 업데이트가 이루어지게 되면 해당 상태를 쓰는 곳에서도 업데이트가 이루어지기 때문에 해당 값을 가져오는 것만으로 업데이트가 가능했습니다.\n\n일치하는 채팅 찾기 및 업데이트\n\n// ChatroomsItem.tsx\nconst [curUnreadCount, setCurUnreadCount] = useState(unreadCount);\nconst [curRecentMessage, setCurRecentMessage] = useState&lt;string | undefined&gt;(\n  recentMessage\n);\n\nuseEffect(() =&gt; {\n  if (chatRoomMemberId !== updateId) return;\n\n  setCurRecentMessage(updateContents);\n  setCurUnreadCount((prev) =&gt; prev + 1);\n}, [updateContents]);\n\n\n이후 useEffect를 통해 updateContents가 변하는 경우마다 특정 상황이 이루어지도록 했습니다. 여기서 id값이 일치하는 경우에만 다음 작업이 이루어질 수 있도록 했으며, 이를 통해 해당 id를 찾는 작업을 진행했습니다.\n\nid가 일치하는 경우, 해당 항목의 메세지를 새롭게 설정된 메세지(setCurRecentMessage)로 바꾸고, 읽지 않은 개수(setCurUnreadCount)도 증가하도록 설정했습니다.\n\n업데이트된 정보 처리하기\n\n하지만, 이렇게 설정할 경우, 한 가지 문제가 발생하게 됐는데, updateContents라는 정보가 다른 페이지에 있다가 넘어오는 경우 useEffect의 특성으로 인해 렌더링 후 바로 해당 id의 정보가 업데이트되어 버린다는 것입니다. 즉, 읽지 않은 항목이 1개씩 늘어나게 됩니다.\n\n이 부분을 해결하기 위해서 두 가지 중 하나를 골라야했습니다.\n\n\n  업데이트가 이루어질 때마다 updateContents를 초기화하기\n  updateContents를 특정 타이밍에 초기화하기\n\n\n첫 번째 경우의 수를 사용할 경우, 초기화를 하는 중간에 새로운 정보가 socket을 통해 들어오게 되면 제대로 된 데이터 처리가 되지 않을 가능성이 존재합니다. 이로 인해 updateContents를 일정 시점에 초기화해주어야 하는데, 그 시점을 ‘채팅 목록 페이지를 나가는 시점’으로 했습니다. 이를 구현하기 위해 현재 페이지 내의 useEffect에 리턴 함수를 적용해주었습니다.\n\n// Chatrooms.tsx\nuseEffect(() =&gt; {\n  return () =&gt; setChatroomsUpdate({});\n}, []);\n\n\n\n   \n\n\n🔎 여기서 현재 의문점이 드는 것은, 업데이트가 발생할 때마다 모든 채팅 한 번씩 검사는 거친다는 점에서, 렌더링에는 큰 무리가 없지만 계산이 계속 적용된다는 것에 문제가 있지는 않을까하는 생각이 들었고, 추후에 이것 외에 다른 방식으로 id값을 비교할 방법이 있는지 알아보고자 합니다.\n",
        "url": "/javascript/2022/10/16/socket-%EC%B1%84%ED%8C%85-%EB%AA%A9%EB%A1%9D-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0/"
      },
    
      {
        "title": "mouse click event 자동 발생 문제",
        "feature_text": "컴퓨터 브라우저에서 mouse up event 시 mouse click event가 자동 발생하는 문제\n",
        "excerpt": "\n   \n\n\n슬라이딩 애니메이션을 구현하며, 위와 같이 슬라이딩을 할 때 클릭이 되지 않도록 기능을 적용했습니다. 하지만 이는 모바일에서만 적용이 되었는데, 컴퓨터 브라우저에서는 아래와 같이 mouseclick 이벤트가 동작해, 다른 링크로 넘어가게 되는 문제가 발생했습니다.\n\n\n   \n\n\n위 그림과 같이 클릭 이벤트를 처리해야하는 상황에서 슬라이딩 되는 요소에 mouseclick 이벤트와 mouseup 이벤트가 모두 적용될 시, mouseclick 이벤트가 실행되는 것이 문제점이었습니다. 원인은 mouseclick이 **mousedown, mouseup이 같은 요소에 대해 이루어질 시 나타나는 이벤트**이기 때문이었습니다.\n\n이로 인해, mouseclick 이벤트 핸들러에 이러한 상황을 구분할 수 있는 구분점(여기서는 움직임의 유무)을 두는 것으로서 처리를 해줄 수 있었습니다. 현재 mouseup 이벤트가 실행되고 나면 애니메이션이 그 다음으로 실행되고, 이 애니메이션이 종료되는 것을 통해 움직임과 관련된 옵션이 끝났다는 것을 알려주도록 했습니다.\n\nconst handleAnimationEnd = () =&gt; {\n  if (moving === 'right') setMoving(null);\n};\n// 애니메이션이 종료되는 시점에 움직이는 작업이 끝나, 작업이 없다는 것을 설정해줍니다.\n\n&lt;S.InnerWrapper\n  ref={wrapperRef}\n  ...\n  onAnimationEnd={handleAnimationEnd}\n\t// 애니메이션이 끝나면 해당 함수가 실행되도록 합니다.\n&gt;\n\n\n그리고 클릭 이벤트 내에는, 움직이는 작업이 없는 경우에만 클릭 이벤트로 다른 작업을 할 수 있도록 설정했습니다.\n\nconst handleClickItem = () =&gt; {\n  if (moving) return;\n  // 움직임이 남아있을 경우 다음 작업을 하지 않습니다.\n  navigate(`${pathName.chatroomDetail}/${id}`, { state: { chatRoomMemberId } });\n};\n\n\nmouseclick과 mouseup을 함께 사용할 때에는 위와 같이 click만이 구분되어 실행될 수 있도록 하는 옵션을 주어, 처리를 해야 원하는 처리가 가능하다는 것을 알 수 있었습니다.\n\n\n   \n\n\n",
        "content": "\n   \n\n\n슬라이딩 애니메이션을 구현하며, 위와 같이 슬라이딩을 할 때 클릭이 되지 않도록 기능을 적용했습니다. 하지만 이는 모바일에서만 적용이 되었는데, 컴퓨터 브라우저에서는 아래와 같이 mouseclick 이벤트가 동작해, 다른 링크로 넘어가게 되는 문제가 발생했습니다.\n\n\n   \n\n\n위 그림과 같이 클릭 이벤트를 처리해야하는 상황에서 슬라이딩 되는 요소에 mouseclick 이벤트와 mouseup 이벤트가 모두 적용될 시, mouseclick 이벤트가 실행되는 것이 문제점이었습니다. 원인은 mouseclick이 **mousedown, mouseup이 같은 요소에 대해 이루어질 시 나타나는 이벤트**이기 때문이었습니다.\n\n이로 인해, mouseclick 이벤트 핸들러에 이러한 상황을 구분할 수 있는 구분점(여기서는 움직임의 유무)을 두는 것으로서 처리를 해줄 수 있었습니다. 현재 mouseup 이벤트가 실행되고 나면 애니메이션이 그 다음으로 실행되고, 이 애니메이션이 종료되는 것을 통해 움직임과 관련된 옵션이 끝났다는 것을 알려주도록 했습니다.\n\nconst handleAnimationEnd = () =&gt; {\n  if (moving === 'right') setMoving(null);\n};\n// 애니메이션이 종료되는 시점에 움직이는 작업이 끝나, 작업이 없다는 것을 설정해줍니다.\n\n&lt;S.InnerWrapper\n  ref={wrapperRef}\n  ...\n  onAnimationEnd={handleAnimationEnd}\n\t// 애니메이션이 끝나면 해당 함수가 실행되도록 합니다.\n&gt;\n\n\n그리고 클릭 이벤트 내에는, 움직이는 작업이 없는 경우에만 클릭 이벤트로 다른 작업을 할 수 있도록 설정했습니다.\n\nconst handleClickItem = () =&gt; {\n  if (moving) return;\n  // 움직임이 남아있을 경우 다음 작업을 하지 않습니다.\n  navigate(`${pathName.chatroomDetail}/${id}`, { state: { chatRoomMemberId } });\n};\n\n\nmouseclick과 mouseup을 함께 사용할 때에는 위와 같이 click만이 구분되어 실행될 수 있도록 하는 옵션을 주어, 처리를 해야 원하는 처리가 가능하다는 것을 알 수 있었습니다.\n\n\n   \n\n\n",
        "url": "/javascript/2022/10/17/mouse-click-event-%EC%9E%90%EB%8F%99-%EB%B0%9C%EC%83%9D-%EB%AC%B8%EC%A0%9C/"
      },
    
      {
        "title": "stomp(socket) 동시 연결하기",
        "feature_text": "stomp(socket)를 사용하는 곳들이 한 번에 연결되도록 설정하기\n",
        "excerpt": "이전 코드의 문제점\n\n기존에 stomp를 통한 socket 연결 시, socket에 연결되는 것들의 종류에 따라 나누어 stompClient를 직접 만들어 적용하는 방식을 사용하고 있었습니다.\n\n그로 인해 아래 사진과 같이 socket 연결을 두 번 진행하게 됐고, 이는 불필요한 연결을 반복하는 결과가 나오게 했습니다.\n\n\n   \n\n\n코드로는 아래와 같은 형태가 나오게 되며, 아래의 함수들을 각각 호출해 적용하는 형식이었습니다.\n\nexport const chatroomSocket = () =&gt; {\n  const sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\n  const sock = new SockJs(sockServer);\n  const stompClient = StompJs.over(sock);\n\t// 해당 부분에서 stompClient를 계속해서 새로 생성하게 됨\n\n  const subscribeChat = ({ onReceive, chatroomId, chatroomIds }: subscribeParamsType) =&gt; {\n    const headers = getAuthHeaders();\n    const subscribeToStomp = (id: string | number) =&gt; {\n      const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n      stompClient.subscribe(subscribeURL, onReceive, headers);\n    };\n\n    if (chatroomId) subscribeToStomp(chatroomId);\n    if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n  };\n\nexport const noticeSocket = () =&gt; {\n  const sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\n  const sock = new SockJs(sockServer);\n  const stompClient = StompJs.over(sock);\n\t// 해당 부분에서 stompClient를 계속해서 새로 생성하게 됨\n\n  const subscribeNotice = ({\n    entryIds,\n    keywordIds,\n    onSubscribeEntries,\n    onSubscribeKeywords,\n  }: subscribeParamsType) =&gt; {\n    const subscribeURL = `/${QUEUE}/${NOTIFICATIONS}`;\n    const headers = getAuthHeaders();\n\n    if (!!entryIds.length) {\n      entryIds.forEach((id) =&gt; {\n        stompClient.subscribe(subscribeURL + `/${ENTRIES}/${id}`, onSubscribeEntries, headers);\n      });\n    }\n\n\n\n   \n\n\n‘stompClient’ 하나만 사용하기\n\n이 부분에서 stompClient를 하나만 호출하고, 이를 전체 App에서 연결, 구독, 연결 해제 등의 작업을 해야했습니다. 이를 위해 stompClient가 호출되는 위치를 상단으로 바꾸고, 이를 export하는 작업부터 진행했습니다.\n\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\nconst sock = new SockJs(sockServer);\nexport const stompClient = StompJs.over(sock);\n\n\n위와 같이 하나의 stompClient만을 생성하고, 이를 export해, 이 stompClient만을 이용해 소켓 연결을 할 수 있도록 했습니다. 그 다음 stompClient를 갖고 바로 구독을 하거나 연결을 하는 등의 행위를 할 수 있었습니다.\n\nexport const subscribeChat = ({\n  onReceiveChat,\n  chatroomId,\n  chatroomIds,\n}: subscribeChatParamsType) =&gt; {\n  const subscribeToStomp = (id: number) =&gt; {\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n    const headers = getAuthHeaders();\n    const { id: stompId } = stompClient.subscribe(subscribeURL, onReceiveChat, headers);\n\t\t// stompClient를 바로 가져다 쓰도록 설정\n\t\t...\n\nexport const connectStomp = ({ noticeParams, chatParams }: ConnectStompParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  try {\n    // stompClient.debug = () =&gt; null; 이후 console로 나오는 stomp 관련 내용 제거에 사용\n    stompClient.connect(headers, () =&gt; {\n\t\t// stompClient에 바로 연결\n      subscribeNotice(noticeParams);\n      subscribeChat(chatParams);\n\t\t\t// 연결이 완료될 시, 바로 Notice, Chat의 구독 시 행위를 지정함\n\t\t\t...\n\n\n이 작업을 통해서 위 그림과 달리 아래처럼 하나의 stompClient만을 갖고 원하는 모든 알림, 채팅을 구독할 수 있었습니다.\n\n\n   \n\n\n새로운 채팅의 내용 가져오기\n\n기존에 채팅을 사용할 때에는, 채팅 상세 페이지에서 직접 소켓에 다시 한 번 연결하는 과정을 거치며, 그 과정에서 채팅 데이터 목록을 업데이트하는 코드를 직접 주입하는 방식으로 이루어졌었습니다.\n\n// 채팅 상세 페이지 내 새로운 채팅을 받는 함수\nconst getNewChatMessage = (chatData: StompJs.Message) =&gt; {\n  const newChat = JSON.parse(chatData.body);\n  // 새로운 채팅을 소켓으로부터 직접 받아(StompJs.Message), 기존 리스트에 업데이트 해주는 방식으로 되어 있음\n  setCurChats((chats) =&gt; {\n    const newChats = [...chats, newChat];\n\n    return newChats;\n  });\n  scrollToBottom();\n};\n\nuseEffect(() =&gt; {\n  const { disconnectChatroom, connectChatroom } = chatroomSocket();\n  connectChatroom({ onReceive: getNewChatMessage, chatroomId });\n  // 소켓에 직접 연결 및 채팅 받을 시 실행할 함수를 적용\n  return () =&gt; disconnectChatroom();\n  // 채팅방 나갈 시 소켓 연결 제거\n}, []);\n\n\n\n   \n\n\n하지만, 소켓을 한 번 연결하고, 채팅방에 들어올 때 별도의 소켓 연결을 더 하지 않으려면, 기존의 연결을 통해 바뀌는 값을 따로 저장해줄 필요가 있었습니다. 이를 처리하기 위해 기존에 사용하던 recoil의 atom을 통해서 값을 저장하는 store를 만들었습니다.\n\nexport type ChatroomsUpdate = {\n  id?: number;\n  chat?: ChatroomDetailChatType;\n  trigger: number;\n  // 같은 chat이 들어온 경우에 대한 구분이 필요해, trigger를 통한 구분을 하도록 설정\n};\n\nexport const chatUpdateState = atom&lt;ChatroomsUpdate&gt;({\n  key: \"chatUpdate\",\n  default: { trigger: 0 },\n});\n\n// stomp 연결 시, 새로운 채팅이 들어오면 실행할 콜백함수의 hooks\nexport const useOnReceiveChat = () =&gt; {\n  const setChatsUnreadTrigger = useSetRecoilState(chatsUnreadTrigger);\n  // 읽지 않은 채팅 개수를 다시 구할 때 쓰는 trigger\n  const setChatUpdate = useSetRecoilState(chatUpdateState);\n  // chat update를 다시 설정해주는 함수\n\n  return (chatDate: StompJs.Message) =&gt; {\n    const { body, headers } = chatDate;\n    // 새로운 stomp message에서 필요한 정보들을 파싱\n    const chat = JSON.parse(body);\n    const id = Number(headers.destination.split(\"/\").at(-1));\n    setChatsUnreadTrigger((prev) =&gt; prev + 1);\n    // 채팅 개수가 변하므로 읽지 않은 채팅 개수 다시 불러오기\n    setChatUpdate(({ trigger }) =&gt; ({ chat, id, trigger: trigger + 1 }));\n    // chat update를 stomp를 통해 들어온 값들로 변경\n  };\n};\n\n\n그리고 이 chatUpdate라는 store의 값이 바뀔 시, 이를 인지하고 자신의 정보인지를 확인한 뒤, 자신의 채팅 정보에 넣어주는 함수를 구성했습니다.\n\nconst {\n  id: updatedId,\n  chat: updatedChat,\n  trigger: chatUpdateTrigger,\n} = useRecoilValue(chatUpdateState);\n// store 정보를 불러옴\n\n...\n\nuseEffect(() =&gt; {\n  if (chatroomId !== updatedId || !updatedChat) return;\n\t// id값이 일치하지 않거나 정보가 없을 시 바로 리턴\n  setCurChats((chats) =&gt; [...chats, updatedChat]);\n\t// 새로 받은 채팅 정보를 기존 채팅 정보에 추가\n  scrollToBottom();\n}, [chatUpdateTrigger]);\n// 메세지를 받을 때마다 trigger를 통해 확인이 가능함\n\n\n\n   \n\n\n채팅 보내기\n\n기존 코드에서는 채팅을 보내는 상황에 대해서도 먼저 소켓을 새로 만들어 그 곳에서 채팅을 보내는 방법을 사용했었습니다.\n\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\nconst sock = new SockJs(sockServer);\nconst stompClient = StompJs.over(sock);\n\nexport const sendChat = ({ contents, chatroomId }: SendChatParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  const sendingURL = `/${APP}/${CHATROOMS}/${chatroomId}/${CHAT}`;\n\n  stompClient.send(sendingURL, headers, JSON.stringify({ contents }));\n};\n\n\n하지만, 위에서 살펴본 바와 같이, 한 번의 소켓 연결을 통해 문제를 해결했기 때문에, 현재 새롭게 사용될 sendChat 또한 이전 코드와 동일하지만, 같은 stompClient를 사용하게 됩니다.\n\n\n   \n\n\nconst handleSubmit = (event: FormEvent) =&gt; {\n\t...\n  sendChat({ contents: chatValue, chatroomId });\n};\n\n\nsubmit을 통해 채팅 입력을 완료하는 경우, 원하는 값과 id를 넣어 메세지를 보낼 수 있습니다.\n\n새로운 채팅 생성 후 바로 들어갈 때\n\n이 경우, 소켓에 해당 채팅에 대한 아이디가 구독되어 있지 않은 상황이라 채팅을 입력해도 바로 정보를 가져오지 못했습니다. 이를 해결하기 위해서 새로운 채팅에 들어가는 순간, 해당 채팅에 대한 stomp id를 찾고, 해당 값이 없는 경우 이전에 설정해둔 chatMap에서 값을 가져와 구독을 해주도록 했습니다.\n\nimport { chatMap, subscribeChat } from '@socket/stomp';\nimport { useOnReceiveChat } from '@socket/useConnectSocket';\n...\nconst stompId = chatMap.get(chatroomId);\n// 해당 채팅 아이디에 대한 stomp id 값을 구함\n...\nuseEffect(() =&gt; {\n  // when use question chat in share detail page\n  if (!stompId) subscribeChat({ onReceiveChat, chatroomId });\n\t// stomp id가 없을 시, 기존에 만든 onReceiveChat과 현재 채팅 아이디를 갖고 stomp에 구독\n\t...\n  };\n}, []);\n\n\n이를 통해 새로운 채팅이 생성될 경우에 대해서도 채팅이 바로 이루어질 수 있도록 처리했습니다.\n\n\n\n   \n\n\n\n   \n\n\n\n",
        "content": "이전 코드의 문제점\n\n기존에 stomp를 통한 socket 연결 시, socket에 연결되는 것들의 종류에 따라 나누어 stompClient를 직접 만들어 적용하는 방식을 사용하고 있었습니다.\n\n그로 인해 아래 사진과 같이 socket 연결을 두 번 진행하게 됐고, 이는 불필요한 연결을 반복하는 결과가 나오게 했습니다.\n\n\n   \n\n\n코드로는 아래와 같은 형태가 나오게 되며, 아래의 함수들을 각각 호출해 적용하는 형식이었습니다.\n\nexport const chatroomSocket = () =&gt; {\n  const sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\n  const sock = new SockJs(sockServer);\n  const stompClient = StompJs.over(sock);\n\t// 해당 부분에서 stompClient를 계속해서 새로 생성하게 됨\n\n  const subscribeChat = ({ onReceive, chatroomId, chatroomIds }: subscribeParamsType) =&gt; {\n    const headers = getAuthHeaders();\n    const subscribeToStomp = (id: string | number) =&gt; {\n      const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n      stompClient.subscribe(subscribeURL, onReceive, headers);\n    };\n\n    if (chatroomId) subscribeToStomp(chatroomId);\n    if (chatroomIds) chatroomIds.forEach((id) =&gt; subscribeToStomp(id));\n  };\n\nexport const noticeSocket = () =&gt; {\n  const sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\n  const sock = new SockJs(sockServer);\n  const stompClient = StompJs.over(sock);\n\t// 해당 부분에서 stompClient를 계속해서 새로 생성하게 됨\n\n  const subscribeNotice = ({\n    entryIds,\n    keywordIds,\n    onSubscribeEntries,\n    onSubscribeKeywords,\n  }: subscribeParamsType) =&gt; {\n    const subscribeURL = `/${QUEUE}/${NOTIFICATIONS}`;\n    const headers = getAuthHeaders();\n\n    if (!!entryIds.length) {\n      entryIds.forEach((id) =&gt; {\n        stompClient.subscribe(subscribeURL + `/${ENTRIES}/${id}`, onSubscribeEntries, headers);\n      });\n    }\n\n\n\n   \n\n\n‘stompClient’ 하나만 사용하기\n\n이 부분에서 stompClient를 하나만 호출하고, 이를 전체 App에서 연결, 구독, 연결 해제 등의 작업을 해야했습니다. 이를 위해 stompClient가 호출되는 위치를 상단으로 바꾸고, 이를 export하는 작업부터 진행했습니다.\n\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\nconst sock = new SockJs(sockServer);\nexport const stompClient = StompJs.over(sock);\n\n\n위와 같이 하나의 stompClient만을 생성하고, 이를 export해, 이 stompClient만을 이용해 소켓 연결을 할 수 있도록 했습니다. 그 다음 stompClient를 갖고 바로 구독을 하거나 연결을 하는 등의 행위를 할 수 있었습니다.\n\nexport const subscribeChat = ({\n  onReceiveChat,\n  chatroomId,\n  chatroomIds,\n}: subscribeChatParamsType) =&gt; {\n  const subscribeToStomp = (id: number) =&gt; {\n    const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n    const headers = getAuthHeaders();\n    const { id: stompId } = stompClient.subscribe(subscribeURL, onReceiveChat, headers);\n\t\t// stompClient를 바로 가져다 쓰도록 설정\n\t\t...\n\nexport const connectStomp = ({ noticeParams, chatParams }: ConnectStompParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  try {\n    // stompClient.debug = () =&gt; null; 이후 console로 나오는 stomp 관련 내용 제거에 사용\n    stompClient.connect(headers, () =&gt; {\n\t\t// stompClient에 바로 연결\n      subscribeNotice(noticeParams);\n      subscribeChat(chatParams);\n\t\t\t// 연결이 완료될 시, 바로 Notice, Chat의 구독 시 행위를 지정함\n\t\t\t...\n\n\n이 작업을 통해서 위 그림과 달리 아래처럼 하나의 stompClient만을 갖고 원하는 모든 알림, 채팅을 구독할 수 있었습니다.\n\n\n   \n\n\n새로운 채팅의 내용 가져오기\n\n기존에 채팅을 사용할 때에는, 채팅 상세 페이지에서 직접 소켓에 다시 한 번 연결하는 과정을 거치며, 그 과정에서 채팅 데이터 목록을 업데이트하는 코드를 직접 주입하는 방식으로 이루어졌었습니다.\n\n// 채팅 상세 페이지 내 새로운 채팅을 받는 함수\nconst getNewChatMessage = (chatData: StompJs.Message) =&gt; {\n  const newChat = JSON.parse(chatData.body);\n  // 새로운 채팅을 소켓으로부터 직접 받아(StompJs.Message), 기존 리스트에 업데이트 해주는 방식으로 되어 있음\n  setCurChats((chats) =&gt; {\n    const newChats = [...chats, newChat];\n\n    return newChats;\n  });\n  scrollToBottom();\n};\n\nuseEffect(() =&gt; {\n  const { disconnectChatroom, connectChatroom } = chatroomSocket();\n  connectChatroom({ onReceive: getNewChatMessage, chatroomId });\n  // 소켓에 직접 연결 및 채팅 받을 시 실행할 함수를 적용\n  return () =&gt; disconnectChatroom();\n  // 채팅방 나갈 시 소켓 연결 제거\n}, []);\n\n\n\n   \n\n\n하지만, 소켓을 한 번 연결하고, 채팅방에 들어올 때 별도의 소켓 연결을 더 하지 않으려면, 기존의 연결을 통해 바뀌는 값을 따로 저장해줄 필요가 있었습니다. 이를 처리하기 위해 기존에 사용하던 recoil의 atom을 통해서 값을 저장하는 store를 만들었습니다.\n\nexport type ChatroomsUpdate = {\n  id?: number;\n  chat?: ChatroomDetailChatType;\n  trigger: number;\n  // 같은 chat이 들어온 경우에 대한 구분이 필요해, trigger를 통한 구분을 하도록 설정\n};\n\nexport const chatUpdateState = atom&lt;ChatroomsUpdate&gt;({\n  key: \"chatUpdate\",\n  default: { trigger: 0 },\n});\n\n// stomp 연결 시, 새로운 채팅이 들어오면 실행할 콜백함수의 hooks\nexport const useOnReceiveChat = () =&gt; {\n  const setChatsUnreadTrigger = useSetRecoilState(chatsUnreadTrigger);\n  // 읽지 않은 채팅 개수를 다시 구할 때 쓰는 trigger\n  const setChatUpdate = useSetRecoilState(chatUpdateState);\n  // chat update를 다시 설정해주는 함수\n\n  return (chatDate: StompJs.Message) =&gt; {\n    const { body, headers } = chatDate;\n    // 새로운 stomp message에서 필요한 정보들을 파싱\n    const chat = JSON.parse(body);\n    const id = Number(headers.destination.split(\"/\").at(-1));\n    setChatsUnreadTrigger((prev) =&gt; prev + 1);\n    // 채팅 개수가 변하므로 읽지 않은 채팅 개수 다시 불러오기\n    setChatUpdate(({ trigger }) =&gt; ({ chat, id, trigger: trigger + 1 }));\n    // chat update를 stomp를 통해 들어온 값들로 변경\n  };\n};\n\n\n그리고 이 chatUpdate라는 store의 값이 바뀔 시, 이를 인지하고 자신의 정보인지를 확인한 뒤, 자신의 채팅 정보에 넣어주는 함수를 구성했습니다.\n\nconst {\n  id: updatedId,\n  chat: updatedChat,\n  trigger: chatUpdateTrigger,\n} = useRecoilValue(chatUpdateState);\n// store 정보를 불러옴\n\n...\n\nuseEffect(() =&gt; {\n  if (chatroomId !== updatedId || !updatedChat) return;\n\t// id값이 일치하지 않거나 정보가 없을 시 바로 리턴\n  setCurChats((chats) =&gt; [...chats, updatedChat]);\n\t// 새로 받은 채팅 정보를 기존 채팅 정보에 추가\n  scrollToBottom();\n}, [chatUpdateTrigger]);\n// 메세지를 받을 때마다 trigger를 통해 확인이 가능함\n\n\n\n   \n\n\n채팅 보내기\n\n기존 코드에서는 채팅을 보내는 상황에 대해서도 먼저 소켓을 새로 만들어 그 곳에서 채팅을 보내는 방법을 사용했었습니다.\n\nconst sockServer = `${process.env.REACT_APP_BASE_URL}/${WEBSOCKET}`; // 들어갈 주소 설정\nconst sock = new SockJs(sockServer);\nconst stompClient = StompJs.over(sock);\n\nexport const sendChat = ({ contents, chatroomId }: SendChatParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  const sendingURL = `/${APP}/${CHATROOMS}/${chatroomId}/${CHAT}`;\n\n  stompClient.send(sendingURL, headers, JSON.stringify({ contents }));\n};\n\n\n하지만, 위에서 살펴본 바와 같이, 한 번의 소켓 연결을 통해 문제를 해결했기 때문에, 현재 새롭게 사용될 sendChat 또한 이전 코드와 동일하지만, 같은 stompClient를 사용하게 됩니다.\n\n\n   \n\n\nconst handleSubmit = (event: FormEvent) =&gt; {\n\t...\n  sendChat({ contents: chatValue, chatroomId });\n};\n\n\nsubmit을 통해 채팅 입력을 완료하는 경우, 원하는 값과 id를 넣어 메세지를 보낼 수 있습니다.\n\n새로운 채팅 생성 후 바로 들어갈 때\n\n이 경우, 소켓에 해당 채팅에 대한 아이디가 구독되어 있지 않은 상황이라 채팅을 입력해도 바로 정보를 가져오지 못했습니다. 이를 해결하기 위해서 새로운 채팅에 들어가는 순간, 해당 채팅에 대한 stomp id를 찾고, 해당 값이 없는 경우 이전에 설정해둔 chatMap에서 값을 가져와 구독을 해주도록 했습니다.\n\nimport { chatMap, subscribeChat } from '@socket/stomp';\nimport { useOnReceiveChat } from '@socket/useConnectSocket';\n...\nconst stompId = chatMap.get(chatroomId);\n// 해당 채팅 아이디에 대한 stomp id 값을 구함\n...\nuseEffect(() =&gt; {\n  // when use question chat in share detail page\n  if (!stompId) subscribeChat({ onReceiveChat, chatroomId });\n\t// stomp id가 없을 시, 기존에 만든 onReceiveChat과 현재 채팅 아이디를 갖고 stomp에 구독\n\t...\n  };\n}, []);\n\n\n이를 통해 새로운 채팅이 생성될 경우에 대해서도 채팅이 바로 이루어질 수 있도록 처리했습니다.\n\n\n\n   \n\n\n\n   \n\n\n\n",
        "url": "/react/2022/10/21/stomp(socket)-%EB%8F%99%EC%8B%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/"
      },
    
      {
        "title": "stomp(socket) 연결 해제하기",
        "feature_text": "불필요한 stomp(socket) 연결 해제하기\n",
        "excerpt": "현재 소켓을 통해 채팅 연결을 지속하고 있었습니다. 이러한 상황에서 특정 채팅방을 나가는 경우, 해당 채팅방에 대한 알림은 더 이상 받을 필요가 없기 때문에 소켓을 유지한 상태에서 특정 소켓만 해제하는 작업이 필요했습니다.\n\n같은 id가 반복되는 문제\n\n소켓 연결 해제를 하기에 앞서, 연결 해제를 위해서는 id값이 필요한데, 소켓 연결 시 현재 같은 id 값으로만 연결을 해주는 상황입니다.\n\n\n   \n\n\n구독하는 상황에서 이는 headers를 직접 넣어주는 경우 해결이 됩니다.\n\nconst subscribeToStomp = (id: string | number) =&gt; {\n  const headers = getAuthHeaders();\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n  stompClient.subscribe(subscribeURL, onReceive, headers);\n};\n\n\n\n   \n\n\n처음에는 stompClient.unsubscribe를 사용하기 위해 필요한 id값을 빼내는 데에 필요하다고 판단해 이와 같은 상황을 먼저 만들었으나, 구독을 하는 동시에 생성되는 값에서 id,unsubscribe()가 존재한다는 것을 발견했습니다.\n\n\n   \n\n\n현재 의문점으로 갖고 있는 것은, 같은 id를 갖고 있는 상황에서도, 저 unsubscribe() 함수를 쓰는 상황에서는 각각을 분리해 구독을 끊는 것인지, 아니면 같은 id를 갖고 있는 것들에 대해 모두 구독을 끊는 것인지 입니다. 이에 대한 제대로 된 문서를 찾기 어려워 직접 적용을 해보게 됐습니다.\n\n\n\n‘sub-0’ id들로만 이루어진 곳에 구독을 끊을 시\n\n\n   \n\n\n‘sub-0’ id로만 이루어진 소켓에 연결을 끊는 작업을 진행할 시, 이후 들어오는 메세지에 대해 위 사진과 같은 결과를 알려주게 됩니다. ‘sub-0’라는 id를 통해 들어온 또 다른 메세지가 있으며, 이 메세지에 대해 핸들링이 이루어지지 않았음을 알려주게 되어, 원하는 기능을 위해서는 정확하게 id값이 분리되어야 한다는 것을 알 수 있었습니다.\n\n앞서 나와있던 unsubscribe() 함수 역시 결국 해당 id값에 대해서 구독 해제를 하는 것이라 판단했고, id를 저장해 필요한 id를 꺼내 쓰기로 결정했습니다.\n\n\n\nid를 직접적으로 넣어주어 구독 끊기\n\n위의 방법이 안 된다는 것을 알고난 뒤, 소켓의 연결을 끊기 위해 사용할 방법들을 찾아봤습니다. 현재 연결된 stomp(소켓)내에서 연결이 이루어지는 경우(stompClient.subscribe)에 리턴하게 되는 id값들을 가지고 있어야하는데, 이 값들을 담아두고, 필요할 때 바로 꺼내서 사용하기 위해 JS의 Map을 사용해 이 값들을 정리해주게 됐습니다.\n\nexport const chatMap = new Map&lt;number, string&gt;();\n// id에 맞는 stompId값을 바로 빼내게 위해 map을 사용\n\nconst subscribeToStomp = (id: number) =&gt; {\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n  const headers = getAuthHeaders();\n  const { id: stompId } = stompClient.subscribe(subscribeURL, onReceiveChat, headers);\n\t// 구독이 완료될 시 나오는 stomp id값을 꺼냄\n  chatMap.set(id, stompId);\n\t// 채팅방의 id값에 stomp id값을 대입시켜서 저장함\n};\n\n\n위와 같은 방법을 통해 채팅방의 id를 알고 있으면 stomp에 연결된 stomp id를 빼낼 수 있게 되고, 그 stomp id를 통해 stomp 연결을 해제할 수 있게 됩니다.\n\nconst handleClickSelectOkBtn = async () =&gt; {\n  // 채팅을 나갈 때 사용하는 함수\n  if (!deletedId) return;\n  const { id, chatRoomMemberId } = deletedId;\n  // 필요한 id값들을 받아옴\n  const response = await deleteChatroomData(id);\n  if (response.status === 200) {\n    // 서버에서 채팅을 나갔다는 응답이 올 경우\n    const stompId = chatMap.get(chatRoomMemberId);\n    // 해당 stompId를 받아옴\n    unsubscribeStomp(stompId);\n    // id를 통해 구독 해제\n    setChatroomsTrigger((trigger) =&gt; trigger + 1);\n    setDeletedId(null);\n  }\n  setIsSelectModal(false);\n};\n\n\n\n   \n\n\n",
        "content": "현재 소켓을 통해 채팅 연결을 지속하고 있었습니다. 이러한 상황에서 특정 채팅방을 나가는 경우, 해당 채팅방에 대한 알림은 더 이상 받을 필요가 없기 때문에 소켓을 유지한 상태에서 특정 소켓만 해제하는 작업이 필요했습니다.\n\n같은 id가 반복되는 문제\n\n소켓 연결 해제를 하기에 앞서, 연결 해제를 위해서는 id값이 필요한데, 소켓 연결 시 현재 같은 id 값으로만 연결을 해주는 상황입니다.\n\n\n   \n\n\n구독하는 상황에서 이는 headers를 직접 넣어주는 경우 해결이 됩니다.\n\nconst subscribeToStomp = (id: string | number) =&gt; {\n  const headers = getAuthHeaders();\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n  stompClient.subscribe(subscribeURL, onReceive, headers);\n};\n\n\n\n   \n\n\n처음에는 stompClient.unsubscribe를 사용하기 위해 필요한 id값을 빼내는 데에 필요하다고 판단해 이와 같은 상황을 먼저 만들었으나, 구독을 하는 동시에 생성되는 값에서 id,unsubscribe()가 존재한다는 것을 발견했습니다.\n\n\n   \n\n\n현재 의문점으로 갖고 있는 것은, 같은 id를 갖고 있는 상황에서도, 저 unsubscribe() 함수를 쓰는 상황에서는 각각을 분리해 구독을 끊는 것인지, 아니면 같은 id를 갖고 있는 것들에 대해 모두 구독을 끊는 것인지 입니다. 이에 대한 제대로 된 문서를 찾기 어려워 직접 적용을 해보게 됐습니다.\n\n\n\n‘sub-0’ id들로만 이루어진 곳에 구독을 끊을 시\n\n\n   \n\n\n‘sub-0’ id로만 이루어진 소켓에 연결을 끊는 작업을 진행할 시, 이후 들어오는 메세지에 대해 위 사진과 같은 결과를 알려주게 됩니다. ‘sub-0’라는 id를 통해 들어온 또 다른 메세지가 있으며, 이 메세지에 대해 핸들링이 이루어지지 않았음을 알려주게 되어, 원하는 기능을 위해서는 정확하게 id값이 분리되어야 한다는 것을 알 수 있었습니다.\n\n앞서 나와있던 unsubscribe() 함수 역시 결국 해당 id값에 대해서 구독 해제를 하는 것이라 판단했고, id를 저장해 필요한 id를 꺼내 쓰기로 결정했습니다.\n\n\n\nid를 직접적으로 넣어주어 구독 끊기\n\n위의 방법이 안 된다는 것을 알고난 뒤, 소켓의 연결을 끊기 위해 사용할 방법들을 찾아봤습니다. 현재 연결된 stomp(소켓)내에서 연결이 이루어지는 경우(stompClient.subscribe)에 리턴하게 되는 id값들을 가지고 있어야하는데, 이 값들을 담아두고, 필요할 때 바로 꺼내서 사용하기 위해 JS의 Map을 사용해 이 값들을 정리해주게 됐습니다.\n\nexport const chatMap = new Map&lt;number, string&gt;();\n// id에 맞는 stompId값을 바로 빼내게 위해 map을 사용\n\nconst subscribeToStomp = (id: number) =&gt; {\n  const subscribeURL = `/${TOPIC}/${CHATROOM_MEMBERS}/${id}`;\n  const headers = getAuthHeaders();\n  const { id: stompId } = stompClient.subscribe(subscribeURL, onReceiveChat, headers);\n\t// 구독이 완료될 시 나오는 stomp id값을 꺼냄\n  chatMap.set(id, stompId);\n\t// 채팅방의 id값에 stomp id값을 대입시켜서 저장함\n};\n\n\n위와 같은 방법을 통해 채팅방의 id를 알고 있으면 stomp에 연결된 stomp id를 빼낼 수 있게 되고, 그 stomp id를 통해 stomp 연결을 해제할 수 있게 됩니다.\n\nconst handleClickSelectOkBtn = async () =&gt; {\n  // 채팅을 나갈 때 사용하는 함수\n  if (!deletedId) return;\n  const { id, chatRoomMemberId } = deletedId;\n  // 필요한 id값들을 받아옴\n  const response = await deleteChatroomData(id);\n  if (response.status === 200) {\n    // 서버에서 채팅을 나갔다는 응답이 올 경우\n    const stompId = chatMap.get(chatRoomMemberId);\n    // 해당 stompId를 받아옴\n    unsubscribeStomp(stompId);\n    // id를 통해 구독 해제\n    setChatroomsTrigger((trigger) =&gt; trigger + 1);\n    setDeletedId(null);\n  }\n  setIsSelectModal(false);\n};\n\n\n\n   \n\n\n",
        "url": "/react/2022/10/21/stomp(socket)-%EC%97%B0%EA%B2%B0-%ED%95%B4%EC%A0%9C%ED%95%98%EA%B8%B0/"
      },
    
      {
        "title": "stomp(socket) 연결 실패 시 알림",
        "feature_text": "socket 연결 실패 시 사용자에게 보여줄 컴포넌트 만들기\n",
        "excerpt": "현재 socket과 관련된 작업을 하면서 socket이 연결됐을 때에 대한 처리는 모두 완료가 되었으나, socket이 처음부터 연결되지 않은 상황에 대해서는 작업이 이루어지지 않았습니다. 이로 인해 사용자는 채팅, 알림 등 socket이 연결되지지 않은 상황임을 인지하지 못하고 계속 서비스를 이용하게 되어 문제가 발생합니다. 그래서 socket이 처음부터 연결되지 않거나, 중간에 끊긴 상황에 대한 알림을 줄 수 있어야 합니다.\n\nsocket의 연결 여부를 확인하는 방법\n\n우선적으로 socket이 연결 여부를 확인하는 값이 필요했습니다. 그래서 socket에 직접적인 socket 연결 여부를 확인하는 값을 가져오고자 했었습니다.\n\nexport const stompClient = StompJs.over(sock);\n\n\n위 코드를 입력한 후, 해당 값을 console을 통해 확인해보면, 아래와 같이 connected라는 값이 있고, 이 값을 통해서 연결 여부를 확인해줄 수 있습니다.\n\n\n   \n\n\n하지만, socket의 첫 연결은 무조건적으로 false에서 시작하기 때문에, 위 connected가 바뀌는 것을 따로 기다린 후 원하는 결과를 만드는 것보다, 연결이 된 후에 실행할 수 있는 콜백함수를 넘기는 것이 더 낫다는 판단을 했습니다. 그리고 socket이 연결되었음을 확인할 수 있는 상태(atom)를 하나 갖는 것도 필요하다고 판단했습니다.\n\n// 소켓 연결 여부를 갖고 있는 atom\nexport const socketConnectState = atom&lt;boolean&gt;({\n  key: \"socketConnect\",\n  default: false,\n});\n\n\nexport const stompClient = StompJs.over(sock);\n...\n\ntype ConnectStompParamsType = {\n  noticeParams: subscribeNoticeParamsType;\n  chatParams: subscribeChatParamsType;\n  onConnect: () =&gt; void;\n  onError: () =&gt; void;\n};\n\nexport const connectStomp = ({\n  noticeParams,\n  chatParams,\n  onConnect,\n  onError,\n}: ConnectStompParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  try {\n\t\t// stompClient로 성공적으로 연결될 경우 첫번째 콜백, 에러가 나올 시 두번째 콜백이 실행됨\n    stompClient.connect(\n      headers,\n      () =&gt; {\n        onConnect();\n        subscribeNotice(noticeParams);\n        subscribeChat(chatParams);\n      },\n      () =&gt; {\n        onError();\n      },\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\nconst setSocketConnect = useSetRecoilState(socketConnectState);\n// 소켓 연결여부를 확인하는 atom을 불러옴\n...\nconnectStomp({\n\t// 연결 성공, 실패 여부에 따라 atom의 값이 바뀌도록 설정\n  onError: () =&gt; setSocketConnect(false),\n  onConnect: () =&gt; setSocketConnect(true),\n  noticeParams: {\n    entryIds,\n    keywordIds,\n    onSubscribeEntries: onSubscribeNotice,\n    onSubscribeKeywords: onSubscribeNotice,\n  },\n  chatParams: { chatroomIds, onReceiveChat },\n});\n\n\n위와 같은 방식을 통해 소켓의 연결 성공, 실패에 따른 atom 값의 설정이 가능해졌습니다. 하지만, 여기서 발생한 또 다른 문제점은 정상적으로 연결이 되는 상황에 대해서도 처음에는 false 값을 갖고, 이후 연결이 된 상황에서 true값을 갖는다는 점입니다.\n\n\n   \n\n\ntrue값을 가짐으로 인해, 연결 유무를 갖고 보일지에 대한 유무를 갖고 있는 컴포넌트는 처음에 보였다가 사라지는 형태로 유지됩니다.\n\n연결 상태의 초기값을 ‘true’로 할 때의 문제점\n\n이를 해결하기 위한 방법으로, 처음에 true로 설정된 뒤, 연결이 잘못된 상황이 발생할 때에만 false가 나오는 것을 고려했습니다. 하지만, 이 방법으로 진행할 시, 이후 이 연결 여부를 갖고 즉각적인 행동을 하게 되는 다른 컴포넌트가 존재할 때 문제가 발생하기 때문에, true를 초기값으로 설정하는 것을 자제했습니다.\n\n그래서 이후 결정한 방법은 사용하는 컴포넌트 내에서 시간 제한을 두는 방법을 쓰게 됐습니다.\n\n자체적인 시간 제한을 두어 연결 여부 확인하기\n\n현재 연결 여부를 사용하는 컴포넌트 TopFixedWarning에서 자체적인 연결 여부 관련 상태를 둠으로써 문제를 해결할 수 있었습니다. 거기에, 이 컴포넌트에서만 따로 시간 제한을 두어 일정 시간이 지난 상황에서도 연결이 제대로 되지 않은 경우 연결이 되지 않았다는 상태로 바뀌도록 설정했습니다.\n\nconst waitingCheckTime = 5000; // ms\n\nconst TopFixedWarinng = ({\n  text,\n  isShowed,\n  otherStyle,\n}: TopFixedWarningPropsType) =&gt; {\n  const socketConnect = useRecoilValue(socketConnectState);\n  // 앱 전체적으로 사용하는 소켓 연결 여부 상태를 가져옴\n  const [isConnected, setIsConnected] = useState(true);\n  // 현재 컴포넌트에서만 사용하는 연결여부 확인 상태\n  const [timeOver, setTimeOver] = useState(false);\n  // 시간 초과 여부를 확인하는 상태\n\n  const handleClickEvent = () =&gt; {\n    window.location.reload();\n  };\n\n  // 앱에서의 소켓 연결 상태에 변화가 있을 시, 동시에 시간이 이미 초과한 상황에서 자체적인 소켓 연결 여부를 지정할 수 있게 함\n  useEffect(() =&gt; {\n    if (!timeOver) return;\n    setIsConnected(socketConnect);\n  }, [socketConnect]);\n\n  // time out을 설정해, 일정 시간이 지나간 경우 timeover 상태를 true로 바꾸고 소켓 연결 여부를 현재 컴포넌트에 알림\n  useTimeout(() =&gt; {\n    setTimeOver(true);\n    setIsConnected(socketConnect);\n  }, waitingCheckTime);\n\n  return (\n    &lt;S.Wrapper\n      isShowed={isShowed || !isConnected} // 자체적으로 받은 props와 자체적인 연결 여부 상태를 통해 보여줄 지에 대한 여부를 지정함\n      otherStyle={otherStyle}\n      onClick={handleClickEvent}\n    &gt;\n      &lt;Icon iconName=\"Warning\" iconSize={1.25} /&gt;\n      &lt;S.TextWrapper&gt;{text}&lt;/S.TextWrapper&gt;\n    &lt;/S.Wrapper&gt;\n  );\n};\n\n\n컴포넌트 내에 자체적인 연결 상태를 지정해준 이유는 소켓 연결 시간이 사용자의 예상 시간보다 긴 경우, 사용자가 소켓과 관련된 기능이 동작하지 않는다는 것을 예상하지 못한 채 계속 활동을 이어갈 수 있기 때문에, 자체적인 연결 상태 지정(isConnected)과 시간 초과 여부(timeover)를 두어 특정 시간(여기서는 5초)이 지날 시 소켓의 상태를 즉각 반영하도록 설정했습니다.\n\n\n   \n\n\n위와 같이 특정 시간(5초)가 지나가면 소켓이 연결되지 않을 시 문제가 있음을 알려줄 수 있게 됩니다.\n",
        "content": "현재 socket과 관련된 작업을 하면서 socket이 연결됐을 때에 대한 처리는 모두 완료가 되었으나, socket이 처음부터 연결되지 않은 상황에 대해서는 작업이 이루어지지 않았습니다. 이로 인해 사용자는 채팅, 알림 등 socket이 연결되지지 않은 상황임을 인지하지 못하고 계속 서비스를 이용하게 되어 문제가 발생합니다. 그래서 socket이 처음부터 연결되지 않거나, 중간에 끊긴 상황에 대한 알림을 줄 수 있어야 합니다.\n\nsocket의 연결 여부를 확인하는 방법\n\n우선적으로 socket이 연결 여부를 확인하는 값이 필요했습니다. 그래서 socket에 직접적인 socket 연결 여부를 확인하는 값을 가져오고자 했었습니다.\n\nexport const stompClient = StompJs.over(sock);\n\n\n위 코드를 입력한 후, 해당 값을 console을 통해 확인해보면, 아래와 같이 connected라는 값이 있고, 이 값을 통해서 연결 여부를 확인해줄 수 있습니다.\n\n\n   \n\n\n하지만, socket의 첫 연결은 무조건적으로 false에서 시작하기 때문에, 위 connected가 바뀌는 것을 따로 기다린 후 원하는 결과를 만드는 것보다, 연결이 된 후에 실행할 수 있는 콜백함수를 넘기는 것이 더 낫다는 판단을 했습니다. 그리고 socket이 연결되었음을 확인할 수 있는 상태(atom)를 하나 갖는 것도 필요하다고 판단했습니다.\n\n// 소켓 연결 여부를 갖고 있는 atom\nexport const socketConnectState = atom&lt;boolean&gt;({\n  key: \"socketConnect\",\n  default: false,\n});\n\n\nexport const stompClient = StompJs.over(sock);\n...\n\ntype ConnectStompParamsType = {\n  noticeParams: subscribeNoticeParamsType;\n  chatParams: subscribeChatParamsType;\n  onConnect: () =&gt; void;\n  onError: () =&gt; void;\n};\n\nexport const connectStomp = ({\n  noticeParams,\n  chatParams,\n  onConnect,\n  onError,\n}: ConnectStompParamsType) =&gt; {\n  const headers = getAuthHeaders();\n  try {\n\t\t// stompClient로 성공적으로 연결될 경우 첫번째 콜백, 에러가 나올 시 두번째 콜백이 실행됨\n    stompClient.connect(\n      headers,\n      () =&gt; {\n        onConnect();\n        subscribeNotice(noticeParams);\n        subscribeChat(chatParams);\n      },\n      () =&gt; {\n        onError();\n      },\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n\n\nconst setSocketConnect = useSetRecoilState(socketConnectState);\n// 소켓 연결여부를 확인하는 atom을 불러옴\n...\nconnectStomp({\n\t// 연결 성공, 실패 여부에 따라 atom의 값이 바뀌도록 설정\n  onError: () =&gt; setSocketConnect(false),\n  onConnect: () =&gt; setSocketConnect(true),\n  noticeParams: {\n    entryIds,\n    keywordIds,\n    onSubscribeEntries: onSubscribeNotice,\n    onSubscribeKeywords: onSubscribeNotice,\n  },\n  chatParams: { chatroomIds, onReceiveChat },\n});\n\n\n위와 같은 방식을 통해 소켓의 연결 성공, 실패에 따른 atom 값의 설정이 가능해졌습니다. 하지만, 여기서 발생한 또 다른 문제점은 정상적으로 연결이 되는 상황에 대해서도 처음에는 false 값을 갖고, 이후 연결이 된 상황에서 true값을 갖는다는 점입니다.\n\n\n   \n\n\ntrue값을 가짐으로 인해, 연결 유무를 갖고 보일지에 대한 유무를 갖고 있는 컴포넌트는 처음에 보였다가 사라지는 형태로 유지됩니다.\n\n연결 상태의 초기값을 ‘true’로 할 때의 문제점\n\n이를 해결하기 위한 방법으로, 처음에 true로 설정된 뒤, 연결이 잘못된 상황이 발생할 때에만 false가 나오는 것을 고려했습니다. 하지만, 이 방법으로 진행할 시, 이후 이 연결 여부를 갖고 즉각적인 행동을 하게 되는 다른 컴포넌트가 존재할 때 문제가 발생하기 때문에, true를 초기값으로 설정하는 것을 자제했습니다.\n\n그래서 이후 결정한 방법은 사용하는 컴포넌트 내에서 시간 제한을 두는 방법을 쓰게 됐습니다.\n\n자체적인 시간 제한을 두어 연결 여부 확인하기\n\n현재 연결 여부를 사용하는 컴포넌트 TopFixedWarning에서 자체적인 연결 여부 관련 상태를 둠으로써 문제를 해결할 수 있었습니다. 거기에, 이 컴포넌트에서만 따로 시간 제한을 두어 일정 시간이 지난 상황에서도 연결이 제대로 되지 않은 경우 연결이 되지 않았다는 상태로 바뀌도록 설정했습니다.\n\nconst waitingCheckTime = 5000; // ms\n\nconst TopFixedWarinng = ({\n  text,\n  isShowed,\n  otherStyle,\n}: TopFixedWarningPropsType) =&gt; {\n  const socketConnect = useRecoilValue(socketConnectState);\n  // 앱 전체적으로 사용하는 소켓 연결 여부 상태를 가져옴\n  const [isConnected, setIsConnected] = useState(true);\n  // 현재 컴포넌트에서만 사용하는 연결여부 확인 상태\n  const [timeOver, setTimeOver] = useState(false);\n  // 시간 초과 여부를 확인하는 상태\n\n  const handleClickEvent = () =&gt; {\n    window.location.reload();\n  };\n\n  // 앱에서의 소켓 연결 상태에 변화가 있을 시, 동시에 시간이 이미 초과한 상황에서 자체적인 소켓 연결 여부를 지정할 수 있게 함\n  useEffect(() =&gt; {\n    if (!timeOver) return;\n    setIsConnected(socketConnect);\n  }, [socketConnect]);\n\n  // time out을 설정해, 일정 시간이 지나간 경우 timeover 상태를 true로 바꾸고 소켓 연결 여부를 현재 컴포넌트에 알림\n  useTimeout(() =&gt; {\n    setTimeOver(true);\n    setIsConnected(socketConnect);\n  }, waitingCheckTime);\n\n  return (\n    &lt;S.Wrapper\n      isShowed={isShowed || !isConnected} // 자체적으로 받은 props와 자체적인 연결 여부 상태를 통해 보여줄 지에 대한 여부를 지정함\n      otherStyle={otherStyle}\n      onClick={handleClickEvent}\n    &gt;\n      &lt;Icon iconName=\"Warning\" iconSize={1.25} /&gt;\n      &lt;S.TextWrapper&gt;{text}&lt;/S.TextWrapper&gt;\n    &lt;/S.Wrapper&gt;\n  );\n};\n\n\n컴포넌트 내에 자체적인 연결 상태를 지정해준 이유는 소켓 연결 시간이 사용자의 예상 시간보다 긴 경우, 사용자가 소켓과 관련된 기능이 동작하지 않는다는 것을 예상하지 못한 채 계속 활동을 이어갈 수 있기 때문에, 자체적인 연결 상태 지정(isConnected)과 시간 초과 여부(timeover)를 두어 특정 시간(여기서는 5초)이 지날 시 소켓의 상태를 즉각 반영하도록 설정했습니다.\n\n\n   \n\n\n위와 같이 특정 시간(5초)가 지나가면 소켓이 연결되지 않을 시 문제가 있음을 알려줄 수 있게 됩니다.\n",
        "url": "/react/2022/10/22/stomp(socket)-%EC%97%B0%EA%B2%B0-%EC%8B%A4%ED%8C%A8/"
      },
    
      {
        "title": "IP, TCP ∙ UDP",
        "feature_text": "HTTP의 기본적인 IP, TCP ∙ UDP 알아보기\n",
        "excerpt": "IP(Internet Protocol)\n\nIP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다.\n\n클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 ‘패킷’이라는 단위를 사용합니다.\n\n클라이언트 주소, 서버 주소, 보낼 내용 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다.\n\n\n   \n\n\n문제점\n\n\n  비연결성 : 패킷 대상이 없거나 불능이어도 보내게 됩니다.\n  비신뢰성 : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다.\n    \n      중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다.\n      1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다.\n    \n  \n  프로그램 구분 : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다.\n\n\n\n\nTCP/UDP\n\n인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다.\n\n\n  애플리케이션 계층 - HTTP, FTP\n  전송 계층 - TDP, UDP (IP 보완)\n  인터넷 계층 - IP\n  네트워크 인터페이스 계층 - LAN 드라이버 등\n\n\n순서\n\n\n   \n\n\n\n  일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달\n  OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함\n  이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄\n  서버로 전송\n\n\nIP, TCP 패킷 정보\n\n패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다.\n\nTCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다.\n\n\n   \n\n\nTCP의 특징\n\n\n  TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다.\n  먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake)\n  데이터가 상대에게 제대로 보내졌는지를 확인하는 데이터 전달 보증이 이루어집니다.\n  데이터가 보낸 순서대로 도착하도록 하는 순서 보증의 역할을 합니다.\n  위와 같은 기능들을 갖고 있어 신뢰가능한 프로토콜입니다.\n\n\nTCP 3 way handshake\n\n클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다.\n\n\n  클라이언트가 서버에게 요청\n  서버가 요청을 수락하고 다시 클라이언트에게 요청\n  클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송)\n  데이터 전송\n\n\n\n   \n\n\nTCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다.\n\n장점\n\n\n  전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다.\n  순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.)\n\n\n\n   \n\n\n\n\nUDP\n\n사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다.\n\nUDP의 특징\n\n\n  하얀 도화지에 비유되며 기능이 거의 없습니다.\n  연결 지향성을 띄며 3-way handshake가 없습니다.\n  데이터 전달 보증이나 순서 보증이 없습니다.\n  IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, 각 패킷의 용도를 구분하기 위해 PORT를 사용하며. 체크섬은 메세지가 제대로 된 것인지 확인하는 용도로 사용됩니다.\n  UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다.\n  주목받는 이유로 아래와 같은 사항들이 있습니다.\n    \n      TCP의 단점인 3 way handshake로 인한 시간\n      여러 데이터들로 인한 데이터 양 증가 → 속도 감소\n      TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움\n      무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음\n    \n  \n  UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.\n\n",
        "content": "IP(Internet Protocol)\n\nIP는 인터넷 프로토콜의 약자로, 인터넷이 가능한 네트워크 상에서 정보를 송 ∙ 수신하는 통신에 대한 규약을 의미합니다. 클라이언트와 서버는 각각의 IP를 갖고 있습니다.\n\n클라이언트와 서버는 각각의 지정된 IP 주소에 데이터를 전달하며, 데이터를 전달할 때에는 ‘패킷’이라는 단위를 사용합니다.\n\n클라이언트 주소, 서버 주소, 보낼 내용 이 세 가지를 적어서 인터넷으로 보내게 되면, 인터넷에서 자체적으로 서버에 보낼 수 있는 주소를 찾아가면서 나아갑니다.\n\n\n   \n\n\n문제점\n\n\n  비연결성 : 패킷 대상이 없거나 불능이어도 보내게 됩니다.\n  비신뢰성 : 중간에 패킷이 없어지거나 순서대로 도착하지 않는 문제가 발생합니다.\n    \n      중간에 케이블이 끊어지는 것과 같은 불가피한 하는 문제가 발생하면 결국 패킷이 없어집니다.\n      1500byte가 넘어가는 경우, 보통 끊어서 보내게 되는데, 이 때 순서를 지켜서 보내야 합니다. 하지만, 여러 패킷이 가는 경우, 중간에 패킷이 다른 순서로 더 먼저 갈 수도 있다는 문제가 발생합니다. 이를 해결하기 위해 TCP, UDP를 사용합니다.\n    \n  \n  프로그램 구분 : 같은 IP를 사용하는 서버에서 여러 애플리케이션이 통신될 경우 문제가 발생할 수 있습니다.\n\n\n\n\nTCP/UDP\n\n인터넷 프로토콜 스택은 4계층으로 이루어져 있습니다.\n\n\n  애플리케이션 계층 - HTTP, FTP\n  전송 계층 - TDP, UDP (IP 보완)\n  인터넷 계층 - IP\n  네트워크 인터페이스 계층 - LAN 드라이버 등\n\n\n순서\n\n\n   \n\n\n\n  일반적으로 사용하는 애플리케이션에서 socket library를 통해 메시지를 전달\n  OS에서 TCP 정보를 메세지에 포함 → IP 패킷을 그 TCP 정보에 포함\n  이더넷 프레임(MAC 주소 등이 포함)을 LAN 드라이버에서 포함 시켜서 인터넷으로 보냄\n  서버로 전송\n\n\nIP, TCP 패킷 정보\n\n패킷은 package(수하물)와 bugget(덩어리)의 합성어입니다. IP 패킷에는 출발지 IP, 목적지 IP가 들어갑니다.\n\nTCP 패킷에는 출발지 PORT, 목적지 PORT, 전송 제어 ∙ 순서 ∙ 검증 등과 관련된 정보 등이 들어옵니다.\n\n\n   \n\n\nTCP의 특징\n\n\n  TCP는 전송 제어 프로토콜(Transmission Control Protocol)입니다.\n  먼저 서로 연결이 되었는지를 확인하는 연결 지향성을 띕니다. (3 way handshake)\n  데이터가 상대에게 제대로 보내졌는지를 확인하는 데이터 전달 보증이 이루어집니다.\n  데이터가 보낸 순서대로 도착하도록 하는 순서 보증의 역할을 합니다.\n  위와 같은 기능들을 갖고 있어 신뢰가능한 프로토콜입니다.\n\n\nTCP 3 way handshake\n\n클라이언트와 서버가 서로 연결을 진행하는 과정으로, SYN, SYN + ACK, ACK의 과정으로 이루어집니다.\n\n\n  클라이언트가 서버에게 요청\n  서버가 요청을 수락하고 다시 클라이언트에게 요청\n  클라이언트가 요청을 수락 (현재는 발전되어 요청 수락과 동시에 데이터 전송)\n  데이터 전송\n\n\n\n   \n\n\nTCP의 연결은 옛날 전화선처럼 연결된 것이 아닙니다. 그저 클라이언트와 서버간 3-way handshake 과정이 성공했다는 것(논리적으로만 연결)을 의미합니다. 즉, 클라이언트와 서버 사이에 수 많은 서버들을 거치는 것은 달라지지 않습니다.\n\n장점\n\n\n  전달 보증 : 클라이언트가 서버에게 메세지를 보낼 때, 이에 대한 응답 유무를 확인해, 제대로 메세지가 보내졌는지를 확인할 수 있습니다.\n  순서 보장 : 패킷을 1, 2, 3 순서로 보냈는데 1, 3, 2의 순서로 도착하는 경우, 패킷 2부터 다시 보내도록 서버가 응답을 보냅니다. (서버가 최적화를 통해 해결을 할 수도 있습니다.)\n\n\n\n   \n\n\n\n\nUDP\n\n사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로, 데이터 통신을 위한 규약의 일종입니다.\n\nUDP의 특징\n\n\n  하얀 도화지에 비유되며 기능이 거의 없습니다.\n  연결 지향성을 띄며 3-way handshake가 없습니다.\n  데이터 전달 보증이나 순서 보증이 없습니다.\n  IP와 비슷하나 다른 점으로 PORT와 체크섬이 있습니다. 특정 IP로 여러 패킷이 오는 경우, 각 패킷의 용도를 구분하기 위해 PORT를 사용하며. 체크섬은 메세지가 제대로 된 것인지 확인하는 용도로 사용됩니다.\n  UDP를 사용하기 위해서는 애플리케이션에서 추가 작업이 필요합니다.\n  주목받는 이유로 아래와 같은 사항들이 있습니다.\n    \n      TCP의 단점인 3 way handshake로 인한 시간\n      여러 데이터들로 인한 데이터 양 증가 → 속도 감소\n      TCP가 이미 인터넷에서 많이 사용되고 있어 TCP는 추가 작업을 하기 어려움\n      무언가 추가적인 작업을 할 때 UDP 위에서 진행할 수 있음\n    \n  \n  UDP의 활용도가 올라가기 시작했는데, 이는 HTTP3 스팩에서 TCP/IP의 3 way 과정을 줄이기 위한 최적화 방법으로써 UDP 프로토콜을 활용하기 시작했기 때문입니다.\n\n",
        "url": "/http/2022/10/23/IP_TCP_UDP/"
      },
    
      {
        "title": "PORT ∙ DNS ∙ URI",
        "feature_text": "HTTP의 기본적인 PORT ∙ DNS ∙ URI 알아보기\n",
        "excerpt": "PORT\n\nPORT란 IP 내 프로세스 구분을 위해 사용하는 번호입니다. 보통 한 번에 둘 이상의 애플리케이션을 연결해야하는 상황에서 사용합니다.\n통신을 주고 받으면서 패킷이 오는 경우, 해당 패킷이 어느 곳에서 오는 패킷인지를 구분해야하는 문제가 발생합니다. 이 상황에서 데이터를 전송할 목적지 서버를 찾는 것이 IP, 서버 내에서 구분된 애플리케이션을 찾는 것이 PORT라고 볼 수 있습니다.\n\n\n   \n\n\nPORT의 특징\n\n\n  같은 IP 내 프로세스 구분\n    \n      아래 예시와 같이, 80포트로 클라이언트가 메세지를 보내고, 서버에서는 10010번 포트로 응답을 보내게 되면, 포트를 뒤에 붙여서 같이 보내게 됩니다.\n      이 상황에서 IP는 아파트, PORT는 몇 동 ∙ 몇 호라고 생각할 수 있습니다.\n    \n  \n\n\n\n   \n\n\n\n  0 - 65535가 할당 가능\n  1023까지는 잘 알려져서 일반적으로 사용하지 않음\n    \n      FTP : 20,21\n      TELNET : 23\n      HTTP : 80\n      HTTPS : 443\n    \n  \n\n\n\n\nDNS\n\nDNS는 Domain Name System의 줄임말로, 호스트 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행하기 위해 개발되었습니다.\n일종의 전화번호부와 같은 역할을 수행하며, IP가 숫자로만 이루어져 기억하기 어려운 것과 달리 특정 이름을 갖고 있어 기억을 하기에 용이합니다.\n접근을 원하는 경우 도메인 명으로 DNS 서버에 먼저 접근한 뒤, 해당 IP를 받아올 수 있습니다.\n\n\n   \n\n\n\n\nURI\n\nURI는 Uniform Resource Identifier의 줄임말로, 특정 리소스를 식별하는 역할을 수행합니다.\n\nURI, URL, URN의 차이\n\nURI 내에 URL(로케이터 : locator), URN(이름 : name) 두 가지가 존재합니다.\nURL은 리소스가 있는 위치를 지정하고, URN은 리소스에 자체적인 이름을 부여하는데, 이로 인해 URN 이름만으로 실제 리소스를 받는 방법이 보편화 되지 않아 URL을 주로 사용하게 됩니다.\n\n\n   \n\n\nURL의 특징\n\n\n  전체 문법 : scheme://[userInfo@]host:[:port]/[/path][?query][#fragment]\n  scheme\n    \n      주로 프로토콜이 사용되며 자원 접근 규칙으로서, http, https 등이 존재합니다.\n      http는 80, https는 443 포트를 주로 사용하며 이들은 생략이 가능합니다.\n(https는 http에 보안이 추가된 형태)\n    \n  \n  userInfo : URL에 사용자 정보를 포함해서 인증할 때 사용하나, 거의 사용되지 않습니다.\n  host : 도메인명, IP 주소를 직접 넣어서 사용합니다.\n  port : 접속 포트로, 일반적으로 웹 브라우저에서 생략이 가능합니다.\n  path : 리소스 경로를 나타내며 계층적 구조로 이루어지며, ‘profile/1223’ 과 같은 형태를 띕니다.\n  query : key=value의 형태로 이루어지며, ?로 시작하고 &amp;으로 추가가 가능합니다. query parameter, query string(모두 문자로 넘어가기 때문에) 등으로 불립니다.\n  fragment : html 내부 북마크 등에 사용합니다. 서버로 전송되지는 않습니다.\n\n\n\n\nURI 접속 흐름\n\n\n   \n\n\n\n  DNS 조회, PORT 조회\n  HTTP 요청 메시지 생성\n  Socket Library에서 handshake 과정을 통해 서버와 연결\n  데이터 전송\n  서버가 HTTP 응답 메시지 생성\n  응답 패킷이 클라이언트에 도착\n  클라이언트에서 해당 내용으로 렌더링\n\n",
        "content": "PORT\n\nPORT란 IP 내 프로세스 구분을 위해 사용하는 번호입니다. 보통 한 번에 둘 이상의 애플리케이션을 연결해야하는 상황에서 사용합니다.\n통신을 주고 받으면서 패킷이 오는 경우, 해당 패킷이 어느 곳에서 오는 패킷인지를 구분해야하는 문제가 발생합니다. 이 상황에서 데이터를 전송할 목적지 서버를 찾는 것이 IP, 서버 내에서 구분된 애플리케이션을 찾는 것이 PORT라고 볼 수 있습니다.\n\n\n   \n\n\nPORT의 특징\n\n\n  같은 IP 내 프로세스 구분\n    \n      아래 예시와 같이, 80포트로 클라이언트가 메세지를 보내고, 서버에서는 10010번 포트로 응답을 보내게 되면, 포트를 뒤에 붙여서 같이 보내게 됩니다.\n      이 상황에서 IP는 아파트, PORT는 몇 동 ∙ 몇 호라고 생각할 수 있습니다.\n    \n  \n\n\n\n   \n\n\n\n  0 - 65535가 할당 가능\n  1023까지는 잘 알려져서 일반적으로 사용하지 않음\n    \n      FTP : 20,21\n      TELNET : 23\n      HTTP : 80\n      HTTPS : 443\n    \n  \n\n\n\n\nDNS\n\nDNS는 Domain Name System의 줄임말로, 호스트 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행하기 위해 개발되었습니다.\n일종의 전화번호부와 같은 역할을 수행하며, IP가 숫자로만 이루어져 기억하기 어려운 것과 달리 특정 이름을 갖고 있어 기억을 하기에 용이합니다.\n접근을 원하는 경우 도메인 명으로 DNS 서버에 먼저 접근한 뒤, 해당 IP를 받아올 수 있습니다.\n\n\n   \n\n\n\n\nURI\n\nURI는 Uniform Resource Identifier의 줄임말로, 특정 리소스를 식별하는 역할을 수행합니다.\n\nURI, URL, URN의 차이\n\nURI 내에 URL(로케이터 : locator), URN(이름 : name) 두 가지가 존재합니다.\nURL은 리소스가 있는 위치를 지정하고, URN은 리소스에 자체적인 이름을 부여하는데, 이로 인해 URN 이름만으로 실제 리소스를 받는 방법이 보편화 되지 않아 URL을 주로 사용하게 됩니다.\n\n\n   \n\n\nURL의 특징\n\n\n  전체 문법 : scheme://[userInfo@]host:[:port]/[/path][?query][#fragment]\n  scheme\n    \n      주로 프로토콜이 사용되며 자원 접근 규칙으로서, http, https 등이 존재합니다.\n      http는 80, https는 443 포트를 주로 사용하며 이들은 생략이 가능합니다.\n(https는 http에 보안이 추가된 형태)\n    \n  \n  userInfo : URL에 사용자 정보를 포함해서 인증할 때 사용하나, 거의 사용되지 않습니다.\n  host : 도메인명, IP 주소를 직접 넣어서 사용합니다.\n  port : 접속 포트로, 일반적으로 웹 브라우저에서 생략이 가능합니다.\n  path : 리소스 경로를 나타내며 계층적 구조로 이루어지며, ‘profile/1223’ 과 같은 형태를 띕니다.\n  query : key=value의 형태로 이루어지며, ?로 시작하고 &amp;으로 추가가 가능합니다. query parameter, query string(모두 문자로 넘어가기 때문에) 등으로 불립니다.\n  fragment : html 내부 북마크 등에 사용합니다. 서버로 전송되지는 않습니다.\n\n\n\n\nURI 접속 흐름\n\n\n   \n\n\n\n  DNS 조회, PORT 조회\n  HTTP 요청 메시지 생성\n  Socket Library에서 handshake 과정을 통해 서버와 연결\n  데이터 전송\n  서버가 HTTP 응답 메시지 생성\n  응답 패킷이 클라이언트에 도착\n  클라이언트에서 해당 내용으로 렌더링\n\n",
        "url": "/http/2022/10/24/PORT-DNS-URI/"
      },
    
      {
        "title": "textarea 태그 Enter 처리 문제",
        "feature_text": "input과 textarea 차이로 인해 발생한 Enter 처리 문제\n",
        "excerpt": "input 태그를 textarea 태그로 바꾸기\n\n기존에 input 태그로 되어있던 채팅 입력창을 textarea 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. input 태그의 경우 Enter 키를 입력 시 바로 submit 이벤트가 발생하게 되는 것에 반해, textarea는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다.\n\nonKeyDown 이벤트 적용\n\nEnter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 onKeyDown이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다.\n\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey } = event;\n\n  if (key !== \"Enter\") return;\n  // Enter 키 여부 확인\n  if (!shiftKey) {\n    // Shift 키 여부 확인\n    sendCurChat();\n  } else {\n    setChatValue(chatValue + \"\\n\");\n    // 한 줄 띄운 값으로 기존 채팅값을 변경\n  }\n};\n\n\n그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 onChange 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다.\n\nconst handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { inputType } = event.nativeEvent as any;\n  //\n  if (inputType === 'insertLineBreak') return;\n  setChatValue(event.target.value);\n};\n\n\n이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘onChange 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 nativeEvent 객체 내에 존재하는 inputType을 찾아 Enter를 누를 시 보여주게 되는 ‘insertLineBreak’을 사용했습니다.\n(이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 any로 처리했습니다…)\n\n\n   \n\n\n위 과정을 통해서 Enter키를 누른 상황에는 onKeyDown, 누르지 않은 상황은 onChange에서 처리를 하는 방식을 사용했습니다.\n\nEnter 중복 처리 문제\n\n하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다.\n\n\n   \n\n\n이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 onKeyDown 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다.\n\n\n   \n\n\n\n   \n\n\n영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 keyCode를 사용하는 것이었는데, keyCode를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 keyCode 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다.\n\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey, keyCode } = event;\n  // 'keyCode' is deprecated but error occurs when just use 'key' in korean\n\n  if (key !== \"Enter\" || keyCode !== 13) return;\n  if (!shiftKey) {\n    sendCurChat();\n  } else {\n    setChatValue(chatValue + \"\\n\");\n  }\n};\n\n\n띄워쓰기 스타일 적용하기\n\n\n   \n\n\n띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘\\n’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다.\n\nwhite-space: pre-wrap;\n\n",
        "content": "input 태그를 textarea 태그로 바꾸기\n\n기존에 input 태그로 되어있던 채팅 입력창을 textarea 태그로 바꾸면서 Enter 키에 대한 이벤트 적용 방식을 변경하게 됐습니다. input 태그의 경우 Enter 키를 입력 시 바로 submit 이벤트가 발생하게 되는 것에 반해, textarea는 줄바꿈이 발생하기 때문에 이 부분에 대한 해결책이 필요했습니다.\n\nonKeyDown 이벤트 적용\n\nEnter키가 입력되는 상황에 대해서만 처리를 하면 되었기 때문에 onKeyDown이라는 이벤트 핸들러를 사용했습니다. 여기서 key가 Enter인 상황에 대해 처리를 해주었고, 더불어 Shift 키와 함께 눌리는 상황에는 한 줄 띄우기가 가능하도록 설정을 했습니다.\n\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey } = event;\n\n  if (key !== \"Enter\") return;\n  // Enter 키 여부 확인\n  if (!shiftKey) {\n    // Shift 키 여부 확인\n    sendCurChat();\n  } else {\n    setChatValue(chatValue + \"\\n\");\n    // 한 줄 띄운 값으로 기존 채팅값을 변경\n  }\n};\n\n\n그리고 Enter 키가 입력이 된 상황에 대해, 기존에 설정을 해두었던 onChange 함수에서는 Enter를 받지 않도록 해야됐기 때문에, 이 부분도 설정을 해주었습니다.\n\nconst handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { inputType } = event.nativeEvent as any;\n  //\n  if (inputType === 'insertLineBreak') return;\n  setChatValue(event.target.value);\n};\n\n\n이 부분을 설정하면서 어려움을 느꼈던 부분은 ‘onChange 이벤트에서 어떻게 Enter를 감지하는가’ 였습니다. 이 부분은 정확한 해결책이 나오지 않아, 우선 nativeEvent 객체 내에 존재하는 inputType을 찾아 Enter를 누를 시 보여주게 되는 ‘insertLineBreak’을 사용했습니다.\n(이 부분을 사용하면서 type 상의 에러가 발생했는데, 이 부분은 정확히 타입을 다시 적용할 방법을 찾지 못해 우선 임시적으로 any로 처리했습니다…)\n\n\n   \n\n\n위 과정을 통해서 Enter키를 누른 상황에는 onKeyDown, 누르지 않은 상황은 onChange에서 처리를 하는 방식을 사용했습니다.\n\nEnter 중복 처리 문제\n\n하지만, 이렇게 설정을 해도 문제가 발생했는데, 그 문제는 바로 한글을 입력할 때 채팅이 두 번씩 입력이 된다는 것이었습니다.\n\n\n   \n\n\n이 부분을 해결하기 위해서 우선 영어와 한글로 Enter 키를 입력할 때의 차이점을 찾는 것부터 했습니다. 아래 사진과 같이 onKeyDown 이벤트의 결과값이 나오게 되는데, 위 사진이 영어, 아래 사진이 한글입니다.\n\n\n   \n\n\n\n   \n\n\n영어로 입력하는 경우는 위 사진의 결과만 나오게 되며, 한글로 입력할 때는 위, 아래 사진의 결과가 나와, 결론적으로 Enter가 두 번 발생하게 되고, gif와 같이 한 글자씩 더 입력이 되는 과정을 거쳐 문제가 발생했습니다. 이를 해결하는 방법으로는 keyCode를 사용하는 것이었는데, keyCode를 사용하면서 우려가 되었던 부분은 현재 deprecated 되었다는 경고가 나왔기 때문입니다. 당장의 사용에는 문제가 없으나, 추후에 keyCode 외의 다른 방법을 찾아야한다는 단점이 존재하는 해결 방법을 사용했습니다.\n\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey, keyCode } = event;\n  // 'keyCode' is deprecated but error occurs when just use 'key' in korean\n\n  if (key !== \"Enter\" || keyCode !== 13) return;\n  if (!shiftKey) {\n    sendCurChat();\n  } else {\n    setChatValue(chatValue + \"\\n\");\n  }\n};\n\n\n띄워쓰기 스타일 적용하기\n\n\n   \n\n\n띄워쓰기를 적용해주었음에도 나오는 결과 상으로는 띄워쓰기가 제대로 되지 않는데, 이는 ‘\\n’이라는 줄바꿈값을 스타일적으로 처리하지 않았기 때문이었습니다. 이는 간단히 아래의 코드를 입력해 줄바꿈을 해줄 수 있었습니다.\n\nwhite-space: pre-wrap;\n\n",
        "url": "/react/2022/10/25/textarea-%EC%97%94%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C/"
      },
    
      {
        "title": "스크롤 시 header에 그림자 보여주기",
        "feature_text": "스크롤 시 header에 그림자 보여주기\n",
        "excerpt": "스크롤 여부를 확인하는 방법\n\n처음에는 new IntersactionObserver를 적용해 헤더의 바로 다음 요소가 가려지기 시작하면 스크롤이 되었다는 상태값을 바꿔주는 형식을 적용하고자 했었습니다. 하지만, 스크롤이 되는 순간부터 window.scrollY값이 바뀐다는 것을 알게 되었고, 굳이 더 복잡한 방식을 적용할 필요가 없다고 생각해 window.scrollY를 이용해 처리를 하도록 했습니다.\n\n그리고 스크롤이 되는 상황에 대해서 화면이 인지하고 상태를 바꿔야하기 때문에, window.onscroll에 함수를 적용해주었습니다.\n\nconst useIsTopState = () =&gt; {\n  const [isTop, setIsTop] = useState(true);\n  // 페이지의 최상단에 있는지를 나타내는 state\n\n  window.onscroll = () =&gt; {\n    setIsTop(!window.scrollY);\n    // 스크롤되는 화면의 최상단에 있을 시 scrollY = 0 이므로 isTop이 true가 됨\n  };\n\n  return isTop;\n};\n\n\n상태를 받은 header의 스타일 변경하기\n\nisTop 상태를 받은 header가 true일 때에만 그림자를 보여주지 않도록 설정을 해, 스크롤이 되는 상황에서 지속적으로 그림자를 보여주도록 설정했습니다.\n\nconst Chatrooms = () =&gt; {\n\t...\n  const isTop = useIsTopState();\n\t// isTop 상태를 받아옴\n\t...\n\t&lt;S.Wrapper&gt;\n    &lt;S.HeaderWrapper isTop={isTop}&gt;\n    // 사용하고자 하는 header에 적용\n      &lt;TopFixedWarning text='채팅 연결 끊김' otherStyle={S.TopFixedWarningStyle} /&gt;\n      &lt;S.Header onClick={() =&gt; setIsConnected(!isConnected)}&gt;\n\t...\n\n\nexport const HeaderWrapper = styled.div&lt;{ isTop: boolean }&gt;`\n  ${({ theme: { colors, defaultWidth, defaultPadding }, isTop }) =&gt; css`\n    ${defaultWidth};\n\t\t...\n    transition: all 0.3s;\n    // 그림자가 부드럽게 사라지고 나타나기 위해 설정\n\n    ${!isTop &amp;&amp;\n    css`\n      box-shadow: 2px 4px 6px rgba(0, 0, 0, 0.08);\n      // 최상단에 있을 때에만 그림자가 안 보이도록 설정\n    `}\n\n\n위 코드들을 적용해줌으로써, 스크롤 상황에 대한 그림자 표현을 할 수 있었습니다.\n\n\n   \n\n\nwindow.onscroll 값을 초기화해야 하는지\n\nuseEffect(() =&gt; {\n  return () =&gt; {\n    window.onscroll = null;\n  };\n}, []);\n\n\n기존에는 위와 같이 화면을 나가는 경우 window,onscroll을 초기화하도록 설정을 해주었습니다. 초기화를 하지 않는 경우, 이 함수가 사용되지 않는 곳에서도 지속적으로 함수가 작동해 불필요한 연산이 될 것이라는 예상 때문이었습니다. 하지만, 아래와 같이 useEffect가 없어도 화면 전환 시 onScroll의 함수는 없어진다는 것을 확인할 수 있었습니다. (console.log()로 확인)\n\n\n   \n\n\n",
        "content": "스크롤 여부를 확인하는 방법\n\n처음에는 new IntersactionObserver를 적용해 헤더의 바로 다음 요소가 가려지기 시작하면 스크롤이 되었다는 상태값을 바꿔주는 형식을 적용하고자 했었습니다. 하지만, 스크롤이 되는 순간부터 window.scrollY값이 바뀐다는 것을 알게 되었고, 굳이 더 복잡한 방식을 적용할 필요가 없다고 생각해 window.scrollY를 이용해 처리를 하도록 했습니다.\n\n그리고 스크롤이 되는 상황에 대해서 화면이 인지하고 상태를 바꿔야하기 때문에, window.onscroll에 함수를 적용해주었습니다.\n\nconst useIsTopState = () =&gt; {\n  const [isTop, setIsTop] = useState(true);\n  // 페이지의 최상단에 있는지를 나타내는 state\n\n  window.onscroll = () =&gt; {\n    setIsTop(!window.scrollY);\n    // 스크롤되는 화면의 최상단에 있을 시 scrollY = 0 이므로 isTop이 true가 됨\n  };\n\n  return isTop;\n};\n\n\n상태를 받은 header의 스타일 변경하기\n\nisTop 상태를 받은 header가 true일 때에만 그림자를 보여주지 않도록 설정을 해, 스크롤이 되는 상황에서 지속적으로 그림자를 보여주도록 설정했습니다.\n\nconst Chatrooms = () =&gt; {\n\t...\n  const isTop = useIsTopState();\n\t// isTop 상태를 받아옴\n\t...\n\t&lt;S.Wrapper&gt;\n    &lt;S.HeaderWrapper isTop={isTop}&gt;\n    // 사용하고자 하는 header에 적용\n      &lt;TopFixedWarning text='채팅 연결 끊김' otherStyle={S.TopFixedWarningStyle} /&gt;\n      &lt;S.Header onClick={() =&gt; setIsConnected(!isConnected)}&gt;\n\t...\n\n\nexport const HeaderWrapper = styled.div&lt;{ isTop: boolean }&gt;`\n  ${({ theme: { colors, defaultWidth, defaultPadding }, isTop }) =&gt; css`\n    ${defaultWidth};\n\t\t...\n    transition: all 0.3s;\n    // 그림자가 부드럽게 사라지고 나타나기 위해 설정\n\n    ${!isTop &amp;&amp;\n    css`\n      box-shadow: 2px 4px 6px rgba(0, 0, 0, 0.08);\n      // 최상단에 있을 때에만 그림자가 안 보이도록 설정\n    `}\n\n\n위 코드들을 적용해줌으로써, 스크롤 상황에 대한 그림자 표현을 할 수 있었습니다.\n\n\n   \n\n\nwindow.onscroll 값을 초기화해야 하는지\n\nuseEffect(() =&gt; {\n  return () =&gt; {\n    window.onscroll = null;\n  };\n}, []);\n\n\n기존에는 위와 같이 화면을 나가는 경우 window,onscroll을 초기화하도록 설정을 해주었습니다. 초기화를 하지 않는 경우, 이 함수가 사용되지 않는 곳에서도 지속적으로 함수가 작동해 불필요한 연산이 될 것이라는 예상 때문이었습니다. 하지만, 아래와 같이 useEffect가 없어도 화면 전환 시 onScroll의 함수는 없어진다는 것을 확인할 수 있었습니다. (console.log()로 확인)\n\n\n   \n\n\n",
        "url": "/javascript/2022/10/25/%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%8B%9C-header%EC%97%90-%EA%B7%B8%EB%A6%BC%EC%9E%90-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0/"
      },
    
      {
        "title": "textarea 높이 조절하기",
        "feature_text": "React에서 textarea 높이 조절하기\n",
        "excerpt": "줄바꿈이 발생할 때 채팅 높이를 늘리기\n\ntextarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다.\n\n\n   \n\n\n줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다.\n\nconst setAutoSize = () =&gt; {\n  if (!textareaRef.current) return;\n\n  const { scrollHeight: curHeight } = textareaRef.current.style;\n  // 현재의 scroll 높이를 구함\n\n  // maximum height is 83px when textarea has 3 line\n  if (curHeight &gt;= 90) return;\n  // 83보다 크고 110보다 작은 값으로 설정\n  textareaRef.current.style.height = `${curHeight}px`;\n  // 실제 textarea 높이를 스크롤 높이만큼 넓힘\n};\n\n\n하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다.\n\n\n   \n\n\n그림자 태그를 만들어 해결하기\n\n이를 해결하기 위한 방법을 찾아보던 도중, 링크를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다.\n실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다.\n현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다.\n\n\n   \n\n\nexport const ChatTextarea = styled.textarea&lt;{ isShadow?: boolean }&gt;`\n  ${({ theme: { colors, fonts }, isShadow = false }) =&gt; css`\n    ${fonts.main}\n    ${fonts.largeRegular}\n\n\t\t...\n\n    ${isShadow &amp;&amp;\n    // 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정\n    css`\n      height: 0px;\n      opacity: 0;\n    `}\n  `}\n`;\n\n\n우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, width는 그대로 두고, height 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\nconst shadowTextareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\n\n...\n\n/** get height with shadow textarea */\nconst setAutoSize = () =&gt; {\n  if (!textareaRef.current || !shadowTextareaRef.current) return;\n\n  const { scrollHeight: shadowHeight } = shadowTextareaRef.current;\n\t// 그림자의 scroll height를 이용해 높이를 구함\n  const { height: curHeight } = textareaRef.current.style;\n\n  // maximum height is 83px when textarea has 3 line\n  if (curHeight === `${shadowHeight}px` || shadowHeight &gt;= 90) return;\n\t// 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용\n  textareaRef.current.style.height = `${shadowHeight}px`;\n};\n\n...\n\nuseEffect(() =&gt; {\n  setAutoSize();\n}, [chatValue]);\n\n&lt;S.ChatTextareaWrapper&gt;\n  &lt;S.ChatTextarea\n    ref={textareaRef}\n    rows={1}\n    spellCheck={false}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    placeholder='메시지를 입력하세요.'\n  /&gt;\n\t// 그림자 태그를 만들어 뒤에 숨어있도록 설정\n  &lt;S.ChatTextarea\n    ref={shadowTextareaRef}\n    isShadow={true}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    readOnly\n    tabIndex={-1}\n  /&gt;\n&lt;/S.ChatTextareaWrapper&gt;\n\n\n이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다.\n\n\n   \n\n\n하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다.\n\n채팅창의 높이가 올라갈 때 채팅 내용도 올려주기\n\n이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, position: fixed로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 fixed가 아닌 일반적인 position 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다.\n\n이 부분에서 저는 fixed를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다.\n\nposition: fixed로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 onHeightChange라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다.\n\nconst [blockHeight, setBlockHeight] = useState(0);\n...\nconst scrollToBottom = () =&gt; {\n  lastBlockRef.current?.scrollIntoView({ block: 'end' });\n};\n...\nconst changeBlockHeight = (height: number) =&gt; {\n  setBlockHeight(height);\n  scrollToBottom();\n\t// 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정\n};\n\n...\n\nreturn (\n  &lt;&gt;\n    &lt;S.Wrapper&gt;\n      {chatroomLogs}\n      &lt;S.LastBottomBlock ref={scrollToBottomRef} blockHeight={blockHeight} /&gt;\n\t\t\t// 채팅창 뒤 빈 영역을 채워주는 블록\n    &lt;/S.Wrapper&gt;\n    &lt;ChatroomBar chatroomId={Number(chatroomId)} onHeightChange={changeBlockHeight} /&gt;\n\t\t// 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정\n  &lt;/&gt;\n);\n\n\n위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.\n\n\n   \n\n\n",
        "content": "줄바꿈이 발생할 때 채팅 높이를 늘리기\n\ntextarea 태그를 이용해 채팅 작성 기능을 만들면서, 최대 세 줄까지 늘어나고, 줄어드는 기능이 가능하도록 구현하고 있었습니다. 이를 위해 기존에 만들어진 textarea 태그에 스크롤이 발생하는 경우, 특정 길이 이하일 때 높이가 늘어날 수 있도록 만들었습니다.\n\n\n   \n\n\n줄이 1개, 2개, 3개일 때의 각각의 높이가 57, 83, 110인 것도 함께 확인했습니다.\n\nconst setAutoSize = () =&gt; {\n  if (!textareaRef.current) return;\n\n  const { scrollHeight: curHeight } = textareaRef.current.style;\n  // 현재의 scroll 높이를 구함\n\n  // maximum height is 83px when textarea has 3 line\n  if (curHeight &gt;= 90) return;\n  // 83보다 크고 110보다 작은 값으로 설정\n  textareaRef.current.style.height = `${curHeight}px`;\n  // 실제 textarea 높이를 스크롤 높이만큼 넓힘\n};\n\n\n하지만, 위 코드와 같이 작성할 경우 문제점이 발생하는데, 채팅창이 넓어지는 것은 가능하나, 이후 줄어드는 것이 불가능했습니다. 이는 이미 해당 요소의 값이 이미 커진 상태에서 글자를 제거해도 scroll height는 줄어들지 않는 데에서 발생하는 문제였습니다.\n\n\n   \n\n\n그림자 태그를 만들어 해결하기\n\n이를 해결하기 위한 방법을 찾아보던 도중, 링크를 통해 ‘그림자’를 만들어 해결하는 방법을 알게 되었습니다.\n실제 보여지는 textarea 1개, 내부에서 높이 계산을 위해 따로 존재하는 textarea 1개, 총 두 개를 만드는 형식이었습니다.\n현재 문제가 되는 부분이 위에서 말한 바와 같이, textarea의 크기가 이미 커진 상태에서는 scroll height가 줄어들지 않는 것이 문제였는데, 그림자 태그를 두고 그 내부에 같은 글자들이 계속 들어올 수 있게 설정을 하면, 그림자 태그의 scroll height는 외부 height가 변하지 않았기 때문에 한 줄일 때부터 세 줄일 때의 높이를 지속적으로 알려줄 수 있게 됩니다.\n\n\n   \n\n\nexport const ChatTextarea = styled.textarea&lt;{ isShadow?: boolean }&gt;`\n  ${({ theme: { colors, fonts }, isShadow = false }) =&gt; css`\n    ${fonts.main}\n    ${fonts.largeRegular}\n\n\t\t...\n\n    ${isShadow &amp;&amp;\n    // 그림자로 설정된 경우, 높이를 없애 보이지 않도록 설정\n    css`\n      height: 0px;\n      opacity: 0;\n    `}\n  `}\n`;\n\n\n우선 위와 같이 그림자 옵션이 들어갈 시, 보이지 않는 태그가 만들어지도록 설정했습니다. 이 때, width는 그대로 두고, height 값의 변화만 주어, 같은 길이의 text에서 높이가 변할 수 있도록 설정했습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\nconst shadowTextareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\n\n...\n\n/** get height with shadow textarea */\nconst setAutoSize = () =&gt; {\n  if (!textareaRef.current || !shadowTextareaRef.current) return;\n\n  const { scrollHeight: shadowHeight } = shadowTextareaRef.current;\n\t// 그림자의 scroll height를 이용해 높이를 구함\n  const { height: curHeight } = textareaRef.current.style;\n\n  // maximum height is 83px when textarea has 3 line\n  if (curHeight === `${shadowHeight}px` || shadowHeight &gt;= 90) return;\n\t// 그림자의 scroll height가 사용 가능할 시, 실제 textarea의 높이로 사용\n  textareaRef.current.style.height = `${shadowHeight}px`;\n};\n\n...\n\nuseEffect(() =&gt; {\n  setAutoSize();\n}, [chatValue]);\n\n&lt;S.ChatTextareaWrapper&gt;\n  &lt;S.ChatTextarea\n    ref={textareaRef}\n    rows={1}\n    spellCheck={false}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    placeholder='메시지를 입력하세요.'\n  /&gt;\n\t// 그림자 태그를 만들어 뒤에 숨어있도록 설정\n  &lt;S.ChatTextarea\n    ref={shadowTextareaRef}\n    isShadow={true}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    readOnly\n    tabIndex={-1}\n  /&gt;\n&lt;/S.ChatTextareaWrapper&gt;\n\n\n이후 기본 textarea, 그림자 textarea 두 개를 주어, scroll height가 바뀌는 상황(채팅 값이 써지면서 높이가 변할 때)에서 함수가 동작할 수 있도록 설정했습니다. 이를 통해, 채팅이 써지고 지워지는 상황에 채팅창의 높이가 올라갔다가 내려가는 것을 확인할 수 있었습니다.\n\n\n   \n\n\n하지만, 위 그림에서 보이듯 하나의 문제점이 더 존재하는데, 채팅이 써지고 이 채팅이 최종 입력되는 상황에서 기존 채팅이 가려지는 것이 문제가 되었습니다.\n\n채팅창의 높이가 올라갈 때 채팅 내용도 올려주기\n\n이 부분에 대해 진행을 하면서 가장 우선적으로 고민했던 것은 채팅창의 스타일 형태였습니다. 현재 만들고 있는 채팅창의 스타일의 경우, position: fixed로 설정이 되어있었고, 이로 인해 채팅창 뒤에 존재하는 채팅 내용 일부가 가려지는 곳을 다시 올려주는 형태로 이루어져있었습니다. 하지만, 인스타그램의 DM과 같은 곳에서 확인해본 결과, 그 곳에서는 fixed가 아닌 일반적인 position 설정을 하고 채팅 내용 부분에만 스크롤이 이루어질 수 있도록 설정이 되어있었습니다.\n\n이 부분에서 저는 fixed를 그대로 활용하는 쪽으로 진행하게 되었습니다. 그 이유는 모바일 브라우저의 경우 최상단으로 가기 위한 단축키로 화면 최상단을 더블탭하는 방법이 있는데, 이 방법이 작동하기 위해서는 자식 태그가 아닌 전체 앱 내에서 스크롤이 이루어지는 현재 방식이어야 하기 때문입니다.\n\nposition: fixed로 결정한 이후,현재의 문제를 해결하기 위해 진행할 것은, 채팅창 내의 스크롤이 발생하는 시점마다 채팅 내용의 스크롤도 올려주는 것이었습니다. 이를 위해 기존 채팅창 컴포넌트 내에 onHeightChange라는 높이가 바뀔 때에 처리할 함수를 받는 새로운 prop을 추가했습니다. 그리고 이 곳에 높이가 바뀔 때 채팅 내용 부분에 스크롤이 다시 이루어질 수 있도록 설정을 했습니다.\n\nconst [blockHeight, setBlockHeight] = useState(0);\n...\nconst scrollToBottom = () =&gt; {\n  lastBlockRef.current?.scrollIntoView({ block: 'end' });\n};\n...\nconst changeBlockHeight = (height: number) =&gt; {\n  setBlockHeight(height);\n  scrollToBottom();\n\t// 블록 높이를 바꾸고, 스크롤을 한 번 더 진행하도록 설정\n};\n\n...\n\nreturn (\n  &lt;&gt;\n    &lt;S.Wrapper&gt;\n      {chatroomLogs}\n      &lt;S.LastBottomBlock ref={scrollToBottomRef} blockHeight={blockHeight} /&gt;\n\t\t\t// 채팅창 뒤 빈 영역을 채워주는 블록\n    &lt;/S.Wrapper&gt;\n    &lt;ChatroomBar chatroomId={Number(chatroomId)} onHeightChange={changeBlockHeight} /&gt;\n\t\t// 채팅창의 높이가 변할 시 블록 높이를 바꾸도록 설정\n  &lt;/&gt;\n);\n\n\n위 과정을 통해서 아래와 같이 자동으로 높이가 조절되는 채팅창을 만들어낼 수 있었습니다.\n\n\n   \n\n\n",
        "url": "/react/2022/10/26/textarea-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88%ED%95%98%EA%B8%B0/"
      },
    
      {
        "title": "textarea 줄바꿈 시 자동 스크롤",
        "feature_text": "React에서 textarea 줄바꿈 시 자동 스크롤이 되도록 만들기\n",
        "excerpt": "textarea 태그 내 줄바꿈 시 문제점\n\ntextarea 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 input 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. input 태그는 한 줄로만 이어져 줄바꿈이 없었지만, textarea는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다.\n\n\n   \n\n\n이러한 문제를 해결하기 위한 방법으로 처음에는 line-height를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다.\n\n스크롤을 최하단으로 내리기\n\n이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\n// textarea 태그를 받아오기 위한 ref\n\nconst handleScrollTextarea = () =&gt; {\n  // scroll이 발생하는 상황 시\n  if (!textareaRef.current) return;\n  textareaRef.current.scrollTop = textareaRef.current.scrollHeight;\n  // 스크롤의 위치를 textarea의 최하단으로 옮김\n};\n\n&lt;S.ChatTextarea\n  ref={textareaRef}\n  onScroll={handleScrollTextarea}\n  // 스크롤 발생 시 함수 적용\n  placeholder=\"메시지를 입력하세요.\"\n/&gt;;\n\n\n하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다.\n\n\n   \n\n\n특정 상황에서만 스크롤을 강제로 내리기\n\n위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\nconst scrollWithTypingRef = useRef(false);\n// 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref\nconst typingTimeoutRef = useRef&lt;NodeJS.Timeout&gt;();\n// 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref\n\n/** handler for type key */\nconst handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { inputType } = event.nativeEvent as any;\n  if (inputType === 'insertLineBreak') return;\n  setChatValue(event.target.value);\n\n  if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current);\n  // 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce)\n  scrollWithTypingRef.current = true;\n  // 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정\n  typingTimeoutRef.current = setTimeout(() =&gt; (scrollWithTypingRef.current = false), 500);\n  // 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정\n};\n\n/** handler for type 'Enter' key */\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey, keyCode } = event;\n  // 'keyCode' is deprecated but error occurs when just use 'key' in korean\n\n  if (key !== 'Enter' || keyCode !== 13) return;\n  if (!shiftKey) {\n    sendCurChat();\n  } else {\n    scrollWithTypingRef.current = true;\n    // Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정\n    setChatValue(chatValue + '\\n');\n    // 줄바꿈 추가를 통해 스크롤을 발생시킴\n  }\n};\n\n/** handler for auto scroll during typing */\nconst handleScrollTextarea = () =&gt; {\n  if (!textareaRef.current || !scrollWithTypingRef.current) return;\n  textareaRef.current.scrollTop = textareaRef.current.scrollHeight;\n  scrollWithTypingRef.current = false;\n  // 스크롤이 발생했으므로, 다시 false로 설정\n};\n\nreturn (\n  ...\n  &lt;S.ChatTextarea\n    ref={textareaRef}\n    rows={1}\n    spellCheck={false}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    placeholder='메시지를 입력하세요.'\n  /&gt;\n  ...\n)\n\n\n위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다.\n\n\n  ‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생\n  줄바꿈 이전에 실행된 입력으로 인해 scrollWithTypingRef.current = true; 설정\n  onScroll에서 scrollWithTypingRef.current = true;여부 확인\n  true일 시 자동 스크롤 발생\n  scrollWithTypingRef.current = false;로 설정\n\n\n결과\n\n위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.\n\n\n   \n\n\n",
        "content": "textarea 태그 내 줄바꿈 시 문제점\n\ntextarea 태그를 적용하면서, 줄바꿈이 발생하는 경우 기존에 input 태그를 쓸 때에는 겪지 못했던 문제가 있었습니다. input 태그는 한 줄로만 이어져 줄바꿈이 없었지만, textarea는 줄바꿈을 할 때 아래 사진과 같이 아래로 뻗쳐지는 글자(’j’, ‘g’)가 아래로 튀어나와 다음 영역을 간섭했습니다. 이는 스크롤이 최하단까지 내려가지 않는 것에서 문제가 비롯되었습니다.\n\n\n   \n\n\n이러한 문제를 해결하기 위한 방법으로 처음에는 line-height를 적용해봤으나, 이 방법을 적용해도 위와 같은 상황이 바뀌지는 않았습니다.\n\n스크롤을 최하단으로 내리기\n\n이를 해결하기 위해서 ‘글자가 하단으로 내려가는 상황’을 가려낼 필요가 있었습니다. 현재 적용된 textarea에서는 ‘Shift + Enter를 누를 때’, ‘글자가 일정 너비를 넘어갈 때’ 총 두 가지 경우에서 줄 바꿈이 발생했습니다. 그리고 이 줄 바꿈이 발생할 시, 스크롤이 자동적으로 내려가게 되었습니다. 그래서 스크롤을 강제적으로 최하단까지 내리면 간섭이 사라지게 되므로, 줄바꿈 상황 시 스크롤을 내리는 기능을 우선 만들어주었습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\n// textarea 태그를 받아오기 위한 ref\n\nconst handleScrollTextarea = () =&gt; {\n  // scroll이 발생하는 상황 시\n  if (!textareaRef.current) return;\n  textareaRef.current.scrollTop = textareaRef.current.scrollHeight;\n  // 스크롤의 위치를 textarea의 최하단으로 옮김\n};\n\n&lt;S.ChatTextarea\n  ref={textareaRef}\n  onScroll={handleScrollTextarea}\n  // 스크롤 발생 시 함수 적용\n  placeholder=\"메시지를 입력하세요.\"\n/&gt;;\n\n\n하지만, 이렇게 진행할 경우, 한 가지 문제가 발생하게 되는데, 스크롤 하는 상황에서 강제로 높이 지정을 하다보니 작성할 채팅을 스크롤로 올려보고 싶을 때 이 상황이 불가능했습니다.\n\n\n   \n\n\n특정 상황에서만 스크롤을 강제로 내리기\n\n위 문제를 해결하기 위해서, 스크롤을 강제로 내리는 상황을 지정해주어야 했습니다. 스크롤이 강제로 내려가야되는 상황은 ‘타이핑을 통해 줄이 바뀔 때’와 ‘Enter + Shift 키를 누를 때’ 뿐이므로, 이 두 상황이 발생한 뒤에는 다시 스크롤이 가능하도록 지정해주면 되었습니다.\n\nconst textareaRef = useRef&lt;HTMLTextAreaElement&gt;(null);\nconst scrollWithTypingRef = useRef(false);\n// 스크롤이 타이핑으로 인해 발생할 시 true가 될 ref\nconst typingTimeoutRef = useRef&lt;NodeJS.Timeout&gt;();\n// 타이핑이 연속으로 발생할 시, 이전 set timeout을 삭제하기 위한 ref\n\n/** handler for type key */\nconst handleChangeChatValue = (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { inputType } = event.nativeEvent as any;\n  if (inputType === 'insertLineBreak') return;\n  setChatValue(event.target.value);\n\n  if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current);\n  // 타이핑이 연속적으로 발생할 경우, 이전 set timeout을 제거 (Debounce)\n  scrollWithTypingRef.current = true;\n  // 타이핑으로 스크롤이 발생할 수 있으므로 true로 설정\n  typingTimeoutRef.current = setTimeout(() =&gt; (scrollWithTypingRef.current = false), 500);\n  // 0.5초 내에 타이핑이 다시 발생하지 않을 경우, 타이핑으로 스크롤이 발생하지 않을 것이므로 false로 설정\n};\n\n/** handler for type 'Enter' key */\nconst handleKeyDownChat = (event: KeyboardEvent&lt;HTMLTextAreaElement&gt;) =&gt; {\n  const { key, shiftKey, keyCode } = event;\n  // 'keyCode' is deprecated but error occurs when just use 'key' in korean\n\n  if (key !== 'Enter' || keyCode !== 13) return;\n  if (!shiftKey) {\n    sendCurChat();\n  } else {\n    scrollWithTypingRef.current = true;\n    // Enter + Shift 키가 적용된 상황에서 스크롤이 발생할 것이므로 true로 미리 설정\n    setChatValue(chatValue + '\\n');\n    // 줄바꿈 추가를 통해 스크롤을 발생시킴\n  }\n};\n\n/** handler for auto scroll during typing */\nconst handleScrollTextarea = () =&gt; {\n  if (!textareaRef.current || !scrollWithTypingRef.current) return;\n  textareaRef.current.scrollTop = textareaRef.current.scrollHeight;\n  scrollWithTypingRef.current = false;\n  // 스크롤이 발생했으므로, 다시 false로 설정\n};\n\nreturn (\n  ...\n  &lt;S.ChatTextarea\n    ref={textareaRef}\n    rows={1}\n    spellCheck={false}\n    value={chatValue}\n    onKeyDown={handleKeyDownChat}\n    onChange={handleChangeChatValue}\n    onScroll={handleScrollTextarea}\n    placeholder='메시지를 입력하세요.'\n  /&gt;\n  ...\n)\n\n\n위 코드로 인해 자동 스크롤이 발생하는 순서는 아래와 같습니다.\n\n\n  ‘Enter + Shift’ 또는 타이핑으로 인해 줄바꿈이 발생\n  줄바꿈 이전에 실행된 입력으로 인해 scrollWithTypingRef.current = true; 설정\n  onScroll에서 scrollWithTypingRef.current = true;여부 확인\n  true일 시 자동 스크롤 발생\n  scrollWithTypingRef.current = false;로 설정\n\n\n결과\n\n위 설정들을 통해서 스크롤을 발생시킬 수 있었고, 아래 그림과 같이 줄바꿈이 발생할 때 자동 스크롤로 채팅을 간섭없이 보여줄 수 있었습니다.\n\n\n   \n\n\n",
        "url": "/react/2022/10/26/textarea-%EC%A4%84%EB%B0%94%EA%BF%88-%EC%8B%9C-%EC%9E%90%EB%8F%99-%EC%8A%A4%ED%81%AC%EB%A1%A4/"
      },
    
  
  
  
  {
    "title": "CATEGORIES",
    "feature_text": null,
    "excerpt": "CATEGORIES\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "SEARCH",
    "feature_text": null,
    "excerpt": "SEARCH FOR A PAGE OR POST\n",
    "content": "{% include site-search.html %}\n",
    "url": "/search/"
  }
  
]

